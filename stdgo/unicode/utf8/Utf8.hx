package stdgo.unicode.utf8;
import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;
var _first : GoArray<GoUInt8> = ((new GoArray<GoUInt8>(
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((240 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((2 : GoUInt8)),
((19 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((35 : GoUInt8)),
((3 : GoUInt8)),
((3 : GoUInt8)),
((52 : GoUInt8)),
((4 : GoUInt8)),
((4 : GoUInt8)),
((4 : GoUInt8)),
((68 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8)),
((241 : GoUInt8))) : GoArray<GoUInt8>));
var _acceptRanges : GoArray<T_acceptRange> = {
    var s:GoArray<T_acceptRange> = new GoArray<T_acceptRange>(...[for (i in 0 ... 16) new T_acceptRange()]);
    s[0] = ((new T_acceptRange(((128 : GoUInt8)), ((191 : GoUInt8))) : T_acceptRange));
    s[1] = ((new T_acceptRange(((160 : GoUInt8)), ((191 : GoUInt8))) : T_acceptRange));
    s[2] = ((new T_acceptRange(((128 : GoUInt8)), ((159 : GoUInt8))) : T_acceptRange));
    s[3] = ((new T_acceptRange(((144 : GoUInt8)), ((191 : GoUInt8))) : T_acceptRange));
    s[4] = ((new T_acceptRange(((128 : GoUInt8)), ((143 : GoUInt8))) : T_acceptRange));
    s;
};
@:structInit class T_acceptRange {
    public var _lo : GoUInt8 = ((0 : GoUInt8));
    public var _hi : GoUInt8 = ((0 : GoUInt8));
    public function new(?_lo:GoUInt8, ?_hi:GoUInt8) {
        if (_lo != null) this._lo = _lo;
        if (_hi != null) this._hi = _hi;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_acceptRange(_lo, _hi);
    }
}
/**
    // FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.
    // An invalid encoding is considered a full Rune since it will convert as a width-1 error rune.
**/
function fullRune(_p:Slice<GoByte>):Bool {
        var _n:GoInt = (_p != null ? _p.length : ((0 : GoInt)));
        if (_n == ((0 : GoInt))) {
            return false;
        };
        var _x:GoUInt8 = (_first != null ? _first[(_p != null ? _p[((0 : GoInt))] : ((0 : GoUInt8)))] : ((0 : GoUInt8)));
        if (_n >= (((_x & ((7 : GoUInt8))) : GoInt))) {
            return true;
        };
        var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
        if ((_n > ((1 : GoInt))) && (((_p != null ? _p[((1 : GoInt))] : ((0 : GoUInt8))) < _accept._lo) || (_accept._hi < (_p != null ? _p[((1 : GoInt))] : ((0 : GoUInt8)))))) {
            return true;
        } else if ((_n > ((2 : GoInt))) && (((_p != null ? _p[((2 : GoInt))] : ((0 : GoUInt8))) < ((128 : GoUInt8))) || (((191 : GoUInt8)) < (_p != null ? _p[((2 : GoInt))] : ((0 : GoUInt8)))))) {
            return true;
        };
        return false;
    }
/**
    // FullRuneInString is like FullRune but its input is a string.
**/
function fullRuneInString(_s:GoString):Bool {
        var _n:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        if (_n == ((0 : GoInt))) {
            return false;
        };
        var _x:GoUInt8 = (_first != null ? _first[(_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8)))] : ((0 : GoUInt8)));
        if (_n >= (((_x & ((7 : GoUInt8))) : GoInt))) {
            return true;
        };
        var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
        if ((_n > ((1 : GoInt))) && (((_s != null ? _s[((1 : GoInt))] : ((0 : GoUInt8))) < _accept._lo) || (_accept._hi < (_s != null ? _s[((1 : GoInt))] : ((0 : GoUInt8)))))) {
            return true;
        } else if ((_n > ((2 : GoInt))) && (((_s != null ? _s[((2 : GoInt))] : ((0 : GoUInt8))) < ((128 : GoUInt8))) || (((191 : GoUInt8)) < (_s != null ? _s[((2 : GoInt))] : ((0 : GoUInt8)))))) {
            return true;
        };
        return false;
    }
/**
    // DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and
    // its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
    // the encoding is invalid, it returns (RuneError, 1). Both are impossible
    // results for correct, non-empty UTF-8.
    //
    // An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
    // out of range, or is not the shortest possible UTF-8 encoding for the
    // value. No other validation is performed.
**/
function decodeRune(_p:Slice<GoByte>):{ var _0 : GoRune; var _1 : GoInt; } {
        var _r:GoRune = ((0 : GoInt32)), _size:GoInt = ((0 : GoInt));
        var _n:GoInt = (_p != null ? _p.length : ((0 : GoInt)));
        if (_n < ((1 : GoInt))) {
            return { _0 : ((65533 : GoInt32)), _1 : ((0 : GoInt)) };
        };
        var _p0:GoUInt8 = (_p != null ? _p[((0 : GoInt))] : ((0 : GoUInt8)));
        var _x:GoUInt8 = (_first != null ? _first[_p0] : ((0 : GoUInt8)));
        if (_x >= ((240 : GoUInt8))) {
            var _mask:GoInt32 = (((_x : GoRune)) << ((31 : GoUnTypedInt))) >> ((31 : GoUnTypedInt));
            return { _0 : ((((_p != null ? _p[((0 : GoInt))] : ((0 : GoUInt8))) : GoRune)) & (_mask ^ ((-1 : GoUnTypedInt)))) | (((65533 : GoInt32)) & _mask), _1 : ((1 : GoInt)) };
        };
        var _sz:GoInt = (((_x & ((7 : GoUInt8))) : GoInt));
        var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
        if (_n < _sz) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        var _b1:GoUInt8 = (_p != null ? _p[((1 : GoInt))] : ((0 : GoUInt8)));
        if ((_b1 < _accept._lo) || (_accept._hi < _b1)) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        if (_sz <= ((2 : GoInt))) {
            return { _0 : ((((_p0 & ((31 : GoUInt8))) : GoRune)) << ((6 : GoUnTypedInt))) | (((_b1 & ((63 : GoUInt8))) : GoRune)), _1 : ((2 : GoInt)) };
        };
        var _b2:GoUInt8 = (_p != null ? _p[((2 : GoInt))] : ((0 : GoUInt8)));
        if ((_b2 < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _b2)) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        if (_sz <= ((3 : GoInt))) {
            return { _0 : (((((_p0 & ((15 : GoUInt8))) : GoRune)) << ((12 : GoUnTypedInt))) | ((((_b1 & ((63 : GoUInt8))) : GoRune)) << ((6 : GoUnTypedInt)))) | (((_b2 & ((63 : GoUInt8))) : GoRune)), _1 : ((3 : GoInt)) };
        };
        var _b3:GoUInt8 = (_p != null ? _p[((3 : GoInt))] : ((0 : GoUInt8)));
        if ((_b3 < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _b3)) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        return { _0 : ((((((_p0 & ((7 : GoUInt8))) : GoRune)) << ((18 : GoUnTypedInt))) | ((((_b1 & ((63 : GoUInt8))) : GoRune)) << ((12 : GoUnTypedInt)))) | ((((_b2 & ((63 : GoUInt8))) : GoRune)) << ((6 : GoUnTypedInt)))) | (((_b3 & ((63 : GoUInt8))) : GoRune)), _1 : ((4 : GoInt)) };
    }
/**
    // DecodeRuneInString is like DecodeRune but its input is a string. If s is
    // empty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it
    // returns (RuneError, 1). Both are impossible results for correct, non-empty
    // UTF-8.
    //
    // An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
    // out of range, or is not the shortest possible UTF-8 encoding for the
    // value. No other validation is performed.
**/
function decodeRuneInString(_s:GoString):{ var _0 : GoRune; var _1 : GoInt; } {
        var _r:GoRune = ((0 : GoInt32)), _size:GoInt = ((0 : GoInt));
        var _n:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        if (_n < ((1 : GoInt))) {
            return { _0 : ((65533 : GoInt32)), _1 : ((0 : GoInt)) };
        };
        var _s0:GoUInt8 = (_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8)));
        var _x:GoUInt8 = (_first != null ? _first[_s0] : ((0 : GoUInt8)));
        if (_x >= ((240 : GoUInt8))) {
            var _mask:GoInt32 = (((_x : GoRune)) << ((31 : GoUnTypedInt))) >> ((31 : GoUnTypedInt));
            return { _0 : ((((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) : GoRune)) & (_mask ^ ((-1 : GoUnTypedInt)))) | (((65533 : GoInt32)) & _mask), _1 : ((1 : GoInt)) };
        };
        var _sz:GoInt = (((_x & ((7 : GoUInt8))) : GoInt));
        var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
        if (_n < _sz) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        var _s1:GoUInt8 = (_s != null ? _s[((1 : GoInt))] : ((0 : GoUInt8)));
        if ((_s1 < _accept._lo) || (_accept._hi < _s1)) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        if (_sz <= ((2 : GoInt))) {
            return { _0 : ((((_s0 & ((31 : GoUInt8))) : GoRune)) << ((6 : GoUnTypedInt))) | (((_s1 & ((63 : GoUInt8))) : GoRune)), _1 : ((2 : GoInt)) };
        };
        var _s2:GoUInt8 = (_s != null ? _s[((2 : GoInt))] : ((0 : GoUInt8)));
        if ((_s2 < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _s2)) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        if (_sz <= ((3 : GoInt))) {
            return { _0 : (((((_s0 & ((15 : GoUInt8))) : GoRune)) << ((12 : GoUnTypedInt))) | ((((_s1 & ((63 : GoUInt8))) : GoRune)) << ((6 : GoUnTypedInt)))) | (((_s2 & ((63 : GoUInt8))) : GoRune)), _1 : ((3 : GoInt)) };
        };
        var _s3:GoUInt8 = (_s != null ? _s[((3 : GoInt))] : ((0 : GoUInt8)));
        if ((_s3 < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _s3)) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        return { _0 : ((((((_s0 & ((7 : GoUInt8))) : GoRune)) << ((18 : GoUnTypedInt))) | ((((_s1 & ((63 : GoUInt8))) : GoRune)) << ((12 : GoUnTypedInt)))) | ((((_s2 & ((63 : GoUInt8))) : GoRune)) << ((6 : GoUnTypedInt)))) | (((_s3 & ((63 : GoUInt8))) : GoRune)), _1 : ((4 : GoInt)) };
    }
/**
    // DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and
    // its width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if
    // the encoding is invalid, it returns (RuneError, 1). Both are impossible
    // results for correct, non-empty UTF-8.
    //
    // An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
    // out of range, or is not the shortest possible UTF-8 encoding for the
    // value. No other validation is performed.
**/
function decodeLastRune(_p:Slice<GoByte>):{ var _0 : GoRune; var _1 : GoInt; } {
        var _r:GoRune = ((0 : GoInt32)), _size:GoInt = ((0 : GoInt));
        var _end:GoInt = (_p != null ? _p.length : ((0 : GoInt)));
        if (_end == ((0 : GoInt))) {
            return { _0 : ((65533 : GoInt32)), _1 : ((0 : GoInt)) };
        };
        var _start:GoInt = _end - ((1 : GoInt));
        _r = (((_p != null ? _p[_start] : ((0 : GoUInt8))) : GoRune));
        if (_r < ((128 : GoInt32))) {
            return { _0 : _r, _1 : ((1 : GoInt)) };
        };
        var _lim:GoInt = _end - ((4 : GoInt));
        if (_lim < ((0 : GoInt))) {
            _lim = ((0 : GoInt));
        };
        {
            _start--;
            Go.cfor(_start >= _lim, _start--, {
                if (runeStart((_p != null ? _p[_start] : ((0 : GoUInt8))))) {
                    break;
                };
            });
        };
        if (_start < ((0 : GoInt))) {
            _start = ((0 : GoInt));
        };
        {
            var __tmp__ = decodeRune(_p.__slice__(_start, _end));
            _r = __tmp__._0;
            _size = __tmp__._1;
        };
        if ((_start + _size) != _end) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        return { _0 : _r, _1 : _size };
    }
/**
    // DecodeLastRuneInString is like DecodeLastRune but its input is a string. If
    // s is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,
    // it returns (RuneError, 1). Both are impossible results for correct,
    // non-empty UTF-8.
    //
    // An encoding is invalid if it is incorrect UTF-8, encodes a rune that is
    // out of range, or is not the shortest possible UTF-8 encoding for the
    // value. No other validation is performed.
**/
function decodeLastRuneInString(_s:GoString):{ var _0 : GoRune; var _1 : GoInt; } {
        var _r:GoRune = ((0 : GoInt32)), _size:GoInt = ((0 : GoInt));
        var _end:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        if (_end == ((0 : GoInt))) {
            return { _0 : ((65533 : GoInt32)), _1 : ((0 : GoInt)) };
        };
        var _start:GoInt = _end - ((1 : GoInt));
        _r = (((_s != null ? _s[_start] : ((0 : GoUInt8))) : GoRune));
        if (_r < ((128 : GoInt32))) {
            return { _0 : _r, _1 : ((1 : GoInt)) };
        };
        var _lim:GoInt = _end - ((4 : GoInt));
        if (_lim < ((0 : GoInt))) {
            _lim = ((0 : GoInt));
        };
        {
            _start--;
            Go.cfor(_start >= _lim, _start--, {
                if (runeStart((_s != null ? _s[_start] : ((0 : GoUInt8))))) {
                    break;
                };
            });
        };
        if (_start < ((0 : GoInt))) {
            _start = ((0 : GoInt));
        };
        {
            var __tmp__ = decodeRuneInString(_s.__slice__(_start, _end));
            _r = __tmp__._0;
            _size = __tmp__._1;
        };
        if ((_start + _size) != _end) {
            return { _0 : ((65533 : GoInt32)), _1 : ((1 : GoInt)) };
        };
        return { _0 : _r, _1 : _size };
    }
/**
    // RuneLen returns the number of bytes required to encode the rune.
    // It returns -1 if the rune is not a valid value to encode in UTF-8.
**/
function runeLen(_r:GoRune):GoInt {
        if (_r < ((0 : GoInt32))) {
            return ((-1 : GoInt));
        } else if (_r <= ((127 : GoInt32))) {
            return ((1 : GoInt));
        } else if (_r <= ((2047 : GoInt32))) {
            return ((2 : GoInt));
        } else if ((((55296 : GoInt32)) <= _r) && (_r <= ((57343 : GoInt32)))) {
            return ((-1 : GoInt));
        } else if (_r <= ((65535 : GoInt32))) {
            return ((3 : GoInt));
        } else if (_r <= ((1114111 : GoInt32))) {
            return ((4 : GoInt));
        };
        return ((-1 : GoInt));
    }
/**
    // EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.
    // If the rune is out of range, it writes the encoding of RuneError.
    // It returns the number of bytes written.
**/
function encodeRune(_p:Slice<GoByte>, _r:GoRune):GoInt {
        {
            var _i:GoUInt32 = ((_r : GoUInt32));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _i <= ((127 : GoUInt32)))) {
                        if (_p != null) _p[((0 : GoInt))] = ((_r : GoByte));
                        return ((1 : GoInt));
                        break;
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _i <= ((2047 : GoUInt32)))) {
                        (_p != null ? _p[((1 : GoInt))] : ((0 : GoUInt8)));
                        if (_p != null) _p[((0 : GoInt))] = ((192 : GoUInt8)) | (((_r >> ((6 : GoUnTypedInt))) : GoByte));
                        if (_p != null) _p[((1 : GoInt))] = ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)));
                        return ((2 : GoInt));
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _i > ((1114111 : GoUInt32)) || (((55296 : GoUInt32)) <= _i) && (_i <= ((57343 : GoUInt32))))) {
                        _r = ((65533 : GoInt32));
                        @:fallthrough {
                            __switchIndex__ = 3;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _i <= ((65535 : GoUInt32)))) {
                        (_p != null ? _p[((2 : GoInt))] : ((0 : GoUInt8)));
                        if (_p != null) _p[((0 : GoInt))] = ((224 : GoUInt8)) | (((_r >> ((12 : GoUnTypedInt))) : GoByte));
                        if (_p != null) _p[((1 : GoInt))] = ((128 : GoUInt8)) | ((((_r >> ((6 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8)));
                        if (_p != null) _p[((2 : GoInt))] = ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)));
                        return ((3 : GoInt));
                        break;
                        break;
                    } else {
                        (_p != null ? _p[((3 : GoInt))] : ((0 : GoUInt8)));
                        if (_p != null) _p[((0 : GoInt))] = ((240 : GoUInt8)) | (((_r >> ((18 : GoUnTypedInt))) : GoByte));
                        if (_p != null) _p[((1 : GoInt))] = ((128 : GoUInt8)) | ((((_r >> ((12 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8)));
                        if (_p != null) _p[((2 : GoInt))] = ((128 : GoUInt8)) | ((((_r >> ((6 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8)));
                        if (_p != null) _p[((3 : GoInt))] = ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)));
                        return ((4 : GoInt));
                        break;
                    };
                    break;
                };
                return ((0 : GoInt));
            };
        };
    }
/**
    // AppendRune appends the UTF-8 encoding of r to the end of p and
    // returns the extended buffer. If the rune is out of range,
    // it appends the encoding of RuneError.
**/
function appendRune(_p:Slice<GoByte>, _r:GoRune):Slice<GoByte> {
        if (((_r : GoUInt32)) <= ((127 : GoUInt32))) {
            return (_p != null ? _p.__append__(((_r : GoByte))) : new Slice(((_r : GoByte))));
        };
        return _appendRuneNonASCII(_p, _r);
    }
function _appendRuneNonASCII(_p:Slice<GoByte>, _r:GoRune):Slice<GoByte> {
        {
            var _i:GoUInt32 = ((_r : GoUInt32));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _i <= ((2047 : GoUInt32)))) {
                        return (_p != null ? _p.__append__(((192 : GoUInt8)) | (((_r >> ((6 : GoUnTypedInt))) : GoByte)), ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)))) : new Slice(((192 : GoUInt8)) | (((_r >> ((6 : GoUnTypedInt))) : GoByte)), ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)))));
                        break;
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _i > ((1114111 : GoUInt32)) || (((55296 : GoUInt32)) <= _i) && (_i <= ((57343 : GoUInt32))))) {
                        _r = ((65533 : GoInt32));
                        @:fallthrough {
                            __switchIndex__ = 2;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _i <= ((65535 : GoUInt32)))) {
                        return (_p != null ? _p.__append__(((224 : GoUInt8)) | (((_r >> ((12 : GoUnTypedInt))) : GoByte)), ((128 : GoUInt8)) | ((((_r >> ((6 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8))), ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)))) : new Slice(((224 : GoUInt8)) | (((_r >> ((12 : GoUnTypedInt))) : GoByte)), ((128 : GoUInt8)) | ((((_r >> ((6 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8))), ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)))));
                        break;
                        break;
                    } else {
                        return (_p != null ? _p.__append__(((240 : GoUInt8)) | (((_r >> ((18 : GoUnTypedInt))) : GoByte)), ((128 : GoUInt8)) | ((((_r >> ((12 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8))), ((128 : GoUInt8)) | ((((_r >> ((6 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8))), ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)))) : new Slice(((240 : GoUInt8)) | (((_r >> ((18 : GoUnTypedInt))) : GoByte)), ((128 : GoUInt8)) | ((((_r >> ((12 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8))), ((128 : GoUInt8)) | ((((_r >> ((6 : GoUnTypedInt))) : GoByte)) & ((63 : GoUInt8))), ((128 : GoUInt8)) | (((_r : GoByte)) & ((63 : GoUInt8)))));
                        break;
                    };
                    break;
                };
                return ((null : Slice<GoUInt8>));
            };
        };
    }
/**
    // RuneCount returns the number of runes in p. Erroneous and short
    // encodings are treated as single runes of width 1 byte.
**/
function runeCount(_p:Slice<GoByte>):GoInt {
        var _np:GoInt = (_p != null ? _p.length : ((0 : GoInt)));
        var _n:GoInt = ((0 : GoInt));
        {
            var _i:GoInt = ((0 : GoInt));
            while (_i < _np) {
                _n++;
                var _c:GoUInt8 = (_p != null ? _p[_i] : ((0 : GoUInt8)));
                if (_c < ((128 : GoUInt8))) {
                    _i++;
                    continue;
                };
                var _x:GoUInt8 = (_first != null ? _first[_c] : ((0 : GoUInt8)));
                if (_x == ((241 : GoUInt8))) {
                    _i++;
                    continue;
                };
                var _size:GoInt = (((_x & ((7 : GoUInt8))) : GoInt));
                if ((_i + _size) > _np) {
                    _i++;
                    continue;
                };
                var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
                {
                    var _c:GoUInt8 = (_p != null ? _p[_i + ((1 : GoInt))] : ((0 : GoUInt8)));
                    if ((_c < _accept._lo) || (_accept._hi < _c)) {
                        _size = ((1 : GoInt));
                    } else if (_size == ((2 : GoInt))) {} else {
                        var _c:GoUInt8 = (_p != null ? _p[_i + ((2 : GoInt))] : ((0 : GoUInt8)));
                        if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                            _size = ((1 : GoInt));
                        } else if (_size == ((3 : GoInt))) {} else {
                            var _c:GoUInt8 = (_p != null ? _p[_i + ((3 : GoInt))] : ((0 : GoUInt8)));
                            if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                                _size = ((1 : GoInt));
                            };
                        };
                    };
                };
                _i = _i + (_size);
            };
        };
        return _n;
    }
/**
    // RuneCountInString is like RuneCount but its input is a string.
**/
function runeCountInString(_s:GoString):GoInt {
        var _n:GoInt = ((0 : GoInt));
        var _ns:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _ns, _n++, {
                var _c:GoUInt8 = (_s != null ? _s[_i] : ((0 : GoUInt8)));
                if (_c < ((128 : GoUInt8))) {
                    _i++;
                    continue;
                };
                var _x:GoUInt8 = (_first != null ? _first[_c] : ((0 : GoUInt8)));
                if (_x == ((241 : GoUInt8))) {
                    _i++;
                    continue;
                };
                var _size:GoInt = (((_x & ((7 : GoUInt8))) : GoInt));
                if ((_i + _size) > _ns) {
                    _i++;
                    continue;
                };
                var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
                {
                    var _c:GoUInt8 = (_s != null ? _s[_i + ((1 : GoInt))] : ((0 : GoUInt8)));
                    if ((_c < _accept._lo) || (_accept._hi < _c)) {
                        _size = ((1 : GoInt));
                    } else if (_size == ((2 : GoInt))) {} else {
                        var _c:GoUInt8 = (_s != null ? _s[_i + ((2 : GoInt))] : ((0 : GoUInt8)));
                        if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                            _size = ((1 : GoInt));
                        } else if (_size == ((3 : GoInt))) {} else {
                            var _c:GoUInt8 = (_s != null ? _s[_i + ((3 : GoInt))] : ((0 : GoUInt8)));
                            if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                                _size = ((1 : GoInt));
                            };
                        };
                    };
                };
                _i = _i + (_size);
            });
        };
        return _n;
    }
/**
    // RuneStart reports whether the byte could be the first byte of an encoded,
    // possibly invalid rune. Second and subsequent bytes always have the top two
    // bits set to 10.
**/
function runeStart(_b:GoByte):Bool {
        return (_b & ((192 : GoUInt8))) != ((128 : GoUInt8));
    }
/**
    // Valid reports whether p consists entirely of valid UTF-8-encoded runes.
**/
function valid(_p:Slice<GoByte>):Bool {
        while ((_p != null ? _p.length : ((0 : GoInt))) >= ((8 : GoInt))) {
            var _first32:GoUInt32 = (((((_p != null ? _p[((0 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) | ((((_p != null ? _p[((1 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((8 : GoUnTypedInt)))) | ((((_p != null ? _p[((2 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((16 : GoUnTypedInt)))) | ((((_p != null ? _p[((3 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((24 : GoUnTypedInt)));
            var _second32:GoUInt32 = (((((_p != null ? _p[((4 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) | ((((_p != null ? _p[((5 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((8 : GoUnTypedInt)))) | ((((_p != null ? _p[((6 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((16 : GoUnTypedInt)))) | ((((_p != null ? _p[((7 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((24 : GoUnTypedInt)));
            if (((_first32 | _second32) & (("2155905152" : GoUInt32))) != ((0 : GoUInt32))) {
                break;
            };
            _p = _p.__slice__(((8 : GoInt)));
        };
        var _n:GoInt = (_p != null ? _p.length : ((0 : GoInt)));
        {
            var _i:GoInt = ((0 : GoInt));
            while (_i < _n) {
                var _pi:GoUInt8 = (_p != null ? _p[_i] : ((0 : GoUInt8)));
                if (_pi < ((128 : GoUInt8))) {
                    _i++;
                    continue;
                };
                var _x:GoUInt8 = (_first != null ? _first[_pi] : ((0 : GoUInt8)));
                if (_x == ((241 : GoUInt8))) {
                    return false;
                };
                var _size:GoInt = (((_x & ((7 : GoUInt8))) : GoInt));
                if ((_i + _size) > _n) {
                    return false;
                };
                var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
                {
                    var _c:GoUInt8 = (_p != null ? _p[_i + ((1 : GoInt))] : ((0 : GoUInt8)));
                    if ((_c < _accept._lo) || (_accept._hi < _c)) {
                        return false;
                    } else if (_size == ((2 : GoInt))) {} else {
                        var _c:GoUInt8 = (_p != null ? _p[_i + ((2 : GoInt))] : ((0 : GoUInt8)));
                        if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                            return false;
                        } else if (_size == ((3 : GoInt))) {} else {
                            var _c:GoUInt8 = (_p != null ? _p[_i + ((3 : GoInt))] : ((0 : GoUInt8)));
                            if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                                return false;
                            };
                        };
                    };
                };
                _i = _i + (_size);
            };
        };
        return true;
    }
/**
    // ValidString reports whether s consists entirely of valid UTF-8-encoded runes.
**/
function validString(_s:GoString):Bool {
        while ((_s != null ? _s.length : ((0 : GoInt))) >= ((8 : GoInt))) {
            var _first32:GoUInt32 = (((((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) | ((((_s != null ? _s[((1 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((8 : GoUnTypedInt)))) | ((((_s != null ? _s[((2 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((16 : GoUnTypedInt)))) | ((((_s != null ? _s[((3 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((24 : GoUnTypedInt)));
            var _second32:GoUInt32 = (((((_s != null ? _s[((4 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) | ((((_s != null ? _s[((5 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((8 : GoUnTypedInt)))) | ((((_s != null ? _s[((6 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((16 : GoUnTypedInt)))) | ((((_s != null ? _s[((7 : GoInt))] : ((0 : GoUInt8))) : GoUInt32)) << ((24 : GoUnTypedInt)));
            if (((_first32 | _second32) & (("2155905152" : GoUInt32))) != ((0 : GoUInt32))) {
                break;
            };
            _s = _s.__slice__(((8 : GoInt)));
        };
        var _n:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        {
            var _i:GoInt = ((0 : GoInt));
            while (_i < _n) {
                var _si:GoUInt8 = (_s != null ? _s[_i] : ((0 : GoUInt8)));
                if (_si < ((128 : GoUInt8))) {
                    _i++;
                    continue;
                };
                var _x:GoUInt8 = (_first != null ? _first[_si] : ((0 : GoUInt8)));
                if (_x == ((241 : GoUInt8))) {
                    return false;
                };
                var _size:GoInt = (((_x & ((7 : GoUInt8))) : GoInt));
                if ((_i + _size) > _n) {
                    return false;
                };
                var _accept:T_acceptRange = ((_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()) == null ? null : (_acceptRanges != null ? _acceptRanges[_x >> ((4 : GoUnTypedInt))] : new T_acceptRange()).__copy__());
                {
                    var _c:GoUInt8 = (_s != null ? _s[_i + ((1 : GoInt))] : ((0 : GoUInt8)));
                    if ((_c < _accept._lo) || (_accept._hi < _c)) {
                        return false;
                    } else if (_size == ((2 : GoInt))) {} else {
                        var _c:GoUInt8 = (_s != null ? _s[_i + ((2 : GoInt))] : ((0 : GoUInt8)));
                        if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                            return false;
                        } else if (_size == ((3 : GoInt))) {} else {
                            var _c:GoUInt8 = (_s != null ? _s[_i + ((3 : GoInt))] : ((0 : GoUInt8)));
                            if ((_c < ((128 : GoUInt8))) || (((191 : GoUInt8)) < _c)) {
                                return false;
                            };
                        };
                    };
                };
                _i = _i + (_size);
            };
        };
        return true;
    }
/**
    // ValidRune reports whether r can be legally encoded as UTF-8.
    // Code points that are out of range or a surrogate half are illegal.
**/
function validRune(_r:GoRune):Bool {
        if ((((0 : GoInt32)) <= _r) && (_r < ((55296 : GoInt32)))) {
            return true;
        } else if ((((57343 : GoInt32)) < _r) && (_r <= ((1114111 : GoInt32)))) {
            return true;
        };
        return false;
    }
