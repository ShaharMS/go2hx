package stdgo.runtime.metrics;

import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;

@:structInit class Description {
	public var name:GoString = (("" : GoString));
	public var description:GoString = (("" : GoString));
	public var kind:ValueKind = new ValueKind();
	public var cumulative:Bool = false;

	public function new(?name:GoString, ?description:GoString, ?kind:ValueKind, ?cumulative:Bool)
		stdgo.internal.Macro.initLocals();

	public function toString() {
		return '{' + Go.string(name) + " " + Go.string(description) + " " + Go.string(kind) + " " + Go.string(cumulative) + "}";
	}

	public function __underlying__():AnyInterface
		return Go.toInterface(this);

	public function __copy__() {
		return new Description(name, description, kind, cumulative);
	}

	public function __set__(__tmp__) {
		this.name = __tmp__.name;
		this.description = __tmp__.description;
		this.kind = __tmp__.kind;
		this.cumulative = __tmp__.cumulative;
		return this;
	}
}

@:structInit class Float64Histogram {
	public var counts:Slice<GoUInt64> = new Slice<GoUInt64>().nil();
	public var buckets:Slice<GoFloat64> = new Slice<GoFloat64>().nil();

	public function new(?counts:Slice<GoUInt64>, ?buckets:Slice<GoFloat64>)
		stdgo.internal.Macro.initLocals();

	public function toString() {
		return '{' + Go.string(counts) + " " + Go.string(buckets) + "}";
	}

	public function __underlying__():AnyInterface
		return Go.toInterface(this);

	public function __copy__() {
		return new Float64Histogram(counts, buckets);
	}

	public function __set__(__tmp__) {
		this.counts = __tmp__.counts;
		this.buckets = __tmp__.buckets;
		return this;
	}
}

@:structInit class Sample {
	public var name:GoString = (("" : GoString));
	public var value:Value = new Value();

	public function new(?name:GoString, ?value:Value)
		stdgo.internal.Macro.initLocals();

	public function toString() {
		return '{' + Go.string(name) + " " + Go.string(value) + "}";
	}

	public function __underlying__():AnyInterface
		return Go.toInterface(this);

	public function __copy__() {
		return new Sample(name, value);
	}

	public function __set__(__tmp__) {
		this.name = __tmp__.name;
		this.value = __tmp__.value;
		return this;
	}
}

@:named class ValueKind {
	public var __t__:GoInt;

	public function new(?t:GoInt) {
		__t__ = t == null ? 0 : t;
	}

	public function __underlying__():AnyInterface
		return Go.toInterface(this);

	@:implicit
	public function toString():GoString
		return Go.string(__t__);

	public function __copy__()
		return new ValueKind(__t__);
}

@:structInit class Value {
	public function float64Histogram():Pointer<Float64Histogram> {
		var _v = this.__copy__();
		if (_v._kind.__t__ != kindFloat64Histogram.__t__) {
			throw "called Float64Histogram on non-Float64Histogram metric value";
		};
		return ((_v._pointer : Pointer<Float64Histogram>));
	}

	public function float64():GoFloat64 {
		var _v = this.__copy__();
		if (_v._kind.__t__ != kindFloat64.__t__) {
			throw "called Float64 on non-float64 metric value";
		};
		return stdgo.math.Math.float64frombits(_v._scalar);
	}

	public function uint64():GoUInt64 {
		var _v = this.__copy__();
		if (_v._kind.__t__ != kindUint64.__t__) {
			throw "called Uint64 on non-uint64 metric value";
		};
		return _v._scalar;
	}

	public function kind():ValueKind {
		var _v = this.__copy__();
		return _v._kind;
	}

	public var _kind:ValueKind = new ValueKind();
	public var _scalar:GoUInt64 = ((0 : GoUInt64));
	public var _pointer:stdgo.unsafe.Unsafe.UnsafePointer = null;

	public function new(?_kind:ValueKind, ?_scalar:GoUInt64, ?_pointer:stdgo.unsafe.Unsafe.UnsafePointer)
		stdgo.internal.Macro.initLocals();

	public function toString() {
		return '{' + Go.string(_kind) + " " + Go.string(_scalar) + " " + Go.string(_pointer) + "}";
	}

	public function __underlying__():AnyInterface
		return Go.toInterface(this);

	public function __copy__() {
		return new Value(_kind, _scalar, _pointer);
	}

	public function __set__(__tmp__) {
		this._kind = __tmp__._kind;
		this._scalar = __tmp__._scalar;
		this._pointer = __tmp__._pointer;
		return this;
	}
}

final kindFloat64:ValueKind = new ValueKind((2 : GoUnTypedInt));
final kindUint64:ValueKind = new ValueKind((1 : GoUnTypedInt));
final kindFloat64Histogram:ValueKind = new ValueKind((3 : GoUnTypedInt));

var _allDesc:Slice<Description> = new Slice<Description>((({
	name: "/gc/cycles/automatic:gc-cycles",
	description: "Count of completed GC cycles generated by the Go runtime.",
	kind: kindUint64,
	cumulative: true
} : Description)).__copy__(), (({
	name: "/gc/cycles/forced:gc-cycles",
	description: "Count of completed GC cycles forced by the application.",
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/cycles/total:gc-cycles",
	description: "Count of all completed GC cycles.",
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/allocs-by-size:bytes",
	description: (("Distribution of heap allocations by approximate size. " : GoString))
		+ (("Note that this does not include tiny objects as defined by " : GoString))
		+ (("/gc/heap/tiny/allocs:objects, only tiny blocks." : GoString)),
	kind: kindFloat64Histogram,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/allocs:bytes",
	description: "Cumulative sum of memory allocated to the heap by the application.",
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/allocs:objects",
	description: (("Cumulative count of heap allocations triggered by the application. " : GoString))
		+ (("Note that this does not include tiny objects as defined by " : GoString))
		+ (("/gc/heap/tiny/allocs:objects, only tiny blocks." : GoString)),
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/frees-by-size:bytes",
	description: (("Distribution of freed heap allocations by approximate size. " : GoString))
		+ (("Note that this does not include tiny objects as defined by " : GoString))
		+ (("/gc/heap/tiny/allocs:objects, only tiny blocks." : GoString)),
	kind: kindFloat64Histogram,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/frees:bytes",
	description: "Cumulative sum of heap memory freed by the garbage collector.",
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/frees:objects",
	description: (("Cumulative count of heap allocations whose storage was freed " : GoString))
		+ (("by the garbage collector. " : GoString))
		+ (("Note that this does not include tiny objects as defined by " : GoString))
		+ (("/gc/heap/tiny/allocs:objects, only tiny blocks." : GoString)),
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/heap/goal:bytes",
	description: "Heap size target for the end of the GC cycle.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/gc/heap/objects:objects",
	description: "Number of objects, live or unswept, occupying heap memory.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/gc/heap/tiny/allocs:objects",
	description: (("Count of small allocations that are packed together into blocks. " : GoString))
		+ (("These allocations are counted separately from other allocations " : GoString))
		+ (("because each individual allocation is not tracked by the runtime, " : GoString))
		+ (("only their block. Each block is already accounted for in " : GoString))
		+ (("allocs-by-size and frees-by-size." : GoString)),
	kind: kindUint64,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/gc/pauses:seconds",
	description: "Distribution individual GC-related stop-the-world pause latencies.",
	kind: kindFloat64Histogram,
	cumulative: true
	} : Description)).__copy__(), (({
	name: "/memory/classes/heap/free:bytes",
	description: (("Memory that is completely free and eligible to be returned to the underlying system, " : GoString))
		+ (("but has not been. This metric is the runtime\'s estimate of free address space that is backed by " : GoString))
		+ (("physical memory." : GoString)),
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/heap/objects:bytes",
	description: "Memory occupied by live objects and dead objects that have not yet been marked free by the garbage collector.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/heap/released:bytes",
	description: (("Memory that is completely free and has been returned to the underlying system. This " : GoString))
		+ (("metric is the runtime\'s estimate of free address space that is still mapped into the process, " : GoString))
		+ (("but is not backed by physical memory." : GoString)),
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/heap/stacks:bytes",
	description: "Memory allocated from the heap that is reserved for stack space, whether or not it is currently in-use.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/heap/unused:bytes",
	description: "Memory that is reserved for heap objects but is not currently used to hold heap objects.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/metadata/mcache/free:bytes",
	description: "Memory that is reserved for runtime mcache structures, but not in-use.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/metadata/mcache/inuse:bytes",
	description: "Memory that is occupied by runtime mcache structures that are currently being used.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/metadata/mspan/free:bytes",
	description: "Memory that is reserved for runtime mspan structures, but not in-use.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/metadata/mspan/inuse:bytes",
	description: "Memory that is occupied by runtime mspan structures that are currently being used.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/metadata/other:bytes",
	description: "Memory that is reserved for or used to hold runtime metadata.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/os-stacks:bytes",
	description: "Stack memory allocated by the underlying operating system.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/other:bytes",
	description: "Memory used by execution trace buffers, structures for debugging the runtime, finalizer and profiler specials, and more.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/profiling/buckets:bytes",
	description: "Memory that is used by the stack trace hash map used for profiling.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/memory/classes/total:bytes",
	description: "All memory mapped by the Go runtime into the current process as read-write. Note that this does not include memory mapped by code called via cgo or via the syscall package. Sum of all metrics in /memory/classes.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/sched/goroutines:goroutines",
	description: "Count of live goroutines.",
	kind: kindUint64,
	cumulative: false
	} : Description)).__copy__(), (({
	name: "/sched/latencies:seconds",
	description: "Distribution of the time goroutines have spent in the scheduler in a runnable state before actually running.",
	kind: kindFloat64Histogram,
	cumulative: false
	} : Description)).__copy__());

final kindBad:ValueKind = new ValueKind((0 : GoUnTypedInt));

/**
	// All returns a slice of containing metric descriptions for all supported metrics.
**/
function all():Slice<Description> {
	return _allDesc;
}

/**
	// Implemented in the runtime.
**/
function _runtime_readMetrics(arg0:stdgo.unsafe.Unsafe.Pointer_, arg1:GoInt, arg2:GoInt):Void {}

/**
	// Read populates each Value field in the given slice of metric samples.
	//
	// Desired metrics should be present in the slice with the appropriate name.
	// The user of this API is encouraged to re-use the same slice between calls for
	// efficiency, but is not required to do so.
	//
	// Note that re-use has some caveats. Notably, Values should not be read or
	// manipulated while a Read with that value is outstanding; that is a data race.
	// This property includes pointer-typed Values (for example, Float64Histogram)
	// whose underlying storage will be reused by Read when possible. To safely use
	// such values in a concurrent setting, all data must be deep-copied.
	//
	// It is safe to execute multiple Read calls concurrently, but their arguments
	// must share no underlying memory. When in doubt, create a new []Sample from
	// scratch, which is always safe, though may be inefficient.
	//
	// Sample values with names not appearing in All will have their Value populated
	// as KindBad to indicate that the name is unknown.
**/
function read(_m:Slice<Sample>):Void {
	_runtime_readMetrics(((Go.pointer(_m[((0 : GoInt))]) : stdgo.unsafe.Unsafe.Pointer_)), _m.length, _m.cap());
}

class Value_extension_fields {
	public function kind(__tmp__):ValueKind
		return __tmp__.kind();

	public function uint64(__tmp__):GoUInt64
		return __tmp__.uint64();

	public function float64(__tmp__):GoFloat64
		return __tmp__.float64();

	public function float64Histogram(__tmp__):Pointer<Float64Histogram>
		return __tmp__.float64Histogram();
}
