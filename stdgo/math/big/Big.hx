package stdgo.math.big;
import stdgo.StdGoTypes;
import stdgo.Error;
import stdgo.Go;
import stdgo.GoString;
import stdgo.Pointer;
import stdgo.Slice;
import stdgo.GoArray;
import stdgo.GoMap;
import stdgo.Chan;
var __Accuracy_index : GoArray<GoUInt8> = ((new GoArray<GoUInt8>(((0 : GoUInt8)), ((5 : GoUInt8)), ((10 : GoUInt8)), ((15 : GoUInt8))) : GoArray<GoUInt8>));
var _pow5tab : GoArray<GoUInt64> = ((new GoArray<GoUInt64>(
((1 : GoUInt64)),
((5 : GoUInt64)),
((25 : GoUInt64)),
((125 : GoUInt64)),
((625 : GoUInt64)),
((3125 : GoUInt64)),
((15625 : GoUInt64)),
((78125 : GoUInt64)),
((390625 : GoUInt64)),
((1953125 : GoUInt64)),
((9765625 : GoUInt64)),
((48828125 : GoUInt64)),
((244140625 : GoUInt64)),
((1220703125 : GoUInt64)),
(("6103515625" : GoUInt64)),
(("30517578125" : GoUInt64)),
(("152587890625" : GoUInt64)),
(("762939453125" : GoUInt64)),
(("3814697265625" : GoUInt64)),
(("19073486328125" : GoUInt64)),
(("95367431640625" : GoUInt64)),
(("476837158203125" : GoUInt64)),
(("2384185791015625" : GoUInt64)),
(("11920928955078125" : GoUInt64)),
(("59604644775390625" : GoUInt64)),
(("298023223876953125" : GoUInt64)),
(("1490116119384765625" : GoUInt64)),
(("7450580596923828125" : GoUInt64))) : GoArray<GoUInt64>));
var _natOne : T_nat = ((new Slice<Word>(((1 : GoUInt))) : T_nat));
var _intOne : Ref<Int_> = ((new Int_(false, (_natOne == null ? null : _natOne.__copy__())) : Int_));
var _natTwo : T_nat = ((new Slice<Word>(((2 : GoUInt))) : T_nat));
var _natFive : T_nat = ((new Slice<Word>(((5 : GoUInt))) : T_nat));
var _natTen : T_nat = ((new Slice<Word>(((10 : GoUInt))) : T_nat));
var _karatsubaThreshold : GoInt64 = ((40 : GoInt));
var _basicSqrThreshold : GoInt64 = ((20 : GoInt));
var _karatsubaSqrThreshold : GoInt64 = ((260 : GoInt));
var _errNoDigits : stdgo.Error = stdgo.errors.Errors.new_(((("number has no digits" : GoString))));
var _errInvalSep : stdgo.Error = stdgo.errors.Errors.new_(((("\'_\' must separate successive digits" : GoString))));
var _leafSize : GoInt = ((8 : GoInt));
var __RoundingMode_index : GoArray<GoUInt8> = ((new GoArray<GoUInt8>(((0 : GoUInt8)), ((13 : GoUInt8)), ((26 : GoUInt8)), ((32 : GoUInt8)), ((44 : GoUInt8)), ((57 : GoUInt8)), ((70 : GoUInt8))) : GoArray<GoUInt8>));
var _isRaceBuilder : Bool = stdgo.strings.Strings.hasSuffix(stdgo.internal.testenv.Testenv.builder(), ((("-race" : GoString))));
var _sumVV : Slice<T_argVV> = ((new Slice<T_argVV>(((new T_argVV() : T_argVV)), ((new T_argVV(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((1 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>(((80235 : GoUInt))) : T_nat)), ((new Slice<Word>(((12345 : GoUInt))) : T_nat)), ((new Slice<Word>(((67890 : GoUInt))) : T_nat)), ((0 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>((("4294967294" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((1 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967294" : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((0 : GoUInt))) : T_argVV)), ((new T_argVV(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), ((0 : GoUInt)), (("4294967295" : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt)), (("4294967295" : GoUInt)), ((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt))) : T_argVV))) : Slice<T_argVV>));
var _rnd : Ref<stdgo.math.rand.Rand.Rand> = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource(((0 : GoInt64))));
var _benchSizes : Slice<GoInt> = ((new Slice<GoInt>(((1 : GoInt)), ((2 : GoInt)), ((3 : GoInt)), ((4 : GoInt)), ((5 : GoInt)), ((10 : GoInt)), ((100 : GoInt)), ((1000 : GoInt)), ((10000 : GoInt)), ((100000 : GoInt))) : Slice<GoInt>));
var _sumVW : Slice<T_argVW> = ((new Slice<T_argVW>(((new T_argVW() : T_argVW)), ((new T_argVW(null, null, ((2 : GoUInt)), ((2 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt)), ((1 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt)), ((1 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((585 : GoUInt))) : T_nat)), ((new Slice<Word>(((314 : GoUInt))) : T_nat)), ((271 : GoUInt)), ((0 : GoUInt))) : T_argVW))) : Slice<T_argVW>));
var _lshVW : Slice<T_argVW> = ((new Slice<T_argVW>(((new T_argVW() : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((20 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967294" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt)), ((1 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4293918720" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((20 : GoUInt)), ((1048575 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967294" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt)), ((1 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4293918720" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((20 : GoUInt)), ((1048575 : GoUInt))) : T_argVW))) : Slice<T_argVW>));
var _rshVW : Slice<T_argVW> = ((new Slice<T_argVW>(((new T_argVW() : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((20 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((2147483647 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt)), (("2147483648" : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>(((4095 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((20 : GoUInt)), (("4294963200" : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((2147483647 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((1 : GoUInt)), (("2147483648" : GoUInt))) : T_argVW)), ((new T_argVW(((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((4095 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((20 : GoUInt)), (("4294963200" : GoUInt))) : T_argVW))) : Slice<T_argVW>));
var _argshlVUIn : Slice<Word> = ((new Slice<Word>(((1 : GoUInt)), ((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt)), ((64 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : Slice<Word>));
var _argshlVUr0 : Slice<Word> = ((new Slice<Word>(((1 : GoUInt)), ((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt)), ((64 : GoUInt))) : Slice<Word>));
var _argshlVUr1 : Slice<Word> = ((new Slice<Word>(((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt)), ((64 : GoUInt)), ((128 : GoUInt))) : Slice<Word>));
var _argshlVUrWm1 : Slice<Word> = ((new Slice<Word>((("2147483648" : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), ((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt))) : Slice<Word>));
var _argshlVU : Slice<T_argVU> = ((new Slice<T_argVU>(
((new T_argVU(((new Slice<Word>(((1 : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("3221225472" : GoUInt)), ((0 : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>(((2 : GoUInt)), (("4294967294" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("2147483649" : GoUInt))) : Slice<Word>)), ((1 : GoUInt)), ((("complete overlap of shlVU" : GoString)))) : T_argVU)),
((new T_argVU(((new Slice<Word>(
((1 : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("3221225472" : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((0 : GoUInt)), ((3 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>(((2 : GoUInt)), (("4294967294" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("2147483649" : GoUInt))) : Slice<Word>)), ((1 : GoUInt)), ((("partial overlap by half of shlVU" : GoString)))) : T_argVU)),
((new T_argVU(((new Slice<Word>(
((1 : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("3221225472" : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((0 : GoUInt)), ((6 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>(((2 : GoUInt)), (("4294967294" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("2147483649" : GoUInt))) : Slice<Word>)), ((1 : GoUInt)), ((("partial overlap by 1 Word of shlVU" : GoString)))) : T_argVU)),
((new T_argVU(((new Slice<Word>(
((1 : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("3221225472" : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((0 : GoUInt)), ((7 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>(((2 : GoUInt)), (("4294967294" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("2147483649" : GoUInt))) : Slice<Word>)), ((1 : GoUInt)), ((("no overlap of shlVU" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), _argshlVUr0, ((0 : GoUInt)), ((("complete overlap of shlVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), _argshlVUr1, ((0 : GoUInt)), ((("complete overlap of shlVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((31 : GoUInt)), _argshlVUrWm1, ((32 : GoUInt)), ((("complete overlap of shlVU and shift of _W - 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), ((0 : GoUInt)), _argshlVUr0, ((0 : GoUInt)), ((("partial overlap by 6 Words of shlVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), _argshlVUr1, ((0 : GoUInt)), ((("partial overlap by 6 Words of shlVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), ((31 : GoUInt)), _argshlVUrWm1, ((32 : GoUInt)), ((("partial overlap by 6 Words of shlVU and shift of _W - 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((2 : GoUInt)), ((0 : GoUInt)), _argshlVUr0, ((0 : GoUInt)), ((("partial overlap by 5 Words of shlVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((2 : GoUInt)), ((1 : GoUInt)), _argshlVUr1, ((0 : GoUInt)), ((("partial overlap by 5 Words of shlVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((2 : GoUInt)), ((31 : GoUInt)), _argshlVUrWm1, ((32 : GoUInt)), ((("partial overlap by 5 Words of shlVU abd shift of _W - 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((3 : GoUInt)), ((0 : GoUInt)), _argshlVUr0, ((0 : GoUInt)), ((("partial overlap by 4 Words of shlVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((3 : GoUInt)), ((1 : GoUInt)), _argshlVUr1, ((0 : GoUInt)), ((("partial overlap by 4 Words of shlVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshlVUIn, ((7 : GoUInt)), ((0 : GoUInt)), ((3 : GoUInt)), ((31 : GoUInt)), _argshlVUrWm1, ((32 : GoUInt)), ((("partial overlap by 4 Words of shlVU and shift of _W - 1" : GoString)))) : T_argVU))) : Slice<T_argVU>));
var _argshrVUIn : Slice<Word> = ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), ((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt)), ((64 : GoUInt))) : Slice<Word>));
var _argshrVUr0 : Slice<Word> = ((new Slice<Word>(((1 : GoUInt)), ((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt)), ((64 : GoUInt))) : Slice<Word>));
var _argshrVUr1 : Slice<Word> = ((new Slice<Word>(((0 : GoUInt)), ((1 : GoUInt)), ((2 : GoUInt)), ((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt))) : Slice<Word>));
var _argshrVUrWm1 : Slice<Word> = ((new Slice<Word>(((4 : GoUInt)), ((8 : GoUInt)), ((16 : GoUInt)), ((32 : GoUInt)), ((64 : GoUInt)), ((128 : GoUInt)), ((0 : GoUInt))) : Slice<Word>));
var _argshrVU : Slice<T_argVU> = ((new Slice<T_argVU>(
((new T_argVU(((new Slice<Word>(((0 : GoUInt)), ((3 : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("2147483648" : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>((("2147483649" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((2147483647 : GoUInt)), ((1073741824 : GoUInt))) : Slice<Word>)), (("2147483648" : GoUInt)), ((("complete overlap of shrVU" : GoString)))) : T_argVU)),
((new T_argVU(((new Slice<Word>(
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((3 : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("2147483648" : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((4 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>((("2147483649" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((2147483647 : GoUInt)), ((1073741824 : GoUInt))) : Slice<Word>)), (("2147483648" : GoUInt)), ((("partial overlap by half of shrVU" : GoString)))) : T_argVU)),
((new T_argVU(((new Slice<Word>(
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((3 : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("2147483648" : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((7 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>((("2147483649" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((2147483647 : GoUInt)), ((1073741824 : GoUInt))) : Slice<Word>)), (("2147483648" : GoUInt)), ((("partial overlap by 1 Word of shrVU" : GoString)))) : T_argVU)),
((new T_argVU(((new Slice<Word>(
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((0 : GoUInt)),
((3 : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("4294967295" : GoUInt)),
(("2147483648" : GoUInt))) : Slice<Word>)), ((7 : GoUInt)), ((8 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), ((new Slice<Word>((("2147483649" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((2147483647 : GoUInt)), ((1073741824 : GoUInt))) : Slice<Word>)), (("2147483648" : GoUInt)), ((("no overlap of shrVU" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((3 : GoUInt)), ((0 : GoUInt)), _argshrVUr0, ((0 : GoUInt)), ((("complete overlap of shrVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((3 : GoUInt)), ((1 : GoUInt)), _argshrVUr1, (("2147483648" : GoUInt)), ((("complete overlap of shrVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((3 : GoUInt)), ((31 : GoUInt)), _argshrVUrWm1, ((2 : GoUInt)), ((("complete overlap of shrVU and shift of _W - 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((2 : GoUInt)), ((0 : GoUInt)), _argshrVUr0, ((0 : GoUInt)), ((("partial overlap by 6 Words of shrVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((2 : GoUInt)), ((1 : GoUInt)), _argshrVUr1, (("2147483648" : GoUInt)), ((("partial overlap by 6 Words of shrVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((2 : GoUInt)), ((31 : GoUInt)), _argshrVUrWm1, ((2 : GoUInt)), ((("partial overlap by 6 Words of shrVU and shift of _W - 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((1 : GoUInt)), ((0 : GoUInt)), _argshrVUr0, ((0 : GoUInt)), ((("partial overlap by 5 Words of shrVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt)), _argshrVUr1, (("2147483648" : GoUInt)), ((("partial overlap by 5 Words of shrVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((1 : GoUInt)), ((31 : GoUInt)), _argshrVUrWm1, ((2 : GoUInt)), ((("partial overlap by 5 Words of shrVU and shift of _W - 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), _argshrVUr0, ((0 : GoUInt)), ((("partial overlap by 4 Words of shrVU and shift of 0" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt)), _argshrVUr1, (("2147483648" : GoUInt)), ((("partial overlap by 4 Words of shrVU and shift of 1" : GoString)))) : T_argVU)),
((new T_argVU(_argshrVUIn, ((7 : GoUInt)), ((3 : GoUInt)), ((0 : GoUInt)), ((31 : GoUInt)), _argshrVUrWm1, ((2 : GoUInt)), ((("partial overlap by 4 Words of shrVU and shift of _W - 1" : GoString)))) : T_argVU))) : Slice<T_argVU>));
var _prodVWW : Slice<T_argVWW> = ((new Slice<T_argVWW>(
((new T_argVWW() : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((991 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((0 : GoUInt)), ((991 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), (("4294967295" : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), (("4294967295" : GoUInt)), ((991 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((992 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((991 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((22793 : GoUInt))) : T_nat)), ((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((23 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((22800 : GoUInt))) : T_nat)), ((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((23 : GoUInt)), ((7 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((22793 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((991 : GoUInt))) : T_nat)), ((23 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((7 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((22793 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((991 : GoUInt))) : T_nat)), ((23 : GoUInt)), ((7 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((7893475 : GoUInt)), ((7395495 : GoUInt)), ((798547395 : GoUInt)), ((68943 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((991 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((7893475 : GoUInt)), ((7395495 : GoUInt)), ((798547395 : GoUInt)), ((68943 : GoUInt))) : T_nat)), ((0 : GoUInt)), ((991 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((894375984 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>(((991 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((894375984 : GoUInt)), ((991 : GoUInt)), ((0 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>((("4294967294" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((2 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((2 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>((("4294967168" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((128 : GoUInt)), ((0 : GoUInt)), ((127 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>((("4294967232" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt))) : T_nat)), ((128 : GoUInt)), ((64 : GoUInt)), ((127 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>((("4294967168" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((128 : GoUInt)), ((0 : GoUInt)), ((127 : GoUInt))) : T_argVWW)),
((new T_argVWW(((new Slice<Word>((("4294967232" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((128 : GoUInt)), ((64 : GoUInt)), ((127 : GoUInt))) : T_argVWW))) : Slice<T_argVWW>));
var _mulWWTests : Slice<T__struct_0> = ((new Slice<T__struct_0>(((new T__struct_0((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967294" : GoUInt)), ((1 : GoUInt))) : T__struct_0))) : Slice<T__struct_0>));
var _mulAddWWWTests : Slice<T__struct_1> = ((new Slice<T__struct_1>(((new T__struct_1((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((0 : GoUInt)), (("4294967294" : GoUInt)), ((1 : GoUInt))) : T__struct_1)), ((new T__struct_1((("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), (("4294967295" : GoUInt)), ((0 : GoUInt))) : T__struct_1))) : Slice<T__struct_1>));
var _divWWTests : Slice<T__struct_2> = ((new Slice<T__struct_2>(((new T__struct_2(((2147483647 : GoUInt)), ((0 : GoUInt)), (("4294967295" : GoUInt)), ((2147483647 : GoUInt)), ((2147483647 : GoUInt))) : T__struct_2)), ((new T__struct_2((("3221225471" : GoUInt)), (("4294967295" : GoUInt)), (("3221225472" : GoUInt)), (("4294967295" : GoUInt)), (("3221225471" : GoUInt))) : T__struct_2))) : Slice<T__struct_2>));
var _calibrate : Pointer<Bool> = stdgo.flag.Flag.bool(((("calibrate" : GoString))), false, ((("run calibration test" : GoString))));
var _precList : GoArray<GoUInt> = ((new GoArray<GoUInt>(
((1 : GoUInt)),
((2 : GoUInt)),
((5 : GoUInt)),
((8 : GoUInt)),
((10 : GoUInt)),
((16 : GoUInt)),
((23 : GoUInt)),
((24 : GoUInt)),
((32 : GoUInt)),
((50 : GoUInt)),
((53 : GoUInt)),
((64 : GoUInt)),
((100 : GoUInt)),
((128 : GoUInt)),
((500 : GoUInt)),
((511 : GoUInt)),
((512 : GoUInt)),
((513 : GoUInt)),
((1000 : GoUInt)),
((10000 : GoUInt))) : GoArray<GoUInt>));
var _bitsList : GoArray<Bits> = ((new GoArray<Bits>(((new Slice<GoInt>() : Bits)), ((new Slice<GoInt>(((0 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt))) : Bits)), ((new Slice<GoInt>(((-1 : GoInt))) : Bits)), ((new Slice<GoInt>(((10 : GoInt))) : Bits)), ((new Slice<GoInt>(((-10 : GoInt))) : Bits)), ((new Slice<GoInt>(((100 : GoInt)), ((10 : GoInt)), ((1 : GoInt))) : Bits)), ((new Slice<GoInt>(((0 : GoInt)), ((-1 : GoInt)), ((-2 : GoInt)), ((-10 : GoInt))) : Bits))) : GoArray<Bits>));
var _long : Pointer<Bool> = stdgo.flag.Flag.bool(((("long" : GoString))), false, ((("run very long tests" : GoString))));
var _floatVals : Slice<GoString> = ((new Slice<GoString>(
((("0" : GoString))),
((("1" : GoString))),
((("0.1" : GoString))),
((("2.71828" : GoString))),
((("1234567890" : GoString))),
((("3.14e1234" : GoString))),
((("3.14e-1234" : GoString))),
((("0.738957395793475734757349579759957975985497e100" : GoString))),
((("0.73895739579347546656564656573475734957975995797598589749859834759476745986795497e100" : GoString))),
((("inf" : GoString))),
((("Inf" : GoString)))) : Slice<GoString>));
var _sumZZ : Slice<T_argZZ> = ((new Slice<T_argZZ>(((new T_argZZ(newInt(((0 : GoInt64))), newInt(((0 : GoInt64))), newInt(((0 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((1 : GoInt64))), newInt(((1 : GoInt64))), newInt(((0 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((1111111110 : GoInt64))), newInt(((123456789 : GoInt64))), newInt(((987654321 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((-1 : GoInt64))), newInt(((-1 : GoInt64))), newInt(((0 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((864197532 : GoInt64))), newInt(((-123456789 : GoInt64))), newInt(((987654321 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((-1111111110 : GoInt64))), newInt(((-123456789 : GoInt64))), newInt(((-987654321 : GoInt64)))) : T_argZZ))) : Slice<T_argZZ>));
var _prodZZ : Slice<T_argZZ> = ((new Slice<T_argZZ>(((new T_argZZ(newInt(((0 : GoInt64))), newInt(((0 : GoInt64))), newInt(((0 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((0 : GoInt64))), newInt(((1 : GoInt64))), newInt(((0 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((1 : GoInt64))), newInt(((1 : GoInt64))), newInt(((1 : GoInt64)))) : T_argZZ)), ((new T_argZZ(newInt(((-982081 : GoInt64))), newInt(((991 : GoInt64))), newInt(((-991 : GoInt64)))) : T_argZZ))) : Slice<T_argZZ>));
var _mulRangesZ : Slice<T__struct_32> = ((new Slice<T__struct_32>(
((new T__struct_32(((-1 : GoInt64)), ((1 : GoInt64)), ((("0" : GoString)))) : T__struct_32)),
((new T__struct_32(((-2 : GoInt64)), ((-1 : GoInt64)), ((("2" : GoString)))) : T__struct_32)),
((new T__struct_32(((-3 : GoInt64)), ((-2 : GoInt64)), ((("6" : GoString)))) : T__struct_32)),
((new T__struct_32(((-3 : GoInt64)), ((-1 : GoInt64)), ((("-6" : GoString)))) : T__struct_32)),
((new T__struct_32(((1 : GoInt64)), ((3 : GoInt64)), ((("6" : GoString)))) : T__struct_32)),
((new T__struct_32(((-10 : GoInt64)), ((-10 : GoInt64)), ((("-10" : GoString)))) : T__struct_32)),
((new T__struct_32(((0 : GoInt64)), ((-1 : GoInt64)), ((("1" : GoString)))) : T__struct_32)),
((new T__struct_32(((-1 : GoInt64)), ((-100 : GoInt64)), ((("1" : GoString)))) : T__struct_32)),
((new T__struct_32(((-1 : GoInt64)), ((1 : GoInt64)), ((("0" : GoString)))) : T__struct_32)),
((new T__struct_32(((-1000000000 : GoInt64)), ((0 : GoInt64)), ((("0" : GoString)))) : T__struct_32)),
((new T__struct_32(((-1000000000 : GoInt64)), ((1e+09 : GoInt64)), ((("0" : GoString)))) : T__struct_32)),
((new T__struct_32(((-10 : GoInt64)), ((-1 : GoInt64)), ((("3628800" : GoString)))) : T__struct_32)),
((new T__struct_32(((-20 : GoInt64)), ((-2 : GoInt64)), ((("-2432902008176640000" : GoString)))) : T__struct_32)),
((new T__struct_32(((-99 : GoInt64)), ((-1 : GoInt64)), ((("-933262154439441526816992388562667004907159682643816214685929638952175999932299156089414639761565182862536979208272237582511852109168640000000000000000000000" : GoString)))) : T__struct_32))) : Slice<T__struct_32>));
var _divisionSignsTests : Slice<T__struct_34> = ((new Slice<T__struct_34>(((new T__struct_34(((5 : GoInt64)), ((3 : GoInt64)), ((1 : GoInt64)), ((2 : GoInt64)), ((1 : GoInt64)), ((2 : GoInt64))) : T__struct_34)), ((new T__struct_34(((-5 : GoInt64)), ((3 : GoInt64)), ((-1 : GoInt64)), ((-2 : GoInt64)), ((-2 : GoInt64)), ((1 : GoInt64))) : T__struct_34)), ((new T__struct_34(((5 : GoInt64)), ((-3 : GoInt64)), ((-1 : GoInt64)), ((2 : GoInt64)), ((-1 : GoInt64)), ((2 : GoInt64))) : T__struct_34)), ((new T__struct_34(((-5 : GoInt64)), ((-3 : GoInt64)), ((1 : GoInt64)), ((-2 : GoInt64)), ((2 : GoInt64)), ((1 : GoInt64))) : T__struct_34)), ((new T__struct_34(((1 : GoInt64)), ((2 : GoInt64)), ((0 : GoInt64)), ((1 : GoInt64)), ((0 : GoInt64)), ((1 : GoInt64))) : T__struct_34)), ((new T__struct_34(((8 : GoInt64)), ((4 : GoInt64)), ((2 : GoInt64)), ((0 : GoInt64)), ((2 : GoInt64)), ((0 : GoInt64))) : T__struct_34))) : Slice<T__struct_34>));
var _quoTests : Slice<T__struct_35> = ((new Slice<T__struct_35>(((new T__struct_35(((("476217953993950760840509444250624797097991362735329973741718102894495832294430498335824897858659711275234906400899559094370964723884706254265559534144986498357" : GoString))), ((("9353930466774385905609975137998169297361893554149986716853295022578535724979483772383667534691121982974895531435241089241440253066816724367338287092081996" : GoString))), ((("50911" : GoString))), ((("1" : GoString)))) : T__struct_35)), ((new T__struct_35(((("11510768301994997771168" : GoString))), ((("1328165573307167369775" : GoString))), ((("8" : GoString))), ((("885443715537658812968" : GoString)))) : T__struct_35))) : Slice<T__struct_35>));
var _bitLenTests : Slice<T__struct_36> = ((new Slice<T__struct_36>(
((new T__struct_36(((("-1" : GoString))), ((1 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0" : GoString))), ((0 : GoInt))) : T__struct_36)),
((new T__struct_36(((("1" : GoString))), ((1 : GoInt))) : T__struct_36)),
((new T__struct_36(((("2" : GoString))), ((2 : GoInt))) : T__struct_36)),
((new T__struct_36(((("4" : GoString))), ((3 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0xabc" : GoString))), ((12 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0x8000" : GoString))), ((16 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0x80000000" : GoString))), ((32 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0x800000000000" : GoString))), ((48 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0x8000000000000000" : GoString))), ((64 : GoInt))) : T__struct_36)),
((new T__struct_36(((("0x80000000000000000000" : GoString))), ((80 : GoInt))) : T__struct_36)),
((new T__struct_36(((("-0x4000000000000000000000" : GoString))), ((87 : GoInt))) : T__struct_36))) : Slice<T__struct_36>));
var _expTests : Slice<T__struct_37> = ((new Slice<T__struct_37>(
((new T__struct_37(((("0" : GoString))), ((("0" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1" : GoString))), ((("0" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-10" : GoString))), ((("0" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1234" : GoString))), ((("-1" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1234" : GoString))), ((("-1" : GoString))), ((("0" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("17" : GoString))), ((("-100" : GoString))), ((("1234" : GoString))), ((("865" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2" : GoString))), ((("-100" : GoString))), ((("1234" : GoString))), ((("" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0" : GoString))), ((("0" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1" : GoString))), ((("0" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-10" : GoString))), ((("0" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1234" : GoString))), ((("-1" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("5" : GoString))), ((("1" : GoString))), ((("3" : GoString))), ((("2" : GoString)))) : T__struct_37)),
((new T__struct_37(((("5" : GoString))), ((("-7" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-5" : GoString))), ((("-7" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("5" : GoString))), ((("0" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-5" : GoString))), ((("0" : GoString))), ((("" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("5" : GoString))), ((("1" : GoString))), ((("" : GoString))), ((("5" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-5" : GoString))), ((("1" : GoString))), ((("" : GoString))), ((("-5" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-5" : GoString))), ((("1" : GoString))), ((("7" : GoString))), ((("2" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-2" : GoString))), ((("3" : GoString))), ((("2" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("5" : GoString))), ((("2" : GoString))), ((("" : GoString))), ((("25" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1" : GoString))), ((("65537" : GoString))), ((("2" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("2" : GoString))), ((("" : GoString))), ((("0x40000000000000000000000000000000" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("2" : GoString))), ((("6719" : GoString))), ((("4944" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("3" : GoString))), ((("6719" : GoString))), ((("5447" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("1000" : GoString))), ((("6719" : GoString))), ((("1603" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("1000000" : GoString))), ((("6719" : GoString))), ((("3199" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("-1000000" : GoString))), ((("6719" : GoString))), ((("3663" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0xffffffffffffffffffffffffffffffff" : GoString))), ((("0x12345678123456781234567812345678123456789" : GoString))), ((("0x01112222333344445555666677778889" : GoString))), ((("0x36168FA1DB3AAE6C8CE647E137F97A" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2938462938472983472983659726349017249287491026512746239764525612965293865296239471239874193284792387498274256129746192347" : GoString))), ((("298472983472983471903246121093472394872319615612417471234712061" : GoString))), ((("29834729834729834729347290846729561262544958723956495615629569234729836259263598127342374289365912465901365498236492183464" : GoString))), ((("23537740700184054162508175125554701713153216681790245129157191391322321508055833908509185839069455749219131480588829346291" : GoString)))) : T__struct_37)),
((new T__struct_37(((("11001289118363089646017359372117963499250546375269047542777928006103246876688756735760905680604646624353196869572752623285140408755420374049317646428185270079555372763503115646054602867593662923894140940837479507194934267532831694565516466765025434902348314525627418515646588160955862839022051353653052947073136084780742729727874803457643848197499548297570026926927502505634297079527299004267769780768565695459945235586892627059178884998772989397505061206395455591503771677500931269477503508150175717121828518985901959919560700853226255420793148986854391552859459511723547532575574664944815966793196961286234040892865" : GoString))), ((("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString))), ((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString))), ((("21484252197776302499639938883777710321993113097987201050501182909581359357618579566746556372589385361683610524730509041328855066514963385522570894839035884713051640171474186548713546686476761306436434146475140156284389181808675016576845833340494848283681088886584219750554408060556769486628029028720727393293111678826356480455433909233520504112074401376133077150471237549474149190242010469539006449596611576612573955754349042329130631128234637924786466585703488460540228477440853493392086251021228087076124706778899179648655221663765993962724699135217212118535057766739392069738618682722216712319320435674779146070442" : GoString)))) : T__struct_37)),
((new T__struct_37(((("-0x1BCE04427D8032319A89E5C4136456671AC620883F2C4139E57F91307C485AD2D6204F4F87A58262652DB5DBBAC72B0613E51B835E7153BEC6068F5C8D696B74DBD18FEC316AEF73985CF0475663208EB46B4F17DD9DA55367B03323E5491A70997B90C059FB34809E6EE55BCFBD5F2F52233BFE62E6AA9E4E26A1D4C2439883D14F2633D55D8AA66A1ACD5595E778AC3A280517F1157989E70C1A437B849F1877B779CC3CDDEDE2DAA6594A6C66D181A00A5F777EE60596D8773998F6E988DEAE4CCA60E4DDCF9590543C89F74F603259FCAD71660D30294FBBE6490300F78A9D63FA660DC9417B8B9DDA28BEB3977B621B988E23D4D954F322C3540541BC649ABD504C50FADFD9F0987D58A2BF689313A285E773FF02899A6EF887D1D4A0D2" : GoString))), ((("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString))), ((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString))), ((("21484252197776302499639938883777710321993113097987201050501182909581359357618579566746556372589385361683610524730509041328855066514963385522570894839035884713051640171474186548713546686476761306436434146475140156284389181808675016576845833340494848283681088886584219750554408060556769486628029028720727393293111678826356480455433909233520504112074401376133077150471237549474149190242010469539006449596611576612573955754349042329130631128234637924786466585703488460540228477440853493392086251021228087076124706778899179648655221663765993962724699135217212118535057766739392069738618682722216712319320435674779146070442" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0xffffffff00000001" : GoString))), ((("0xffffffff00000001" : GoString))), ((("0xffffffff00000001" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0xffffffffffffffff00000001" : GoString))), ((("0xffffffffffffffff00000001" : GoString))), ((("0xffffffffffffffff00000001" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0xffffffffffffffffffffffff00000001" : GoString))), ((("0xffffffffffffffffffffffff00000001" : GoString))), ((("0xffffffffffffffffffffffff00000001" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0xffffffffffffffffffffffffffffffff00000001" : GoString))), ((("0xffffffffffffffffffffffffffffffff00000001" : GoString))), ((("0xffffffffffffffffffffffffffffffff00000001" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2" : GoString))), ((("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString))), ((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString))), ((("0x6AADD3E3E424D5B713FCAA8D8945B1E055166132038C57BBD2D51C833F0C5EA2007A2324CE514F8E8C2F008A2F36F44005A4039CB55830986F734C93DAF0EB4BAB54A6A8C7081864F44346E9BC6F0A3EB9F2C0146A00C6A05187D0C101E1F2D038CDB70CB5E9E05A2D188AB6CBB46286624D4415E7D4DBFAD3BCC6009D915C406EED38F468B940F41E6BEDC0430DD78E6F19A7DA3A27498A4181E24D738B0072D8F6ADB8C9809A5B033A09785814FD9919F6EF9F83EEA519BEC593855C4C10CBEEC582D4AE0792158823B0275E6AEC35242740468FAF3D5C60FD1E376362B6322F78B7ED0CA1C5BBCD2B49734A56C0967A1D01A100932C837B91D592CE08ABFF" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2" : GoString))), ((("0xB08FFB20760FFED58FADA86DFEF71AD72AA0FA763219618FE022C197E54708BB1191C66470250FCE8879487507CEE41381CA4D932F81C2B3F1AB20B539D50DCD" : GoString))), ((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF72" : GoString))), ((("0x7858794B5897C29F4ED0B40913416AB6C48588484E6A45F2ED3E26C941D878E923575AAC434EE2750E6439A6976F9BB4D64CEDB2A53CE8D04DD48CADCDF8E46F22747C6B81C6CEA86C0D873FBF7CEF262BAAC43A522BD7F32F3CDAC52B9337C77B3DCFB3DB3EDD80476331E82F4B1DF8EFDC1220C92656DFC9197BDC1877804E28D928A2A284B8DED506CBA304435C9D0133C246C98A7D890D1DE60CBC53A024361DA83A9B8775019083D22AC6820ED7C3C68F8E801DD4EC779EE0A05C6EB682EF9840D285B838369BA7E148FA27691D524FAEAF7C6ECE2A4B99A294B9F2C241857B5B90CC8BFFCFCF18DFA7D676131D5CD3855A5A3E8EBFA0CDFADB4D198B4A" : GoString)))) : T__struct_37))) : Slice<T__struct_37>));
var _gcdTests : Slice<T__struct_38> = ((new Slice<T__struct_38>(
((new T__struct_38(((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString)))) : T__struct_38)),
((new T__struct_38(((("7" : GoString))), ((("0" : GoString))), ((("1" : GoString))), ((("0" : GoString))), ((("7" : GoString)))) : T__struct_38)),
((new T__struct_38(((("7" : GoString))), ((("0" : GoString))), ((("-1" : GoString))), ((("0" : GoString))), ((("-7" : GoString)))) : T__struct_38)),
((new T__struct_38(((("11" : GoString))), ((("1" : GoString))), ((("0" : GoString))), ((("11" : GoString))), ((("0" : GoString)))) : T__struct_38)),
((new T__struct_38(((("7" : GoString))), ((("-1" : GoString))), ((("-2" : GoString))), ((("-77" : GoString))), ((("35" : GoString)))) : T__struct_38)),
((new T__struct_38(((("935" : GoString))), ((("-3" : GoString))), ((("8" : GoString))), ((("64515" : GoString))), ((("24310" : GoString)))) : T__struct_38)),
((new T__struct_38(((("935" : GoString))), ((("-3" : GoString))), ((("-8" : GoString))), ((("64515" : GoString))), ((("-24310" : GoString)))) : T__struct_38)),
((new T__struct_38(((("935" : GoString))), ((("3" : GoString))), ((("-8" : GoString))), ((("-64515" : GoString))), ((("-24310" : GoString)))) : T__struct_38)),
((new T__struct_38(((("1" : GoString))), ((("-9" : GoString))), ((("47" : GoString))), ((("120" : GoString))), ((("23" : GoString)))) : T__struct_38)),
((new T__struct_38(((("7" : GoString))), ((("1" : GoString))), ((("-2" : GoString))), ((("77" : GoString))), ((("35" : GoString)))) : T__struct_38)),
((new T__struct_38(((("935" : GoString))), ((("-3" : GoString))), ((("8" : GoString))), ((("64515" : GoString))), ((("24310" : GoString)))) : T__struct_38)),
((new T__struct_38(((("935000000000000000" : GoString))), ((("-3" : GoString))), ((("8" : GoString))), ((("64515000000000000000" : GoString))), ((("24310000000000000000" : GoString)))) : T__struct_38)),
((new T__struct_38(((("1" : GoString))), ((("-221" : GoString))), ((("22059940471369027483332068679400581064239780177629666810348940098015901108344" : GoString))), ((("98920366548084643601728869055592650835572950932266967461790948584315647051443" : GoString))), ((("991" : GoString)))) : T__struct_38))) : Slice<T__struct_38>));
var _rshTests : Slice<T_intShiftTest> = ((new Slice<T_intShiftTest>(
((new T_intShiftTest(((("0" : GoString))), ((0 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-0" : GoString))), ((0 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("0" : GoString))), ((1 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("0" : GoString))), ((2 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((0 : GoUInt)), ((("1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((1 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((2 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("2" : GoString))), ((0 : GoUInt)), ((("2" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("2" : GoString))), ((1 : GoUInt)), ((("1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-1" : GoString))), ((0 : GoUInt)), ((("-1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-1" : GoString))), ((1 : GoUInt)), ((("-1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-1" : GoString))), ((10 : GoUInt)), ((("-1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-100" : GoString))), ((2 : GoUInt)), ((("-25" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-100" : GoString))), ((3 : GoUInt)), ((("-13" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-100" : GoString))), ((100 : GoUInt)), ((("-1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4294967296" : GoString))), ((0 : GoUInt)), ((("4294967296" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4294967296" : GoString))), ((1 : GoUInt)), ((("2147483648" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4294967296" : GoString))), ((2 : GoUInt)), ((("1073741824" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("18446744073709551616" : GoString))), ((0 : GoUInt)), ((("18446744073709551616" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("18446744073709551616" : GoString))), ((1 : GoUInt)), ((("9223372036854775808" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("18446744073709551616" : GoString))), ((2 : GoUInt)), ((("4611686018427387904" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("18446744073709551616" : GoString))), ((64 : GoUInt)), ((("1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("340282366920938463463374607431768211456" : GoString))), ((64 : GoUInt)), ((("18446744073709551616" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("340282366920938463463374607431768211456" : GoString))), ((128 : GoUInt)), ((("1" : GoString)))) : T_intShiftTest))) : Slice<T_intShiftTest>));
var _lshTests : Slice<T_intShiftTest> = ((new Slice<T_intShiftTest>(
((new T_intShiftTest(((("0" : GoString))), ((0 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("0" : GoString))), ((1 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("0" : GoString))), ((2 : GoUInt)), ((("0" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((0 : GoUInt)), ((("1" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((1 : GoUInt)), ((("2" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((2 : GoUInt)), ((("4" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("2" : GoString))), ((0 : GoUInt)), ((("2" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("2" : GoString))), ((1 : GoUInt)), ((("4" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("2" : GoString))), ((2 : GoUInt)), ((("8" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("-87" : GoString))), ((1 : GoUInt)), ((("-174" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4294967296" : GoString))), ((0 : GoUInt)), ((("4294967296" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4294967296" : GoString))), ((1 : GoUInt)), ((("8589934592" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4294967296" : GoString))), ((2 : GoUInt)), ((("17179869184" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("18446744073709551616" : GoString))), ((0 : GoUInt)), ((("18446744073709551616" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("9223372036854775808" : GoString))), ((1 : GoUInt)), ((("18446744073709551616" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("4611686018427387904" : GoString))), ((2 : GoUInt)), ((("18446744073709551616" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((64 : GoUInt)), ((("18446744073709551616" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("18446744073709551616" : GoString))), ((64 : GoUInt)), ((("340282366920938463463374607431768211456" : GoString)))) : T_intShiftTest)),
((new T_intShiftTest(((("1" : GoString))), ((128 : GoUInt)), ((("340282366920938463463374607431768211456" : GoString)))) : T_intShiftTest))) : Slice<T_intShiftTest>));
var _cmpAbsTests : Slice<GoString> = ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("2" : GoString))), ((("10" : GoString))), ((("10000000" : GoString))), ((("2783678367462374683678456387645876387564783686583485" : GoString))), ((("2783678367462374683678456387645876387564783686583486" : GoString))), ((("32957394867987420967976567076075976570670947609750670956097509670576075067076027578341538" : GoString)))) : Slice<GoString>));
var _int64Tests : Slice<GoString> = ((new Slice<GoString>(
((("0" : GoString))),
((("1" : GoString))),
((("-1" : GoString))),
((("4294967295" : GoString))),
((("-4294967295" : GoString))),
((("4294967296" : GoString))),
((("-4294967296" : GoString))),
((("9223372036854775807" : GoString))),
((("-9223372036854775807" : GoString))),
((("-9223372036854775808" : GoString))),
((("0x8000000000000000" : GoString))),
((("-0x8000000000000001" : GoString))),
((("38579843757496759476987459679745" : GoString))),
((("-38579843757496759476987459679745" : GoString)))) : Slice<GoString>));
var _uint64Tests : Slice<GoString> = ((new Slice<GoString>(
((("0" : GoString))),
((("1" : GoString))),
((("4294967295" : GoString))),
((("4294967296" : GoString))),
((("8589934591" : GoString))),
((("8589934592" : GoString))),
((("9223372036854775807" : GoString))),
((("9223372036854775808" : GoString))),
((("0x08000000000000000" : GoString))),
((("0x10000000000000000" : GoString))),
((("-0x08000000000000000" : GoString))),
((("-1" : GoString)))) : Slice<GoString>));
var _bitwiseTests : Slice<T__struct_39> = ((new Slice<T__struct_39>(
((new T__struct_39(((("0x00" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x00" : GoString))), ((("0x01" : GoString))), ((("0x00" : GoString))), ((("0x01" : GoString))), ((("0x01" : GoString))), ((("0x00" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x01" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString))), ((("0x01" : GoString))), ((("0x01" : GoString))), ((("0x01" : GoString)))) : T__struct_39)),
((new T__struct_39(((("-0x01" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString))), ((("-0x01" : GoString))), ((("-0x01" : GoString))), ((("-0x01" : GoString)))) : T__struct_39)),
((new T__struct_39(((("-0xaf" : GoString))), ((("-0x50" : GoString))), ((("-0xf0" : GoString))), ((("-0x0f" : GoString))), ((("0xe1" : GoString))), ((("0x41" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x00" : GoString))), ((("-0x01" : GoString))), ((("0x00" : GoString))), ((("-0x01" : GoString))), ((("-0x01" : GoString))), ((("0x00" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x01" : GoString))), ((("0x01" : GoString))), ((("0x01" : GoString))), ((("0x01" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString)))) : T__struct_39)),
((new T__struct_39(((("-0x01" : GoString))), ((("-0x01" : GoString))), ((("-0x01" : GoString))), ((("-0x01" : GoString))), ((("0x00" : GoString))), ((("0x00" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x07" : GoString))), ((("0x08" : GoString))), ((("0x00" : GoString))), ((("0x0f" : GoString))), ((("0x0f" : GoString))), ((("0x07" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x05" : GoString))), ((("0x0f" : GoString))), ((("0x05" : GoString))), ((("0x0f" : GoString))), ((("0x0a" : GoString))), ((("0x00" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0xff" : GoString))), ((("-0x0a" : GoString))), ((("0xf6" : GoString))), ((("-0x01" : GoString))), ((("-0xf7" : GoString))), ((("0x09" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x013ff6" : GoString))), ((("0x9a4e" : GoString))), ((("0x1a46" : GoString))), ((("0x01bffe" : GoString))), ((("0x01a5b8" : GoString))), ((("0x0125b0" : GoString)))) : T__struct_39)),
((new T__struct_39(((("-0x013ff6" : GoString))), ((("0x9a4e" : GoString))), ((("0x800a" : GoString))), ((("-0x0125b2" : GoString))), ((("-0x01a5bc" : GoString))), ((("-0x01c000" : GoString)))) : T__struct_39)),
((new T__struct_39(((("-0x013ff6" : GoString))), ((("-0x9a4e" : GoString))), ((("-0x01bffe" : GoString))), ((("-0x1a46" : GoString))), ((("0x01a5b8" : GoString))), ((("0x8008" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x1000009dc6e3d9822cba04129bcbe3401" : GoString))), ((("0xb9bd7d543685789d57cb918e833af352559021483cdb05cc21fd" : GoString))), ((("0x1000001186210100001000009048c2001" : GoString))), ((("0xb9bd7d543685789d57cb918e8bfeff7fddb2ebe87dfbbdfe35fd" : GoString))), ((("0xb9bd7d543685789d57ca918e8ae69d6fcdb2eae87df2b97215fc" : GoString))), ((("0x8c40c2d8822caa04120b8321400" : GoString)))) : T__struct_39)),
((new T__struct_39(((("0x1000009dc6e3d9822cba04129bcbe3401" : GoString))), ((("-0xb9bd7d543685789d57cb918e833af352559021483cdb05cc21fd" : GoString))), ((("0x8c40c2d8822caa04120b8321401" : GoString))), ((("-0xb9bd7d543685789d57ca918e82229142459020483cd2014001fd" : GoString))), ((("-0xb9bd7d543685789d57ca918e8ae69d6fcdb2eae87df2b97215fe" : GoString))), ((("0x1000001186210100001000009048c2000" : GoString)))) : T__struct_39)),
((new T__struct_39(((("-0x1000009dc6e3d9822cba04129bcbe3401" : GoString))), ((("-0xb9bd7d543685789d57cb918e833af352559021483cdb05cc21fd" : GoString))), ((("-0xb9bd7d543685789d57cb918e8bfeff7fddb2ebe87dfbbdfe35fd" : GoString))), ((("-0x1000001186210100001000009048c2001" : GoString))), ((("0xb9bd7d543685789d57ca918e8ae69d6fcdb2eae87df2b97215fc" : GoString))), ((("0xb9bd7d543685789d57ca918e82229142459020483cd2014001fc" : GoString)))) : T__struct_39))) : Slice<T__struct_39>));
var _bitsetTests : Slice<T__struct_40> = ((new Slice<T__struct_40>(
((new T__struct_40(((("0" : GoString))), ((0 : GoInt)), ((0 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("0" : GoString))), ((200 : GoInt)), ((0 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("1" : GoString))), ((0 : GoInt)), ((1 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("1" : GoString))), ((1 : GoInt)), ((0 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("-1" : GoString))), ((0 : GoInt)), ((1 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("-1" : GoString))), ((200 : GoInt)), ((1 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("0x2000000000000000000000000000" : GoString))), ((108 : GoInt)), ((0 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("0x2000000000000000000000000000" : GoString))), ((109 : GoInt)), ((1 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("0x2000000000000000000000000000" : GoString))), ((110 : GoInt)), ((0 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("-0x2000000000000000000000000001" : GoString))), ((108 : GoInt)), ((1 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("-0x2000000000000000000000000001" : GoString))), ((109 : GoInt)), ((0 : GoUInt))) : T__struct_40)),
((new T__struct_40(((("-0x2000000000000000000000000001" : GoString))), ((110 : GoInt)), ((1 : GoUInt))) : T__struct_40))) : Slice<T__struct_40>));
var _tzbTests : Slice<T__struct_41> = ((new Slice<T__struct_41>(((new T__struct_41(((("0" : GoString))), ((0 : GoUInt))) : T__struct_41)), ((new T__struct_41(((("1" : GoString))), ((0 : GoUInt))) : T__struct_41)), ((new T__struct_41(((("-1" : GoString))), ((0 : GoUInt))) : T__struct_41)), ((new T__struct_41(((("4" : GoString))), ((2 : GoUInt))) : T__struct_41)), ((new T__struct_41(((("-8" : GoString))), ((3 : GoUInt))) : T__struct_41)), ((new T__struct_41(((("0x4000000000000000000" : GoString))), ((74 : GoUInt))) : T__struct_41)), ((new T__struct_41(((("-0x8000000000000000000" : GoString))), ((75 : GoUInt))) : T__struct_41))) : Slice<T__struct_41>));
var _notTests : Slice<T__struct_42> = ((new Slice<T__struct_42>(((new T__struct_42(((("0" : GoString))), ((("-1" : GoString)))) : T__struct_42)), ((new T__struct_42(((("1" : GoString))), ((("-2" : GoString)))) : T__struct_42)), ((new T__struct_42(((("7" : GoString))), ((("-8" : GoString)))) : T__struct_42)), ((new T__struct_42(((("0" : GoString))), ((("-1" : GoString)))) : T__struct_42)), ((new T__struct_42(((("-81910" : GoString))), ((("81909" : GoString)))) : T__struct_42)), ((new T__struct_42(((("298472983472983471903246121093472394872319615612417471234712061" : GoString))), ((("-298472983472983471903246121093472394872319615612417471234712062" : GoString)))) : T__struct_42))) : Slice<T__struct_42>));
var _modInverseTests : Slice<T__struct_43> = ((new Slice<T__struct_43>(((new T__struct_43(((("1234567" : GoString))), ((("458948883992" : GoString)))) : T__struct_43)), ((new T__struct_43(((("239487239847" : GoString))), ((("2410312426921032588552076022197566074856950548502459942654116941958108831682612228890093858261341614673227141477904012196503648957050582631942730706805009223062734745341073406696246014589361659774041027169249453200378729434170325843778659198143763193776859869524088940195577346119843545301547043747207749969763750084308926339295559968882457872412993810129130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919" : GoString)))) : T__struct_43)), ((new T__struct_43(((("-10" : GoString))), ((("13" : GoString)))) : T__struct_43)), ((new T__struct_43(((("10" : GoString))), ((("-13" : GoString)))) : T__struct_43)), ((new T__struct_43(((("-17" : GoString))), ((("-13" : GoString)))) : T__struct_43))) : Slice<T__struct_43>));
var _stringTests : Slice<T__struct_45> = ((new Slice<T__struct_45>(
((({ _in : ((("" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("a" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("a" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("z" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("z" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("+" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("+" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("-" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("-" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0b" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0b" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0o" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0o" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0x" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0x" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0y" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0y" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("2" : GoString))), _base : ((2 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("2" : GoString))), _base : ((2 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0b2" : GoString))), _base : ((0 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0b2" : GoString))), _base : ((0 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("08" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("08" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("8" : GoString))), _base : ((8 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("8" : GoString))), _base : ((8 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0xg" : GoString))), _base : ((0 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0xg" : GoString))), _base : ((0 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("g" : GoString))), _base : ((16 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("g" : GoString))), _base : ((16 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("_" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("_" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0_" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0_" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("_0" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("_0" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("-1__0" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("-1__0" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("0x10_" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0x10_" : GoString))), _out : "", _base : 0, _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("1_000" : GoString))), _base : ((10 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("1_000" : GoString))), _base : ((10 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((({ _in : ((("d_e_a_d" : GoString))), _base : ((16 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("d_e_a_d" : GoString))), _base : ((16 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((new T__struct_45(((("0" : GoString))), ((("0" : GoString))), ((0 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0" : GoString))), ((("0" : GoString))), ((10 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0" : GoString))), ((("0" : GoString))), ((16 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("+0" : GoString))), ((("0" : GoString))), ((0 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("-0" : GoString))), ((("0" : GoString))), ((0 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("10" : GoString))), ((("10" : GoString))), ((0 : GoInt)), ((10 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("10" : GoString))), ((("10" : GoString))), ((10 : GoInt)), ((10 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("10" : GoString))), ((("10" : GoString))), ((16 : GoInt)), ((16 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("-10" : GoString))), ((("-10" : GoString))), ((16 : GoInt)), ((-16 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("+10" : GoString))), ((("10" : GoString))), ((16 : GoInt)), ((16 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0b10" : GoString))), ((("2" : GoString))), ((0 : GoInt)), ((2 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0o10" : GoString))), ((("8" : GoString))), ((0 : GoInt)), ((8 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0x10" : GoString))), ((("16" : GoString))), ((0 : GoInt)), ((16 : GoInt64)), true) : T__struct_45)),
((({ _in : ((("0x10" : GoString))), _base : ((16 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)) == null ? null : (({ _in : ((("0x10" : GoString))), _base : ((16 : GoInt)), _out : "", _val : 0, _ok : false } : T__struct_45)).__copy__()),
((new T__struct_45(((("-0x10" : GoString))), ((("-16" : GoString))), ((0 : GoInt)), ((-16 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("+0x10" : GoString))), ((("16" : GoString))), ((0 : GoInt)), ((16 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("00" : GoString))), ((("0" : GoString))), ((0 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0" : GoString))), ((("0" : GoString))), ((8 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("07" : GoString))), ((("7" : GoString))), ((0 : GoInt)), ((7 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("7" : GoString))), ((("7" : GoString))), ((8 : GoInt)), ((7 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("023" : GoString))), ((("19" : GoString))), ((0 : GoInt)), ((19 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("23" : GoString))), ((("23" : GoString))), ((8 : GoInt)), ((19 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("cafebabe" : GoString))), ((("cafebabe" : GoString))), ((16 : GoInt)), (("3405691582" : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0b0" : GoString))), ((("0" : GoString))), ((0 : GoInt)), ((0 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("-111" : GoString))), ((("-111" : GoString))), ((2 : GoInt)), ((-7 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("-0b111" : GoString))), ((("-7" : GoString))), ((0 : GoInt)), ((-7 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0b1001010111" : GoString))), ((("599" : GoString))), ((0 : GoInt)), ((599 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("1001010111" : GoString))), ((("1001010111" : GoString))), ((2 : GoInt)), ((599 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("A" : GoString))), ((("a" : GoString))), ((36 : GoInt)), ((10 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("A" : GoString))), ((("A" : GoString))), ((37 : GoInt)), ((36 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("ABCXYZ" : GoString))), ((("abcxyz" : GoString))), ((36 : GoInt)), ((623741435 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("ABCXYZ" : GoString))), ((("ABCXYZ" : GoString))), ((62 : GoInt)), (("33536793425" : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("1_000" : GoString))), ((("1000" : GoString))), ((0 : GoInt)), ((1000 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("0b_1010" : GoString))), ((("10" : GoString))), ((0 : GoInt)), ((10 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("+0o_660" : GoString))), ((("432" : GoString))), ((0 : GoInt)), ((432 : GoInt64)), true) : T__struct_45)),
((new T__struct_45(((("-0xF00D_1E" : GoString))), ((("-15731998" : GoString))), ((0 : GoInt)), ((-15731998 : GoInt64)), true) : T__struct_45))) : Slice<T__struct_45>));
var _formatTests : Slice<T__struct_46> = ((new Slice<T__struct_46>(
((new T__struct_46(((("<nil>" : GoString))), ((("%x" : GoString))), ((("<nil>" : GoString)))) : T__struct_46)),
((new T__struct_46(((("<nil>" : GoString))), ((("%#x" : GoString))), ((("<nil>" : GoString)))) : T__struct_46)),
((new T__struct_46(((("<nil>" : GoString))), ((("%#y" : GoString))), ((("%!y(big.Int=<nil>)" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%b" : GoString))), ((("1010" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%o" : GoString))), ((("12" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%d" : GoString))), ((("10" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%v" : GoString))), ((("10" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%x" : GoString))), ((("a" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%X" : GoString))), ((("A" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%X" : GoString))), ((("-A" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%y" : GoString))), ((("%!y(big.Int=10)" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%y" : GoString))), ((("%!y(big.Int=-10)" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#b" : GoString))), ((("0b1010" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#o" : GoString))), ((("012" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%O" : GoString))), ((("0o12" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%#b" : GoString))), ((("-0b1010" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%#o" : GoString))), ((("-012" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%O" : GoString))), ((("-0o12" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#d" : GoString))), ((("10" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#v" : GoString))), ((("10" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#x" : GoString))), ((("0xa" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#X" : GoString))), ((("0XA" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%#X" : GoString))), ((("-0XA" : GoString)))) : T__struct_46)),
((new T__struct_46(((("10" : GoString))), ((("%#y" : GoString))), ((("%!y(big.Int=10)" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-10" : GoString))), ((("%#y" : GoString))), ((("%!y(big.Int=-10)" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%3d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%4d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%d" : GoString))), ((("-1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 5d" : GoString))), (((" 1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+5d" : GoString))), ((("+1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-5d" : GoString))), ((("1234 " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%x" : GoString))), ((("4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%X" : GoString))), ((("4D2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%3x" : GoString))), ((("-4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%4x" : GoString))), ((("-4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%5x" : GoString))), (((" -4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-5x" : GoString))), ((("-4d2 " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%03d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%04d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%05d" : GoString))), ((("01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%06d" : GoString))), ((("001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%06d" : GoString))), ((("-01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+06d" : GoString))), ((("+01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 06d" : GoString))), (((" 01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-6d" : GoString))), ((("1234  " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-06d" : GoString))), ((("1234  " : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-06d" : GoString))), ((("-1234 " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.3d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.4d" : GoString))), ((("1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.5d" : GoString))), ((("01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.6d" : GoString))), ((("001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.3d" : GoString))), ((("-1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.4d" : GoString))), ((("-1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.5d" : GoString))), ((("-01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.6d" : GoString))), ((("-001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.3d" : GoString))), ((("    1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.4d" : GoString))), ((("    1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.5d" : GoString))), ((("   01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.6d" : GoString))), ((("  001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.3d" : GoString))), ((("   -1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.4d" : GoString))), ((("   -1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.5d" : GoString))), ((("  -01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.6d" : GoString))), (((" -001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.3d" : GoString))), ((("   +1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.4d" : GoString))), ((("   +1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.5d" : GoString))), ((("  +01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.6d" : GoString))), (((" +001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.3d" : GoString))), ((("   -1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.4d" : GoString))), ((("   -1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.5d" : GoString))), ((("  -01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.6d" : GoString))), (((" -001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.3d" : GoString))), ((("    1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.4d" : GoString))), ((("    1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.5d" : GoString))), ((("   01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.6d" : GoString))), ((("  001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.3d" : GoString))), ((("   -1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.4d" : GoString))), ((("   -1234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.5d" : GoString))), ((("  -01234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.6d" : GoString))), (((" -001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.3x" : GoString))), ((("4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.4x" : GoString))), ((("04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.5x" : GoString))), ((("004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%.6x" : GoString))), ((("0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.3x" : GoString))), ((("-4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.4x" : GoString))), ((("-04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.5x" : GoString))), ((("-004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%.6x" : GoString))), ((("-0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.3x" : GoString))), ((("     4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.4x" : GoString))), ((("    04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.5x" : GoString))), ((("   004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%8.6x" : GoString))), ((("  0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.3x" : GoString))), ((("    -4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.4x" : GoString))), ((("   -04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.5x" : GoString))), ((("  -004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%8.6x" : GoString))), (((" -0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.3x" : GoString))), ((("    +4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.4x" : GoString))), ((("   +04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.5x" : GoString))), ((("  +004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%+8.6x" : GoString))), (((" +0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.3x" : GoString))), ((("    -4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.4x" : GoString))), ((("   -04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.5x" : GoString))), ((("  -004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%+8.6x" : GoString))), (((" -0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.3x" : GoString))), ((("     4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.4x" : GoString))), ((("    04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.5x" : GoString))), ((("   004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.6x" : GoString))), ((("  0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.7x" : GoString))), (((" 00004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("% 8.8x" : GoString))), (((" 000004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.3x" : GoString))), ((("    -4d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.4x" : GoString))), ((("   -04d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.5x" : GoString))), ((("  -004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.6x" : GoString))), (((" -0004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.7x" : GoString))), ((("-00004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("% 8.8x" : GoString))), ((("-000004d2" : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-8.3d" : GoString))), ((("1234    " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-8.4d" : GoString))), ((("1234    " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-8.5d" : GoString))), ((("01234   " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-8.6d" : GoString))), ((("001234  " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-8.7d" : GoString))), ((("0001234 " : GoString)))) : T__struct_46)),
((new T__struct_46(((("1234" : GoString))), ((("%-8.8d" : GoString))), ((("00001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-8.3d" : GoString))), ((("-1234   " : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-8.4d" : GoString))), ((("-1234   " : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-8.5d" : GoString))), ((("-01234  " : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-8.6d" : GoString))), ((("-001234 " : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-8.7d" : GoString))), ((("-0001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("-1234" : GoString))), ((("%-8.8d" : GoString))), ((("-00001234" : GoString)))) : T__struct_46)),
((new T__struct_46(((("16777215" : GoString))), ((("%b" : GoString))), ((("111111111111111111111111" : GoString)))) : T__struct_46)),
((new T__struct_46(((("0" : GoString))), ((("%.d" : GoString))), ((("" : GoString)))) : T__struct_46)),
((new T__struct_46(((("0" : GoString))), ((("%.0d" : GoString))), ((("" : GoString)))) : T__struct_46)),
((new T__struct_46(((("0" : GoString))), ((("%3.d" : GoString))), ((("" : GoString)))) : T__struct_46))) : Slice<T__struct_46>));
var _scanTests : Slice<T__struct_47> = ((new Slice<T__struct_47>(
((new T__struct_47(((("1010" : GoString))), ((("%b" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("0b1010" : GoString))), ((("%v" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("12" : GoString))), ((("%o" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("012" : GoString))), ((("%v" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("10" : GoString))), ((("%d" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("10" : GoString))), ((("%v" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("a" : GoString))), ((("%x" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("0xa" : GoString))), ((("%v" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("A" : GoString))), ((("%X" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("-A" : GoString))), ((("%X" : GoString))), ((("-10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("+0b1011001" : GoString))), ((("%v" : GoString))), ((("89" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("0xA" : GoString))), ((("%v" : GoString))), ((("10" : GoString))), ((0 : GoInt))) : T__struct_47)),
((new T__struct_47(((("0 " : GoString))), ((("%v" : GoString))), ((("0" : GoString))), ((1 : GoInt))) : T__struct_47)),
((new T__struct_47(((("2+3" : GoString))), ((("%v" : GoString))), ((("2" : GoString))), ((2 : GoInt))) : T__struct_47)),
((new T__struct_47(((("0XABC 12" : GoString))), ((("%v" : GoString))), ((("2748" : GoString))), ((3 : GoInt))) : T__struct_47))) : Slice<T__struct_47>));
var _encodingTests : Slice<GoString> = ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("2" : GoString))), ((("10" : GoString))), ((("1000" : GoString))), ((("1234567890" : GoString))), ((("298472983472983471903246121093472394872319615612417471234712061" : GoString)))) : Slice<GoString>));
var _cmpTests : Slice<T__struct_48> = ((new Slice<T__struct_48>(
((new T__struct_48(null, null, ((0 : GoInt))) : T__struct_48)),
((new T__struct_48(null, ((new T_nat() : T_nat)), ((0 : GoInt))) : T__struct_48)),
((new T__struct_48(((new T_nat() : T_nat)), null, ((0 : GoInt))) : T__struct_48)),
((new T__struct_48(((new T_nat() : T_nat)), ((new T_nat() : T_nat)), ((0 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((0 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((-1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((0 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((-1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((1 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((-1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((16 : GoUInt)), ((571956 : GoUInt)), ((8794 : GoUInt)), ((68 : GoUInt))) : T_nat)), ((new Slice<Word>(((837 : GoUInt)), ((9146 : GoUInt)), ((1 : GoUInt)), ((754489 : GoUInt))) : T_nat)), ((-1 : GoInt))) : T__struct_48)),
((new T__struct_48(((new Slice<Word>(((34986 : GoUInt)), ((41 : GoUInt)), ((105 : GoUInt)), ((1957 : GoUInt))) : T_nat)), ((new Slice<Word>(((56 : GoUInt)), ((7458 : GoUInt)), ((104 : GoUInt)), ((1957 : GoUInt))) : T_nat)), ((1 : GoInt))) : T__struct_48))) : Slice<T__struct_48>));
var _sumNN : Slice<T_argNN> = ((new Slice<T_argNN>(((new T_argNN() : T_argNN)), ((new T_argNN(((new Slice<Word>(((1 : GoUInt))) : T_nat)), null, ((new Slice<Word>(((1 : GoUInt))) : T_nat))) : T_argNN)), ((new T_argNN(((new Slice<Word>(((1111111110 : GoUInt))) : T_nat)), ((new Slice<Word>(((123456789 : GoUInt))) : T_nat)), ((new Slice<Word>(((987654321 : GoUInt))) : T_nat))) : T_argNN)), ((new T_argNN(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt))) : T_nat)), null, ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt))) : T_nat))) : T_argNN)), ((new T_argNN(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1111111110 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((123456789 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((987654321 : GoUInt))) : T_nat))) : T_argNN)), ((new T_argNN(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), (("4294967295" : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((1 : GoUInt))) : T_nat))) : T_argNN))) : Slice<T_argNN>));
var _prodNN : Slice<T_argNN> = ((new Slice<T_argNN>(
((new T_argNN() : T_argNN)),
((new T_argNN(null, null, null) : T_argNN)),
((new T_argNN(null, ((new Slice<Word>(((991 : GoUInt))) : T_nat)), null) : T_argNN)),
((new T_argNN(((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat))) : T_argNN)),
((new T_argNN(((new Slice<Word>(((982081 : GoUInt))) : T_nat)), ((new Slice<Word>(((991 : GoUInt))) : T_nat)), ((new Slice<Word>(((991 : GoUInt))) : T_nat))) : T_argNN)),
((new T_argNN(((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), ((982081 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((991 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((991 : GoUInt))) : T_nat))) : T_argNN)),
((new T_argNN(((new Slice<Word>(((991 : GoUInt)), ((1982 : GoUInt)), ((2973 : GoUInt)), ((3964 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt)), ((2 : GoUInt)), ((3 : GoUInt)), ((4 : GoUInt))) : T_nat)), ((new Slice<Word>(((991 : GoUInt))) : T_nat))) : T_argNN)),
((new T_argNN(((new Slice<Word>(((4 : GoUInt)), ((11 : GoUInt)), ((20 : GoUInt)), ((30 : GoUInt)), ((20 : GoUInt)), ((11 : GoUInt)), ((4 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt)), ((2 : GoUInt)), ((3 : GoUInt)), ((4 : GoUInt))) : T_nat)), ((new Slice<Word>(((4 : GoUInt)), ((3 : GoUInt)), ((2 : GoUInt)), ((1 : GoUInt))) : T_nat))) : T_argNN)),
((new T_argNN((_natFromString(((("11790184577738583171520872861412518665678211592275841109096961" : GoString)))) == null ? null : _natFromString(((("11790184577738583171520872861412518665678211592275841109096961" : GoString)))).__copy__()), (_natFromString(((("515377520732011331036461129765621272702107522001" : GoString)))) == null ? null : _natFromString(((("515377520732011331036461129765621272702107522001" : GoString)))).__copy__()), (_natFromString(((("22876792454961" : GoString)))) == null ? null : _natFromString(((("22876792454961" : GoString)))).__copy__())) : T_argNN)),
((new T_argNN((_natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((70000 : GoInt)))) == null ? null : _natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((70000 : GoInt)))).__copy__()), (_natFromString(((("1" : GoString))) + stdgo.strings.Strings.repeat(stdgo.strings.Strings.repeat(((("0" : GoString))), ((699 : GoInt))) + ((("1" : GoString))), ((99 : GoInt)))) == null ? null : _natFromString(((("1" : GoString))) + stdgo.strings.Strings.repeat(stdgo.strings.Strings.repeat(((("0" : GoString))), ((699 : GoInt))) + ((("1" : GoString))), ((99 : GoInt)))).__copy__()), (_natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((700 : GoInt)))) == null ? null : _natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((700 : GoInt)))).__copy__())) : T_argNN)),
((new T_argNN((_natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((20000 : GoInt)))) == null ? null : _natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((20000 : GoInt)))).__copy__()), (_natFromString((((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((9999 : GoInt)))) + ((("1" : GoString)))) == null ? null : _natFromString((((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((9999 : GoInt)))) + ((("1" : GoString)))).__copy__()), (_natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((10000 : GoInt)))) == null ? null : _natFromString(stdgo.strings.Strings.repeat(((("1" : GoString))), ((10000 : GoInt)))).__copy__())) : T_argNN))) : Slice<T_argNN>));
var _mulRangesN : Slice<T__struct_49> = ((new Slice<T__struct_49>(
((new T__struct_49(((0 : GoUInt64)), ((0 : GoUInt64)), ((("0" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((1 : GoUInt64)), ((("1" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((2 : GoUInt64)), ((("2" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((3 : GoUInt64)), ((("6" : GoString)))) : T__struct_49)),
((new T__struct_49(((10 : GoUInt64)), ((10 : GoUInt64)), ((("10" : GoString)))) : T__struct_49)),
((new T__struct_49(((0 : GoUInt64)), ((100 : GoUInt64)), ((("0" : GoString)))) : T__struct_49)),
((new T__struct_49(((0 : GoUInt64)), ((1e+09 : GoUInt64)), ((("0" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((0 : GoUInt64)), ((("1" : GoString)))) : T__struct_49)),
((new T__struct_49(((100 : GoUInt64)), ((1 : GoUInt64)), ((("1" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((10 : GoUInt64)), ((("3628800" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((20 : GoUInt64)), ((("2432902008176640000" : GoString)))) : T__struct_49)),
((new T__struct_49(((1 : GoUInt64)), ((100 : GoUInt64)), ((("93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000" : GoString)))) : T__struct_49))) : Slice<T__struct_49>));
var _mulBenchSizes : Slice<GoInt> = ((new Slice<GoInt>(((10 : GoInt)), ((100 : GoInt)), ((1000 : GoInt)), ((10000 : GoInt)), ((100000 : GoInt))) : Slice<GoInt>));
var _leftShiftTests : Slice<T_shiftTest> = ((new Slice<T_shiftTest>(((new T_shiftTest(null, ((0 : GoUInt)), null) : T_shiftTest)), ((new T_shiftTest(null, ((1 : GoUInt)), null) : T_shiftTest)), ((new T_shiftTest((_natOne == null ? null : _natOne.__copy__()), ((0 : GoUInt)), (_natOne == null ? null : _natOne.__copy__())) : T_shiftTest)), ((new T_shiftTest((_natOne == null ? null : _natOne.__copy__()), ((1 : GoUInt)), (_natTwo == null ? null : _natTwo.__copy__())) : T_shiftTest)), ((new T_shiftTest(((new Slice<Word>((("2147483648" : GoUInt))) : T_nat)), ((1 : GoUInt)), ((new Slice<Word>(((0 : GoUInt))) : T_nat))) : T_shiftTest)), ((new T_shiftTest(((new Slice<Word>((("2147483648" : GoUInt)), ((0 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((new Slice<Word>(((0 : GoUInt)), ((1 : GoUInt))) : T_nat))) : T_shiftTest))) : Slice<T_shiftTest>));
var _rightShiftTests : Slice<T_shiftTest> = ((new Slice<T_shiftTest>(((new T_shiftTest(null, ((0 : GoUInt)), null) : T_shiftTest)), ((new T_shiftTest(null, ((1 : GoUInt)), null) : T_shiftTest)), ((new T_shiftTest((_natOne == null ? null : _natOne.__copy__()), ((0 : GoUInt)), (_natOne == null ? null : _natOne.__copy__())) : T_shiftTest)), ((new T_shiftTest((_natOne == null ? null : _natOne.__copy__()), ((1 : GoUInt)), null) : T_shiftTest)), ((new T_shiftTest((_natTwo == null ? null : _natTwo.__copy__()), ((1 : GoUInt)), (_natOne == null ? null : _natOne.__copy__())) : T_shiftTest)), ((new T_shiftTest(((new Slice<Word>(((0 : GoUInt)), ((1 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((new Slice<Word>((("2147483648" : GoUInt))) : T_nat))) : T_shiftTest)), ((new T_shiftTest(((new Slice<Word>(((2 : GoUInt)), ((1 : GoUInt)), ((1 : GoUInt))) : T_nat)), ((1 : GoUInt)), ((new Slice<Word>((("2147483649" : GoUInt)), (("2147483648" : GoUInt))) : T_nat))) : T_shiftTest))) : Slice<T_shiftTest>));
var _modWTests32 : Slice<T_modWTest> = ((new Slice<T_modWTest>(((new T_modWTest(((("23492635982634928349238759823742" : GoString))), ((("252341" : GoString))), ((("220170" : GoString)))) : T_modWTest))) : Slice<T_modWTest>));
var _modWTests64 : Slice<T_modWTest> = ((new Slice<T_modWTest>(((new T_modWTest(((("6527895462947293856291561095690465243862946" : GoString))), ((("524326975699234" : GoString))), ((("375066989628668" : GoString)))) : T_modWTest))) : Slice<T_modWTest>));
var _montgomeryTests : Slice<T__struct_50> = ((new Slice<T__struct_50>(((new T__struct_50(((("0xffffffffffffffffffffffffffffffffffffffffffffffffe" : GoString))), ((("0xffffffffffffffffffffffffffffffffffffffffffffffffe" : GoString))), ((("0xfffffffffffffffffffffffffffffffffffffffffffffffff" : GoString))), ((1 : GoUInt64)), ((("0x1000000000000000000000000000000000000000000" : GoString))), ((("0x10000000000000000000000000000000000" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x000000000ffffff5" : GoString))), ((("0x000000000ffffff0" : GoString))), ((("0x0000000010000001" : GoString))), (("18374686479940059135" : GoUInt64)), ((("0x000000000bfffff4" : GoString))), ((("0x0000000003400001" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x0000000080000000" : GoString))), ((("0x00000000ffffffff" : GoString))), ((("0x1000000000000001" : GoString))), (("1152921504606846975" : GoUInt64)), ((("0x0800000008000001" : GoString))), ((("0x0800000008000001" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x0000000080000000" : GoString))), ((("0x0000000080000000" : GoString))), ((("0xffffffff00000001" : GoString))), (("18446744069414584319" : GoUInt64)), ((("0xbfffffff40000001" : GoString))), ((("0xbfffffff40000001" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x0000000080000000" : GoString))), ((("0x0000000080000000" : GoString))), ((("0x00ffffff00000001" : GoString))), (("72057589742960639" : GoUInt64)), ((("0xbfffff40000001" : GoString))), ((("0xbfffff40000001" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x0000000080000000" : GoString))), ((("0x0000000080000000" : GoString))), ((("0x0000ffff00000001" : GoString))), (("281470681743359" : GoUInt64)), ((("0xbfff40000001" : GoString))), ((("0xbfff40000001" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x3321ffffffffffffffffffffffffffff00000000000022222623333333332bbbb888c0" : GoString))), ((("0x3321ffffffffffffffffffffffffffff00000000000022222623333333332bbbb888c0" : GoString))), ((("0x33377fffffffffffffffffffffffffffffffffffffffffffff0000000000022222eee1" : GoString))), (("16054364080374360799" : GoUInt64)), ((("0x04eb0e11d72329dc0915f86784820fc403275bf2f6620a20e0dd344c5cd0875e50deb5" : GoString))), ((("0x0d7144739a7d8e11d72329dc0915f86784820fc403275bf2f61ed96f35dd34dbb3d6a0" : GoString)))) : T__struct_50)), ((new T__struct_50(((("0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff00000000000022222223333333333444444444" : GoString))), ((("0x10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ffffffffffffffffffffffffffffffff999999999999999aaabbbbbbbbcccccccccccc" : GoString))), ((("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff33377fffffffffffffffffffffffffffffffffffffffffffff0000000000022222eee1" : GoString))), (("16054364080374360799" : GoUInt64)), ((("0x5c0d52f451aec609b15da8e5e5626c4eaa88723bdeac9d25ca9b961269400410ca208a16af9c2fb07d7a11c7772cba02c22f9711078d51a3797eb18e691295293284d988e349fa6deba46b25a4ecd9f715" : GoString))), ((("0x92fcad4b5c0d52f451aec609b15da8e5e5626c4eaa88723bdeac9d25ca9b961269400410ca208a16af9c2fb07d799c32fe2f3cc5422f9711078d51a3797eb18e691295293284d8f5e69caf6decddfe1df6" : GoString)))) : T__struct_50))) : Slice<T__struct_50>));
var _expNNTests : Slice<T__struct_37> = ((new Slice<T__struct_37>(
((new T__struct_37(((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString))), ((("1" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0" : GoString))), ((("0" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("1" : GoString))), ((("1" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2" : GoString))), ((("1" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2" : GoString))), ((("2" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("10" : GoString))), ((("100000000000" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("2" : GoString))), ((("" : GoString))), ((("0x40000000000000000000000000000000" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("2" : GoString))), ((("6719" : GoString))), ((("4944" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("3" : GoString))), ((("6719" : GoString))), ((("5447" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("1000" : GoString))), ((("6719" : GoString))), ((("1603" : GoString)))) : T__struct_37)),
((new T__struct_37(((("0x8000000000000000" : GoString))), ((("1000000" : GoString))), ((("6719" : GoString))), ((("3199" : GoString)))) : T__struct_37)),
((new T__struct_37(((("2938462938472983472983659726349017249287491026512746239764525612965293865296239471239874193284792387498274256129746192347" : GoString))), ((("298472983472983471903246121093472394872319615612417471234712061" : GoString))), ((("29834729834729834729347290846729561262544958723956495615629569234729836259263598127342374289365912465901365498236492183464" : GoString))), ((("23537740700184054162508175125554701713153216681790245129157191391322321508055833908509185839069455749219131480588829346291" : GoString)))) : T__struct_37)),
((new T__struct_37(((("11521922904531591643048817447554701904414021819823889996244743037378330903763518501116638828335352811871131385129455853417360623007349090150042001944696604737499160174391019030572483602867266711107136838523916077674888297896995042968746762200926853379" : GoString))), ((("426343618817810911523" : GoString))), ((("444747819283133684179" : GoString))), ((("42" : GoString)))) : T__struct_37))) : Slice<T__struct_37>));
var _fiboNums : Slice<GoString> = ((new Slice<GoString>(
((("0" : GoString))),
((("55" : GoString))),
((("6765" : GoString))),
((("832040" : GoString))),
((("102334155" : GoString))),
((("12586269025" : GoString))),
((("1548008755920" : GoString))),
((("190392490709135" : GoString))),
((("23416728348467685" : GoString))),
((("2880067194370816120" : GoString))),
((("354224848179261915075" : GoString)))) : Slice<GoString>));
var _bitTests : Slice<T__struct_51> = ((new Slice<T__struct_51>(
((new T__struct_51(((("0" : GoString))), ((0 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0" : GoString))), ((1 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0" : GoString))), ((1000 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1" : GoString))), ((0 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x10" : GoString))), ((0 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x10" : GoString))), ((3 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x10" : GoString))), ((4 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x10" : GoString))), ((5 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x8000000000000000" : GoString))), ((62 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x8000000000000000" : GoString))), ((63 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x8000000000000000" : GoString))), ((64 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x3" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((32 : GoInt))), ((127 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x3" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((32 : GoInt))), ((128 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x3" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((32 : GoInt))), ((129 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x3" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((32 : GoInt))), ((130 : GoUInt)), ((0 : GoUInt))) : T__struct_51))) : Slice<T__struct_51>));
var _stickyTests : Slice<T__struct_51> = ((new Slice<T__struct_51>(
((new T__struct_51(((("0" : GoString))), ((0 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0" : GoString))), ((1 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0" : GoString))), ((1000 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1" : GoString))), ((0 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1" : GoString))), ((1 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1350" : GoString))), ((0 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1350" : GoString))), ((4 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1350" : GoString))), ((5 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x8000000000000000" : GoString))), ((63 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x8000000000000000" : GoString))), ((64 : GoUInt)), ((1 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((100 : GoInt))), ((400 : GoUInt)), ((0 : GoUInt))) : T__struct_51)),
((new T__struct_51(((("0x1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((100 : GoInt))), ((401 : GoUInt)), ((1 : GoUInt))) : T__struct_51))) : Slice<T__struct_51>));
var _sqrBenchSizes : Slice<GoInt> = ((new Slice<GoInt>(
((1 : GoInt)),
((2 : GoInt)),
((3 : GoInt)),
((5 : GoInt)),
((8 : GoInt)),
((10 : GoInt)),
((20 : GoInt)),
((30 : GoInt)),
((50 : GoInt)),
((80 : GoInt)),
((100 : GoInt)),
((200 : GoInt)),
((300 : GoInt)),
((500 : GoInt)),
((800 : GoInt)),
((1000 : GoInt)),
((10000 : GoInt)),
((100000 : GoInt))) : Slice<GoInt>));
var _strTests : Slice<T__struct_53> = ((new Slice<T__struct_53>(((new T__struct_53(null, ((2 : GoInt)), ((("0" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((2 : GoInt)), ((("1" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((197 : GoUInt))) : T_nat)), ((2 : GoInt)), ((("11000101" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((1721 : GoUInt))) : T_nat)), ((8 : GoInt)), ((("3271" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((10 : GoUInt))) : T_nat)), ((10 : GoInt)), ((("10" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((1234567890 : GoUInt))) : T_nat)), ((10 : GoInt)), ((("1234567890" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>((("3735928559" : GoUInt))) : T_nat)), ((16 : GoInt)), ((("deadbeef" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((2268135 : GoUInt))) : T_nat)), ((17 : GoInt)), ((("1a2b3c" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((815162342 : GoUInt))) : T_nat)), ((32 : GoInt)), ((("o9cov6" : GoString)))) : T__struct_53)), ((new T__struct_53(((new Slice<Word>(((815162342 : GoUInt))) : T_nat)), ((62 : GoInt)), ((("TakXI" : GoString)))) : T__struct_53))) : Slice<T__struct_53>));
var _natScanTests : Slice<T__struct_54> = ((new Slice<T__struct_54>(
((new T__struct_54(((("" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("_" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("?" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("?" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("?" : GoString))), ((10 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("?" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("" : GoString))), ((10 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("" : GoString))), ((36 : GoInt)), false, null, ((36 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("" : GoString))), ((62 : GoInt)), false, null, ((62 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0b" : GoString))), ((0 : GoInt)), false, null, ((2 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0o" : GoString))), ((0 : GoInt)), false, null, ((8 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x" : GoString))), ((0 : GoInt)), false, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x_" : GoString))), ((0 : GoInt)), false, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0b2" : GoString))), ((0 : GoInt)), false, null, ((2 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("2" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0B2" : GoString))), ((0 : GoInt)), false, null, ((2 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("2" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0o8" : GoString))), ((0 : GoInt)), false, null, ((8 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0O8" : GoString))), ((0 : GoInt)), false, null, ((8 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0xg" : GoString))), ((0 : GoInt)), false, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("g" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0Xg" : GoString))), ((0 : GoInt)), false, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("g" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("345" : GoString))), ((2 : GoInt)), false, null, ((2 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("3" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("._" : GoString))), ((0 : GoInt)), true, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54((((".0" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("." : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54((((".0" : GoString))), ((10 : GoInt)), false, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("." : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("." : GoString))), ((0 : GoInt)), true, null, ((10 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x." : GoString))), ((0 : GoInt)), true, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x.g" : GoString))), ((0 : GoInt)), true, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("g" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0x.0" : GoString))), ((0 : GoInt)), false, null, ((16 : GoInt)), ((0 : GoInt)), _errNoDigits, ((((("." : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("_0" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0_" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0__0" : GoString))), ((0 : GoInt)), false, null, ((8 : GoInt)), ((1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x___0" : GoString))), ((0 : GoInt)), false, null, ((16 : GoInt)), ((1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0_x" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), _errInvalSep, ((((("x" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0_8" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), _errInvalSep, ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("123_." : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((123 : GoUInt))) : T_nat)), ((10 : GoInt)), ((0 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("._123" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((123 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-3 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0b__1000" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((8 : GoUInt))) : T_nat)), ((2 : GoInt)), ((4 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0o60___0" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((384 : GoUInt))) : T_nat)), ((8 : GoInt)), ((3 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0466_" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((310 : GoUInt))) : T_nat)), ((8 : GoInt)), ((3 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("01234567_8" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((342391 : GoUInt))) : T_nat)), ((8 : GoInt)), ((7 : GoInt)), _errInvalSep, ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("1_." : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((0 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0._1" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("2.7_" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((27 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x1.0_" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((16 : GoUInt))) : T_nat)), ((16 : GoInt)), ((-1 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0_" : GoString))), ((10 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("_" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("1__0" : GoString))), ((10 : GoInt)), false, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("_" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0__8" : GoString))), ((10 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("_" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("xy_z_" : GoString))), ((36 : GoInt)), false, ((new Slice<Word>(((1222 : GoUInt))) : T_nat)), ((36 : GoInt)), ((2 : GoInt)), ((null : stdgo.Error)), ((((("_" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0" : GoString))), ((36 : GoInt)), false, null, ((36 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0" : GoString))), ((62 : GoInt)), false, null, ((62 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("1" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("1" : GoString))), ((10 : GoInt)), false, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0 " : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), (((((" " : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("00 " : GoString))), ((0 : GoInt)), false, null, ((8 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), (((((" " : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0b1" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((2 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0B11000101" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((197 : GoUInt))) : T_nat)), ((2 : GoInt)), ((8 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0B110001012" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((197 : GoUInt))) : T_nat)), ((2 : GoInt)), ((8 : GoInt)), ((null : stdgo.Error)), ((((("2" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("07" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((7 : GoUInt))) : T_nat)), ((8 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("08" : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("08" : GoString))), ((10 : GoInt)), false, ((new Slice<Word>(((8 : GoUInt))) : T_nat)), ((10 : GoInt)), ((2 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("018" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((8 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0o7" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((7 : GoUInt))) : T_nat)), ((8 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0o18" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((8 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0O17" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((15 : GoUInt))) : T_nat)), ((8 : GoInt)), ((2 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("03271" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1721 : GoUInt))) : T_nat)), ((8 : GoInt)), ((4 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("10ab" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((10 : GoUInt))) : T_nat)), ((10 : GoInt)), ((2 : GoInt)), ((null : stdgo.Error)), ((((("a" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("1234567890" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1234567890 : GoUInt))) : T_nat)), ((10 : GoInt)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("A" : GoString))), ((36 : GoInt)), false, ((new Slice<Word>(((10 : GoUInt))) : T_nat)), ((36 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("A" : GoString))), ((37 : GoInt)), false, ((new Slice<Word>(((36 : GoUInt))) : T_nat)), ((37 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("xyz" : GoString))), ((36 : GoInt)), false, ((new Slice<Word>(((44027 : GoUInt))) : T_nat)), ((36 : GoInt)), ((3 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("XYZ?" : GoString))), ((36 : GoInt)), false, ((new Slice<Word>(((44027 : GoUInt))) : T_nat)), ((36 : GoInt)), ((3 : GoInt)), ((null : stdgo.Error)), ((((("?" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("XYZ?" : GoString))), ((62 : GoInt)), false, ((new Slice<Word>(((230577 : GoUInt))) : T_nat)), ((62 : GoInt)), ((3 : GoInt)), ((null : stdgo.Error)), ((((("?" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0x" : GoString))), ((16 : GoInt)), false, null, ((16 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("x" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0xdeadbeef" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>((("3735928559" : GoUInt))) : T_nat)), ((16 : GoInt)), ((8 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0XDEADBEEF" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>((("3735928559" : GoUInt))) : T_nat)), ((16 : GoInt)), ((8 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0." : GoString))), ((0 : GoInt)), false, null, ((10 : GoInt)), ((1 : GoInt)), ((null : stdgo.Error)), ((((("." : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0." : GoString))), ((10 : GoInt)), true, null, ((10 : GoInt)), ((0 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0.1.2" : GoString))), ((10 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((((("." : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54((((".000" : GoString))), ((10 : GoInt)), true, null, ((10 : GoInt)), ((-3 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("12.3" : GoString))), ((10 : GoInt)), true, ((new Slice<Word>(((123 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("012.345" : GoString))), ((10 : GoInt)), true, ((new Slice<Word>(((12345 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-3 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0.1" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0.1" : GoString))), ((2 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((2 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0.12" : GoString))), ((2 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((2 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((((("2" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0b0.1" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((2 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0B0.12" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((2 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((((("2" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0o0.7" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((7 : GoUInt))) : T_nat)), ((8 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0O0.78" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((7 : GoUInt))) : T_nat)), ((8 : GoInt)), ((-1 : GoInt)), ((null : stdgo.Error)), ((((("8" : GoString))).code : GoRune))) : T__struct_54)),
((new T__struct_54(((("0xdead.beef" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>((("3735928559" : GoUInt))) : T_nat)), ((16 : GoInt)), ((-4 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("1_000" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((1000 : GoUInt))) : T_nat)), ((10 : GoInt)), ((4 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0_466" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((310 : GoUInt))) : T_nat)), ((8 : GoInt)), ((3 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0o_600" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((384 : GoUInt))) : T_nat)), ((8 : GoInt)), ((3 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x_f0_0d" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((61453 : GoUInt))) : T_nat)), ((16 : GoInt)), ((4 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0b1000_0001" : GoString))), ((0 : GoInt)), false, ((new Slice<Word>(((129 : GoUInt))) : T_nat)), ((2 : GoInt)), ((8 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("1_000.000_1" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((10000001 : GoUInt))) : T_nat)), ((10 : GoInt)), ((-4 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x_f00d.1e" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((15731998 : GoUInt))) : T_nat)), ((16 : GoInt)), ((-2 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x_f00d.1E2" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((251711970 : GoUInt))) : T_nat)), ((16 : GoInt)), ((-3 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_54)),
((new T__struct_54(((("0x_f00d.1eg" : GoString))), ((0 : GoInt)), true, ((new Slice<Word>(((15731998 : GoUInt))) : T_nat)), ((16 : GoInt)), ((-2 : GoInt)), ((null : stdgo.Error)), ((((("g" : GoString))).code : GoRune))) : T__struct_54))) : Slice<T__struct_54>));
var _pi : GoString = ((("3141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863278865936153381827968230301952035301852968995773622599413891249721775283479131515574857242454150695950829533116861727855889075098381754637464939319255060400927701671139009848824012858361603563707660104710181942955596198946767837449448255379774726847104047534646208046684259069491293313677028989152104752162056966024058038150193511253382430035587640247496473263914199272604269922796782354781636009341721641219924586315030286182974555706749838505494588586926995690927210797509302955321165344987202755960236480665499119881834797753566369807426542527862551818417574672890977772793800081647060016145249192173217214772350141441973568548161361157352552133475741849468438523323907394143334547762416862518983569485562099219222184272550254256887671790494601653466804988627232791786085784383827967976681454100953883786360950680064225125205117392984896084128488626945604241965285022210661186306744278622039194945047123713786960956364371917287467764657573962413890865832645995813390478027590099465764078951269468398352595709825822620522489407726719478268482601476990902640136394437455305068203496252451749399651431429809190659250937221696461515709858387410597885959772975498930161753928468138268683868942774155991855925245953959431049972524680845987273644695848653836736222626099124608051243884390451244136549762780797715691435997700129616089441694868555848406353422072225828488648158456028506016842739452267467678895252138522549954666727823986456596116354886230577456498035593634568174324112515076069479451096596094025228879710893145669136867228748940560101503308617928680920874760917824938589009714909675985261365549781893129784821682998948722658804857564014270477555132379641451523746234364542858444795265867821051141354735739523113427166102135969536231442952484937187110145765403590279934403742007310578539062198387447808478489683321445713868751943506430218453191048481005370614680674919278191197939952061419663428754440643745123718192179998391015919561814675142691239748940907186494231961567945208095146550225231603881930142093762137855956638937787083039069792077346722182562599661501421503068038447734549202605414665925201497442850732518666002132434088190710486331734649651453905796268561005508106658796998163574736384052571459102897064140110971206280439039759515677157700420337869936007230558763176359421873125147120532928191826186125867321579198414848829164470609575270695722091756711672291098169091528017350671274858322287183520935396572512108357915136988209144421006751033467110314126711136990865851639831501970165151168517143765761835155650884909989859982387345528331635507647918535893226185489632132933089857064204675259070915481416549859461637180270981994309924488957571282890592323326097299712084433573265489382391193259746366730583604142813883032038249037589852437441702913276561809377344403070746921120191302033038019762110110044929321516084244485963766983895228684783123552658213144957685726243344189303968642624341077322697802807318915441101044682325271620105265227211166039666557309254711055785376346682065310989652691862056476931257058635662018558100729360659876486117910453348850346113657686753249441668039626579787718556084552965412665408530614344431858676975145661406800700237877659134401712749470420562230538994561314071127000407854733269939081454664645880797270826683063432858785698305235808933065757406795457163775254202114955761581400250126228594130216471550979259230990796547376125517656751357517829666454779174501129961489030463994713296210734043751895735961458901938971311179042978285647503203198691514028708085990480109412147221317947647772622414254854540332157185306142288137585043063321751829798662237172159160771669254748738986654949450114654062843366393790039769265672146385306736096571209180763832716641627488880078692560290228472104031721186082041900042296617119637792133757511495950156604963186294726547364252308177036751590673502350728354056704038674351362222477158915049530984448933309634087807693259939780541934144737744184263129860809988868741326047215695162396586457302163159819319516735381297416772947867242292465436680098067692823828068996400482435403701416314965897940924323789690706977942236250822168895738379862300159377647165122893578601588161755782973523344604281512627203734314653197777416031990665541876397929334419521541341899485444734567383162499341913181480927777103863877343177207545654532207770921201905166096280490926360197598828161332316663652861932668633606273567630354477628035045077723554710585954870279081435624014517180624643626794561275318134078330336254232783944975382437205835311477119926063813346776879695970309833913077109870408591337" : GoString)));
var _primes : Slice<GoString> = ((new Slice<GoString>(
((("2" : GoString))),
((("3" : GoString))),
((("5" : GoString))),
((("7" : GoString))),
((("11" : GoString))),
((("13756265695458089029" : GoString))),
((("13496181268022124907" : GoString))),
((("10953742525620032441" : GoString))),
((("17908251027575790097" : GoString))),
((("18699199384836356663" : GoString))),
((("98920366548084643601728869055592650835572950932266967461790948584315647051443" : GoString))),
((("94560208308847015747498523884063394671606671904944666360068158221458669711639" : GoString))),
((("449417999055441493994709297093108513015373787049558499205492347871729927573118262811508386655998299074566974373711472560655026288668094291699357843464363003144674940345912431129144354948751003607115263071543163" : GoString))),
((("230975859993204150666423538988557839555560243929065415434980904258310530753006723857139742334640122533598517597674807096648905501653461687601339782814316124971547968912893214002992086353183070342498989426570593" : GoString))),
((("5521712099665906221540423207019333379125265462121169655563495403888449493493629943498064604536961775110765377745550377067893607246020694972959780839151452457728855382113555867743022746090187341871655890805971735385789993" : GoString))),
((("203956878356401977405765866929034577280193993314348263094772646453283062722701277632936616063144088173312372882677123879538709400158306567338328279154499698366071906766440037074217117805690872792848149112022286332144876183376326512083574821647933992961249917319836219304274280243803104015000563790123" : GoString))),
((("3618502788666131106986593281521497120414687020801267626233049500247285301239" : GoString))),
((("57896044618658097711785492504343953926634992332820282019728792003956564819949" : GoString))),
((("9850501549098619803069760025035903451269934817616361666987073351061430442874302652853566563721228910201656997576599" : GoString))),
((("42307582002575910332922579714097346549017899709713998034217522897561970639123926132812109468141778230245837569601494931472367" : GoString))),
((("6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151" : GoString)))) : Slice<GoString>));
var _composites : Slice<GoString> = ((new Slice<GoString>(
((("0" : GoString))),
((("1" : GoString))),
((("21284175091214687912771199898307297748211672914763848041968395774954376176754" : GoString))),
((("6084766654921918907427900243509372380954290099172559290432744450051395395951" : GoString))),
((("84594350493221918389213352992032324280367711247940675652888030554255915464401" : GoString))),
((("82793403787388584738507275144194252681" : GoString))),
((("1195068768795265792518361315725116351898245581" : GoString))),
"\n     80383745745363949125707961434194210813883768828755814583748891752229\n      74273765333652186502336163960045457915042023603208766569966760987284\n       0439654082329287387918508691668573282677617710293896977394701670823\n        0428687109997439976544144845341155872450633409279022275296229414984\n         2306881685404326457534018329786111298960644845216191652872597534901",
((("989" : GoString))),
((("3239" : GoString))),
((("5777" : GoString))),
((("10877" : GoString))),
((("27971" : GoString))),
((("29681" : GoString))),
((("30739" : GoString))),
((("31631" : GoString))),
((("39059" : GoString))),
((("72389" : GoString))),
((("73919" : GoString))),
((("75077" : GoString))),
((("100127" : GoString))),
((("113573" : GoString))),
((("125249" : GoString))),
((("137549" : GoString))),
((("137801" : GoString))),
((("153931" : GoString))),
((("155819" : GoString))),
((("161027" : GoString))),
((("162133" : GoString))),
((("189419" : GoString))),
((("218321" : GoString))),
((("231703" : GoString))),
((("249331" : GoString))),
((("370229" : GoString))),
((("429479" : GoString))),
((("430127" : GoString))),
((("459191" : GoString))),
((("473891" : GoString))),
((("480689" : GoString))),
((("600059" : GoString))),
((("621781" : GoString))),
((("632249" : GoString))),
((("635627" : GoString))),
((("3673744903" : GoString))),
((("3281593591" : GoString))),
((("2385076987" : GoString))),
((("2738053141" : GoString))),
((("2009621503" : GoString))),
((("1502682721" : GoString))),
((("255866131" : GoString))),
((("117987841" : GoString))),
((("587861" : GoString))),
((("6368689" : GoString))),
((("8725753" : GoString))),
((("80579735209" : GoString))),
((("105919633" : GoString)))) : Slice<GoString>));
var _ratCmpTests : Slice<T__struct_55> = ((new Slice<T__struct_55>(((new T__struct_55(((("0" : GoString))), ((("0/1" : GoString))), ((0 : GoInt))) : T__struct_55)), ((new T__struct_55(((("1/1" : GoString))), ((("1" : GoString))), ((0 : GoInt))) : T__struct_55)), ((new T__struct_55(((("-1" : GoString))), ((("-2/2" : GoString))), ((0 : GoInt))) : T__struct_55)), ((new T__struct_55(((("1" : GoString))), ((("0" : GoString))), ((1 : GoInt))) : T__struct_55)), ((new T__struct_55(((("0/1" : GoString))), ((("1/1" : GoString))), ((-1 : GoInt))) : T__struct_55)), ((new T__struct_55(((("-5/1434770811533343057144" : GoString))), ((("-5/1434770811533343057145" : GoString))), ((-1 : GoInt))) : T__struct_55)), ((new T__struct_55(((("49832350382626108453/8964749413" : GoString))), ((("49832350382626108454/8964749413" : GoString))), ((-1 : GoInt))) : T__struct_55)), ((new T__struct_55(((("-37414950961700930/7204075375675961" : GoString))), ((("37414950961700930/7204075375675961" : GoString))), ((-1 : GoInt))) : T__struct_55)), ((new T__struct_55(((("37414950961700930/7204075375675961" : GoString))), ((("74829901923401860/14408150751351922" : GoString))), ((0 : GoInt))) : T__struct_55))) : Slice<T__struct_55>));
var _ratBinTests : Slice<T__struct_56> = ((new Slice<T__struct_56>(
((new T__struct_56(((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString)))) : T__struct_56)),
((new T__struct_56(((("0" : GoString))), ((("1" : GoString))), ((("1" : GoString))), ((("0" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-1" : GoString))), ((("0" : GoString))), ((("-1" : GoString))), ((("0" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-1" : GoString))), ((("1" : GoString))), ((("0" : GoString))), ((("-1" : GoString)))) : T__struct_56)),
((new T__struct_56(((("1" : GoString))), ((("1" : GoString))), ((("2" : GoString))), ((("1" : GoString)))) : T__struct_56)),
((new T__struct_56(((("1/2" : GoString))), ((("1/2" : GoString))), ((("1" : GoString))), ((("1/4" : GoString)))) : T__struct_56)),
((new T__struct_56(((("1/4" : GoString))), ((("1/3" : GoString))), ((("7/12" : GoString))), ((("1/12" : GoString)))) : T__struct_56)),
((new T__struct_56(((("2/5" : GoString))), ((("-14/3" : GoString))), ((("-64/15" : GoString))), ((("-28/15" : GoString)))) : T__struct_56)),
((new T__struct_56(((("4707/49292519774798173060" : GoString))), ((("-3367/70976135186689855734" : GoString))), ((("84058377121001851123459/1749296273614329067191168098769082663020" : GoString))), ((("-1760941/388732505247628681598037355282018369560" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-61204110018146728334/3" : GoString))), ((("-31052192278051565633/2" : GoString))), ((("-215564796870448153567/6" : GoString))), ((("950260896245257153059642991192710872711/3" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-854857841473707320655/4237645934602118692642972629634714039" : GoString))), ((("-18/31750379913563777419" : GoString))), ((("-27/133467566250814981" : GoString))), ((("15387441146526731771790/134546868362786310073779084329032722548987800600710485341" : GoString)))) : T__struct_56)),
((new T__struct_56(((("618575745270541348005638912139/19198433543745179392300736" : GoString))), ((("-19948846211000086/637313996471" : GoString))), ((("27674141753240653/30123979153216" : GoString))), ((("-6169936206128396568797607742807090270137721977/6117715203873571641674006593837351328" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-3/26206484091896184128" : GoString))), ((("5/2848423294177090248" : GoString))), ((("15310893822118706237/9330894968229805033368778458685147968" : GoString))), ((("-5/24882386581946146755650075889827061248" : GoString)))) : T__struct_56)),
((new T__struct_56(((("26946729/330400702820" : GoString))), ((("41563965/225583428284" : GoString))), ((("1238218672302860271/4658307703098666660055" : GoString))), ((("224002580204097/14906584649915733312176" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-8259900599013409474/7" : GoString))), ((("-84829337473700364773/56707961321161574960" : GoString))), ((("-468402123685491748914621885145127724451/396955729248131024720" : GoString))), ((("350340947706464153265156004876107029701/198477864624065512360" : GoString)))) : T__struct_56)),
((new T__struct_56(((("575775209696864/1320203974639986246357" : GoString))), ((("29/712593081308" : GoString))), ((("410331716733912717985762465/940768218243776489278275419794956" : GoString))), ((("808/45524274987585732633" : GoString)))) : T__struct_56)),
((new T__struct_56(((("1786597389946320496771/2066653520653241" : GoString))), ((("6269770/1992362624741777" : GoString))), ((("3559549865190272133656109052308126637/4117523232840525481453983149257" : GoString))), ((("8967230/3296219033" : GoString)))) : T__struct_56)),
((new T__struct_56(((("-36459180403360509753/32150500941194292113930" : GoString))), ((("9381566963714/9633539" : GoString))), ((("301622077145533298008420642898530153/309723104686531919656937098270" : GoString))), ((("-3784609207827/3426986245" : GoString)))) : T__struct_56))) : Slice<T__struct_56>));
var _setFrac64Tests : Slice<T__struct_57> = ((new Slice<T__struct_57>(((new T__struct_57(((0 : GoInt64)), ((1 : GoInt64)), ((("0" : GoString)))) : T__struct_57)), ((new T__struct_57(((0 : GoInt64)), ((-1 : GoInt64)), ((("0" : GoString)))) : T__struct_57)), ((new T__struct_57(((1 : GoInt64)), ((1 : GoInt64)), ((("1" : GoString)))) : T__struct_57)), ((new T__struct_57(((-1 : GoInt64)), ((1 : GoInt64)), ((("-1" : GoString)))) : T__struct_57)), ((new T__struct_57(((1 : GoInt64)), ((-1 : GoInt64)), ((("-1" : GoString)))) : T__struct_57)), ((new T__struct_57(((-1 : GoInt64)), ((-1 : GoInt64)), ((("1" : GoString)))) : T__struct_57)), ((new T__struct_57((("-9223372036854775808" : GoInt64)), (("-9223372036854775808" : GoInt64)), ((("1" : GoString)))) : T__struct_57))) : Slice<T__struct_57>));
var _exponentTests : Slice<T__struct_59> = ((new Slice<T__struct_59>(
((new T__struct_59(((("" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("1" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((((("1" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("e0" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("E1" : GoString))), false, false, ((1 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e+10" : GoString))), false, false, ((10 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e-10" : GoString))), false, false, ((-10 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e123456789a" : GoString))), false, false, ((123456789 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((((("a" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("p" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((((("p" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("P+100" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((((("P" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("p0" : GoString))), true, false, ((0 : GoInt64)), ((2 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("P-123" : GoString))), true, false, ((-123 : GoInt64)), ((2 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("p+0a" : GoString))), true, false, ((0 : GoInt64)), ((2 : GoInt)), ((null : stdgo.Error)), ((((("a" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("p+123__" : GoString))), true, false, ((123 : GoInt64)), ((2 : GoInt)), ((null : stdgo.Error)), ((((("_" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("e+1_0" : GoString))), false, true, ((10 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e-1_0" : GoString))), false, true, ((-10 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e123_456_789a" : GoString))), false, true, ((123456789 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((((("a" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("P+1_00" : GoString))), false, true, ((0 : GoInt64)), ((10 : GoInt)), ((null : stdgo.Error)), ((((("P" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("p-1_2_3" : GoString))), true, true, ((-123 : GoInt64)), ((2 : GoInt)), ((null : stdgo.Error)), ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("ef" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), _errNoDigits, ((((("f" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("e+" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("E-x" : GoString))), false, false, ((0 : GoInt64)), ((10 : GoInt)), _errNoDigits, ((((("x" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("p" : GoString))), true, false, ((0 : GoInt64)), ((2 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("P-" : GoString))), true, false, ((0 : GoInt64)), ((2 : GoInt)), _errNoDigits, ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("p+e" : GoString))), true, false, ((0 : GoInt64)), ((2 : GoInt)), _errNoDigits, ((((("e" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("e+_x" : GoString))), false, true, ((0 : GoInt64)), ((10 : GoInt)), _errNoDigits, ((((("x" : GoString))).code : GoRune))) : T__struct_59)),
((new T__struct_59(((("e0_" : GoString))), false, true, ((0 : GoInt64)), ((10 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e_0" : GoString))), false, true, ((0 : GoInt64)), ((10 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_59)),
((new T__struct_59(((("e-1_2__3" : GoString))), false, true, ((-123 : GoInt64)), ((10 : GoInt)), _errInvalSep, ((0 : GoInt32))) : T__struct_59))) : Slice<T__struct_59>));
var _setStringTests : Slice<StringTest> = ((new Slice<StringTest>(
((({ _in : ((("1e" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("1e" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("1.e" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("1.e" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("1e+14e-5" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("1e+14e-5" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("1e4.5" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("1e4.5" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("r" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("r" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("a/b" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("a/b" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("a.b" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("a.b" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("1/0" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("1/0" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("4/3/2" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("4/3/2" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("4/3/" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("4/3/" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("4/3." : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("4/3." : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("4/" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("4/" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("13e-9223372036854775808" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("13e-9223372036854775808" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((new StringTest(((("0" : GoString))), ((("0" : GoString))), true) : StringTest)),
((new StringTest(((("-0" : GoString))), ((("0" : GoString))), true) : StringTest)),
((new StringTest(((("1" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("-1" : GoString))), ((("-1" : GoString))), true) : StringTest)),
((new StringTest(((("1." : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("1e0" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("1.e1" : GoString))), ((("10" : GoString))), true) : StringTest)),
((new StringTest(((("-0.1" : GoString))), ((("-1/10" : GoString))), true) : StringTest)),
((new StringTest(((("-.1" : GoString))), ((("-1/10" : GoString))), true) : StringTest)),
((new StringTest(((("2/4" : GoString))), ((("1/2" : GoString))), true) : StringTest)),
((new StringTest((((".25" : GoString))), ((("1/4" : GoString))), true) : StringTest)),
((new StringTest(((("-1/5" : GoString))), ((("-1/5" : GoString))), true) : StringTest)),
((new StringTest(((("8129567.7690E14" : GoString))), ((("812956776900000000000" : GoString))), true) : StringTest)),
((new StringTest(((("78189e+4" : GoString))), ((("781890000" : GoString))), true) : StringTest)),
((new StringTest(((("553019.8935e+8" : GoString))), ((("55301989350000" : GoString))), true) : StringTest)),
((new StringTest(((("98765432109876543210987654321e-10" : GoString))), ((("98765432109876543210987654321/10000000000" : GoString))), true) : StringTest)),
((new StringTest(((("9877861857500000E-7" : GoString))), ((("3951144743/4" : GoString))), true) : StringTest)),
((new StringTest(((("2169378.417e-3" : GoString))), ((("2169378417/1000000" : GoString))), true) : StringTest)),
((new StringTest(((("884243222337379604041632732738665534" : GoString))), ((("884243222337379604041632732738665534" : GoString))), true) : StringTest)),
((new StringTest(((("53/70893980658822810696" : GoString))), ((("53/70893980658822810696" : GoString))), true) : StringTest)),
((new StringTest(((("106/141787961317645621392" : GoString))), ((("53/70893980658822810696" : GoString))), true) : StringTest)),
((new StringTest(((("204211327800791583.81095" : GoString))), ((("4084226556015831676219/20000" : GoString))), true) : StringTest)),
((new StringTest(((("0e9999999999" : GoString))), ((("0" : GoString))), true) : StringTest))) : Slice<StringTest>));
var _setStringTests2 : Slice<StringTest> = ((new Slice<StringTest>(
((({ _in : ((("4/3x" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("4/3x" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("0/-1" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("0/-1" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("-1/-1" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("-1/-1" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("10_/1" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("10_/1" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("_10/1" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("_10/1" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((({ _in : ((("1/1__0" : GoString))), _out : "", _ok : false } : StringTest)) == null ? null : (({ _in : ((("1/1__0" : GoString))), _out : "", _ok : false } : StringTest)).__copy__()),
((new StringTest(((("0b1000/3" : GoString))), ((("8/3" : GoString))), true) : StringTest)),
((new StringTest(((("0B1000/0x8" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("-010/1" : GoString))), ((("-8" : GoString))), true) : StringTest)),
((new StringTest(((("-010.0" : GoString))), ((("-10" : GoString))), true) : StringTest)),
((new StringTest(((("-0o10/1" : GoString))), ((("-8" : GoString))), true) : StringTest)),
((new StringTest(((("0x10/1" : GoString))), ((("16" : GoString))), true) : StringTest)),
((new StringTest(((("0x10/0x20" : GoString))), ((("1/2" : GoString))), true) : StringTest)),
((new StringTest(((("0010" : GoString))), ((("10" : GoString))), true) : StringTest)),
((new StringTest(((("0x10.0" : GoString))), ((("16" : GoString))), true) : StringTest)),
((new StringTest(((("0x1.8" : GoString))), ((("3/2" : GoString))), true) : StringTest)),
((new StringTest(((("0X1.8p4" : GoString))), ((("24" : GoString))), true) : StringTest)),
((new StringTest(((("0x1.1E2" : GoString))), ((("2289/2048" : GoString))), true) : StringTest)),
((new StringTest(((("0b1.1E2" : GoString))), ((("150" : GoString))), true) : StringTest)),
((new StringTest(((("0B1.1P3" : GoString))), ((("12" : GoString))), true) : StringTest)),
((new StringTest(((("0o10e-2" : GoString))), ((("2/25" : GoString))), true) : StringTest)),
((new StringTest(((("0O10p-3" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("0b_1000/3" : GoString))), ((("8/3" : GoString))), true) : StringTest)),
((new StringTest(((("0B_10_00/0x8" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("0xdead/0B1101_1110_1010_1101" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("0B1101_1110_1010_1101/0XD_E_A_D" : GoString))), ((("1" : GoString))), true) : StringTest)),
((new StringTest(((("1_000.0" : GoString))), ((("1000" : GoString))), true) : StringTest)),
((new StringTest(((("0x_10.0" : GoString))), ((("16" : GoString))), true) : StringTest)),
((new StringTest(((("0x1_0.0" : GoString))), ((("16" : GoString))), true) : StringTest)),
((new StringTest(((("0x1.8_0" : GoString))), ((("3/2" : GoString))), true) : StringTest)),
((new StringTest(((("0X1.8p0_4" : GoString))), ((("24" : GoString))), true) : StringTest)),
((new StringTest(((("0b1.1_0E2" : GoString))), ((("150" : GoString))), true) : StringTest)),
((new StringTest(((("0o1_0e-2" : GoString))), ((("2/25" : GoString))), true) : StringTest)),
((new StringTest(((("0O_10p-3" : GoString))), ((("1" : GoString))), true) : StringTest))) : Slice<StringTest>));
var _floatStringTests : Slice<T__struct_60> = ((new Slice<T__struct_60>(
((new T__struct_60(((("0" : GoString))), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_60)),
((new T__struct_60(((("0" : GoString))), ((4 : GoInt)), ((("0.0000" : GoString)))) : T__struct_60)),
((new T__struct_60(((("1" : GoString))), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_60)),
((new T__struct_60(((("1" : GoString))), ((2 : GoInt)), ((("1.00" : GoString)))) : T__struct_60)),
((new T__struct_60(((("-1" : GoString))), ((0 : GoInt)), ((("-1" : GoString)))) : T__struct_60)),
((new T__struct_60(((("0.05" : GoString))), ((1 : GoInt)), ((("0.1" : GoString)))) : T__struct_60)),
((new T__struct_60(((("-0.05" : GoString))), ((1 : GoInt)), ((("-0.1" : GoString)))) : T__struct_60)),
((new T__struct_60((((".25" : GoString))), ((2 : GoInt)), ((("0.25" : GoString)))) : T__struct_60)),
((new T__struct_60((((".25" : GoString))), ((1 : GoInt)), ((("0.3" : GoString)))) : T__struct_60)),
((new T__struct_60((((".25" : GoString))), ((3 : GoInt)), ((("0.250" : GoString)))) : T__struct_60)),
((new T__struct_60(((("-1/3" : GoString))), ((3 : GoInt)), ((("-0.333" : GoString)))) : T__struct_60)),
((new T__struct_60(((("-2/3" : GoString))), ((4 : GoInt)), ((("-0.6667" : GoString)))) : T__struct_60)),
((new T__struct_60(((("0.96" : GoString))), ((1 : GoInt)), ((("1.0" : GoString)))) : T__struct_60)),
((new T__struct_60(((("0.999" : GoString))), ((2 : GoInt)), ((("1.00" : GoString)))) : T__struct_60)),
((new T__struct_60(((("0.9" : GoString))), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_60)),
((new T__struct_60((((".25" : GoString))), ((-1 : GoInt)), ((("0" : GoString)))) : T__struct_60)),
((new T__struct_60((((".55" : GoString))), ((-1 : GoInt)), ((("1" : GoString)))) : T__struct_60))) : Slice<T__struct_60>));
var _float64inputs : Slice<GoString> = ((new Slice<GoString>(
((("5e+125" : GoString))),
((("69e+267" : GoString))),
((("999e-026" : GoString))),
((("7861e-034" : GoString))),
((("75569e-254" : GoString))),
((("928609e-261" : GoString))),
((("9210917e+080" : GoString))),
((("84863171e+114" : GoString))),
((("653777767e+273" : GoString))),
((("5232604057e-298" : GoString))),
((("27235667517e-109" : GoString))),
((("653532977297e-123" : GoString))),
((("3142213164987e-294" : GoString))),
((("46202199371337e-072" : GoString))),
((("231010996856685e-073" : GoString))),
((("9324754620109615e+212" : GoString))),
((("78459735791271921e+049" : GoString))),
((("272104041512242479e+200" : GoString))),
((("6802601037806061975e+198" : GoString))),
((("20505426358836677347e-221" : GoString))),
((("836168422905420598437e-234" : GoString))),
((("4891559871276714924261e+222" : GoString))),
((("9e-265" : GoString))),
((("85e-037" : GoString))),
((("623e+100" : GoString))),
((("3571e+263" : GoString))),
((("81661e+153" : GoString))),
((("920657e-023" : GoString))),
((("4603285e-024" : GoString))),
((("87575437e-309" : GoString))),
((("245540327e+122" : GoString))),
((("6138508175e+120" : GoString))),
((("83356057653e+193" : GoString))),
((("619534293513e+124" : GoString))),
((("2335141086879e+218" : GoString))),
((("36167929443327e-159" : GoString))),
((("609610927149051e-255" : GoString))),
((("3743626360493413e-165" : GoString))),
((("94080055902682397e-242" : GoString))),
((("899810892172646163e+283" : GoString))),
((("7120190517612959703e+120" : GoString))),
((("25188282901709339043e-252" : GoString))),
((("308984926168550152811e-052" : GoString))),
((("6372891218502368041059e+064" : GoString))),
((("5e-20" : GoString))),
((("67e+14" : GoString))),
((("985e+15" : GoString))),
((("7693e-42" : GoString))),
((("55895e-16" : GoString))),
((("996622e-44" : GoString))),
((("7038531e-32" : GoString))),
((("60419369e-46" : GoString))),
((("702990899e-20" : GoString))),
((("6930161142e-48" : GoString))),
((("25933168707e+13" : GoString))),
((("596428896559e+20" : GoString))),
((("3e-23" : GoString))),
((("57e+18" : GoString))),
((("789e-35" : GoString))),
((("2539e-18" : GoString))),
((("76173e+28" : GoString))),
((("887745e-11" : GoString))),
((("5382571e-37" : GoString))),
((("82381273e-35" : GoString))),
((("750486563e-38" : GoString))),
((("3752432815e-39" : GoString))),
((("75224575729e-45" : GoString))),
((("459926601011e+15" : GoString))),
((("0" : GoString))),
((("1" : GoString))),
((("+1" : GoString))),
((("1e23" : GoString))),
((("1E23" : GoString))),
((("100000000000000000000000" : GoString))),
((("1e-100" : GoString))),
((("123456700" : GoString))),
((("99999999999999974834176" : GoString))),
((("100000000000000000000001" : GoString))),
((("100000000000000008388608" : GoString))),
((("100000000000000016777215" : GoString))),
((("100000000000000016777216" : GoString))),
((("-1" : GoString))),
((("-0.1" : GoString))),
((("-0" : GoString))),
((("1e-20" : GoString))),
((("625e-3" : GoString))),
((("1.7976931348623157e308" : GoString))),
((("-1.7976931348623157e308" : GoString))),
((("1.7976931348623159e308" : GoString))),
((("-1.7976931348623159e308" : GoString))),
((("1.7976931348623158e308" : GoString))),
((("-1.7976931348623158e308" : GoString))),
((("1.797693134862315808e308" : GoString))),
((("-1.797693134862315808e308" : GoString))),
((("1e308" : GoString))),
((("2e308" : GoString))),
((("1e309" : GoString))),
((("1e310" : GoString))),
((("-1e310" : GoString))),
((("1e400" : GoString))),
((("-1e400" : GoString))),
((("long:1e400000" : GoString))),
((("long:-1e400000" : GoString))),
((("1e-305" : GoString))),
((("1e-306" : GoString))),
((("1e-307" : GoString))),
((("1e-308" : GoString))),
((("1e-309" : GoString))),
((("1e-310" : GoString))),
((("1e-322" : GoString))),
((("5e-324" : GoString))),
((("4e-324" : GoString))),
((("3e-324" : GoString))),
((("2e-324" : GoString))),
((("1e-350" : GoString))),
((("long:1e-400000" : GoString))),
((("-1e-350" : GoString))),
((("long:-1e-400000" : GoString))),
((("2.2250738585072012e-308" : GoString))),
((("2.2250738585072011e-308" : GoString))),
((("4.630813248087435e+307" : GoString))),
((("22.222222222222222" : GoString))),
(((("long:2." : GoString))) + stdgo.strings.Strings.repeat(((("2" : GoString))), ((4000 : GoInt)))) + ((("e+1" : GoString))),
((("1.00000000000000011102230246251565404236316680908203125" : GoString))),
((("1.00000000000000011102230246251565404236316680908203124" : GoString))),
((("1.00000000000000011102230246251565404236316680908203126" : GoString))),
(((("long:1.00000000000000011102230246251565404236316680908203125" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((10000 : GoInt)))) + ((("1" : GoString))),
((("4.940656458412465441765687928682213723651e-324" : GoString))),
((("2.470328229206232720882843964341106861825e-324" : GoString))),
((("2.470328302827751011111470718709768633275e-324" : GoString))),
((("2.225073858507201136057409796709131975935e-308" : GoString))),
((("1152921504606846975" : GoString))),
((("-1152921504606846975" : GoString))),
((("1152921504606846977" : GoString))),
((("-1152921504606846977" : GoString))),
((("1/3" : GoString)))) : Slice<GoString>));
var _ratNums : Slice<GoString> = ((new Slice<GoString>(((("-141592653589793238462643383279502884197169399375105820974944592307816406286" : GoString))), ((("-1415926535897932384626433832795028841971" : GoString))), ((("-141592653589793" : GoString))), ((("-1" : GoString))), ((("0" : GoString))), ((("1" : GoString))), ((("141592653589793" : GoString))), ((("1415926535897932384626433832795028841971" : GoString))), ((("141592653589793238462643383279502884197169399375105820974944592307816406286" : GoString)))) : Slice<GoString>));
var _ratDenoms : Slice<GoString> = ((new Slice<GoString>(((("1" : GoString))), ((("718281828459045" : GoString))), ((("7182818284590452353602874713526624977572" : GoString))), ((("718281828459045235360287471352662497757247093699959574966967627724076630353" : GoString)))) : Slice<GoString>));
var _sink : GoString = (("" : GoString));
var _6 : Error = ((new ErrNaN() : ErrNaN));
var _floatZero : Float_ = new Float_();
var _7 : stdgo.fmt.Fmt.Scanner = ((((null : Ref<Float_>)) : Float_));
var _zero_ : GoFloat64 = ((0 : GoFloat64));
var _8 : stdgo.fmt.Fmt.Formatter = _floatZero;
var _9 : stdgo.fmt.Fmt.Formatter = _intOne;
var _10 : stdgo.fmt.Fmt.Scanner = _intOne;
var _natPool : stdgo.sync.Sync.Pool = new stdgo.sync.Sync.Pool();
var _cacheBase10 : T__struct_52 = new T__struct_52();
var _ratZero : Rat = new Rat();
var _11 : stdgo.fmt.Fmt.Scanner = _ratZero;
var _threeOnce : T__struct_62 = new T__struct_62();
@:structInit class T_argVV {
    public var _z : T_nat = new T_nat();
    public var _x : T_nat = new T_nat();
    public var _y : T_nat = new T_nat();
    public var _c : Word = new Word();
    public function new(?_z:T_nat, ?_x:T_nat, ?_y:T_nat, ?_c:Word) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_c != null) this._c = _c;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argVV(_z, _x, _y, _c);
    }
}
@:structInit class T_argVW {
    public var _z : T_nat = new T_nat();
    public var _x : T_nat = new T_nat();
    public var _y : Word = new Word();
    public var _c : Word = new Word();
    public function new(?_z:T_nat, ?_x:T_nat, ?_y:Word, ?_c:Word) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_c != null) this._c = _c;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argVW(_z, _x, _y, _c);
    }
}
@:structInit class T_argVU {
    public var _d : Slice<Word> = ((null : Slice<Word>));
    public var _l : GoUInt = ((0 : GoUInt));
    public var _xp : GoUInt = ((0 : GoUInt));
    public var _zp : GoUInt = ((0 : GoUInt));
    public var _s : GoUInt = ((0 : GoUInt));
    public var _r : Slice<Word> = ((null : Slice<Word>));
    public var _c : Word = new Word();
    public var _m : GoString = (("" : GoString));
    public function new(?_d:Slice<Word>, ?_l:GoUInt, ?_xp:GoUInt, ?_zp:GoUInt, ?_s:GoUInt, ?_r:Slice<Word>, ?_c:Word, ?_m:GoString) {
        if (_d != null) this._d = _d;
        if (_l != null) this._l = _l;
        if (_xp != null) this._xp = _xp;
        if (_zp != null) this._zp = _zp;
        if (_s != null) this._s = _s;
        if (_r != null) this._r = _r;
        if (_c != null) this._c = _c;
        if (_m != null) this._m = _m;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argVU(_d, _l, _xp, _zp, _s, _r, _c, _m);
    }
}
@:structInit class T_argVWW {
    public var _z : T_nat = new T_nat();
    public var _x : T_nat = new T_nat();
    public var _y : Word = new Word();
    public var _r : Word = new Word();
    public var _c : Word = new Word();
    public function new(?_z:T_nat, ?_x:T_nat, ?_y:Word, ?_r:Word, ?_c:Word) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_r != null) this._r = _r;
        if (_c != null) this._c = _c;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argVWW(_z, _x, _y, _r, _c);
    }
}
@:structInit class T_argWVW {
    public var _z : T_nat = new T_nat();
    public var _xn : Word = new Word();
    public var _x : T_nat = new T_nat();
    public var _y : Word = new Word();
    public var _r : Word = new Word();
    public function new(?_z:T_nat, ?_xn:Word, ?_x:T_nat, ?_y:Word, ?_r:Word) {
        if (_z != null) this._z = _z;
        if (_xn != null) this._xn = _xn;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_r != null) this._r = _r;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argWVW(_z, _xn, _x, _y, _r);
    }
}
@:structInit @:using(stdgo.math.big.Big.T_decimal_static_extension) class T_decimal {
    @:keep
    public function _roundDown(_n:GoInt):Void {
        var _x = this;
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        _x._mant = ((_x._mant.__slice__(0, _n) : Slice<GoUInt8>));
        _trim(_x);
    }
    @:keep
    public function _roundUp(_n:GoInt):Void {
        var _x = this;
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        while ((_n > ((0 : GoInt))) && ((_x._mant != null ? _x._mant[_n - ((1 : GoInt))] : ((0 : GoUInt8))) >= ((((("9" : GoString))).code : GoRune)))) {
            _n--;
        };
        if (_n == ((0 : GoInt))) {
            if (_x._mant != null) _x._mant[((0 : GoInt))] = ((((("1" : GoString))).code : GoRune));
            _x._mant = ((_x._mant.__slice__(0, ((1 : GoInt))) : Slice<GoUInt8>));
            _x._exp++;
            return;
        };
        if (_x._mant != null) _x._mant[_n - ((1 : GoInt))]++;
        _x._mant = ((_x._mant.__slice__(0, _n) : Slice<GoUInt8>));
    }
    @:keep
    public function _round(_n:GoInt):Void {
        var _x = this;
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        if (_shouldRoundUp(_x, _n)) {
            _x._roundUp(_n);
        } else {
            _x._roundDown(_n);
        };
    }
    @:keep
    public function toString():GoString {
        var _x = this;
        _x;
        if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((("0" : GoString)));
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        if (_x._exp <= ((0 : GoInt))) {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__((((((2 : GoInt)) + (-_x._exp)) + (_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(...((("0." : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0." : GoString))).__toArray__()));
            _buf = _appendZeros(_buf, -_x._exp);
            _buf = (_buf != null ? _buf.__append__(..._x._mant.__toArray__()) : new Slice<GoUInt8>(..._x._mant.__toArray__()));
        } else if (_x._exp < (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((((1 : GoInt)) + (_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(...((_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>)).__toArray__()));
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            _buf = (_buf != null ? _buf.__append__(...((_x._mant.__slice__(_x._exp) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_x._mant.__slice__(_x._exp) : Slice<GoUInt8>)).__toArray__()));
        } else {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((_x._exp : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(..._x._mant.__toArray__()) : new Slice<GoUInt8>(..._x._mant.__toArray__()));
            _buf = _appendZeros(_buf, _x._exp - (_x._mant != null ? _x._mant.length : ((0 : GoInt))));
        };
        return ((_buf : GoString));
    }
    @:keep
    public function _init(_m:T_nat, _shift:GoInt):Void {
        var _x = this;
        _x;
        if ((_m != null ? _m.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _x._mant = ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>));
            _x._exp = ((0 : GoInt));
            return;
        };
        if (_shift < ((0 : GoInt))) {
            var _ntz:GoUInt = _m._trailingZeroBits();
            var _s:GoUInt = ((-_shift : GoUInt));
            if (_s >= _ntz) {
                _s = _ntz;
            };
            _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _s) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _s).__copy__());
            _shift = _shift + (((_s : GoInt)));
        };
        if (_shift > ((0 : GoInt))) {
            _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), ((_shift : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), ((_shift : GoUInt))).__copy__());
            _shift = ((0 : GoInt));
        };
        var _s:Slice<GoUInt8> = _m._utoa(((10 : GoInt)));
        var _n:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        _x._exp = _n;
        while ((_n > ((0 : GoInt))) && ((_s != null ? _s[_n - ((1 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) {
            _n--;
        };
        _x._mant = (((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>)) != null ? ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>)).__append__(...((_s.__slice__(0, _n) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_s.__slice__(0, _n) : Slice<GoUInt8>)).__toArray__()));
        if (_shift < ((0 : GoInt))) {
            while (_shift < ((-28 : GoInt))) {
                _shr(_x, ((28 : GoUInt)));
                _shift = _shift + (((28 : GoInt)));
            };
            _shr(_x, ((-_shift : GoUInt)));
        };
    }
    @:keep
    public function _at(_i:GoInt):GoByte {
        var _d = this;
        _d;
        if ((((0 : GoInt)) <= _i) && (_i < (_d._mant != null ? _d._mant.length : ((0 : GoInt))))) {
            return (_d._mant != null ? _d._mant[_i] : ((0 : GoUInt8)));
        };
        return ((((("0" : GoString))).code : GoRune));
    }
    public var _mant : Slice<GoUInt8> = ((null : Slice<GoUInt8>));
    public var _exp : GoInt = ((0 : GoInt));
    public function new(?_mant:Slice<GoUInt8>, ?_exp:GoInt) {
        if (_mant != null) this._mant = _mant;
        if (_exp != null) this._exp = _exp;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_decimal(_mant, _exp);
    }
}
@:structInit @:using(stdgo.math.big.Big.Float__static_extension) class Float_ {
    @:keep
    public function _sqrtInverse(_x:Float_):Void {
        var _z = this;
        _z;
        var _u:Ref<Float_> = _newFloat(_z._prec);
        var _v:Ref<Float_> = _newFloat(_z._prec);
        var _three:Ref<Float_> = _three();
        var _ng:Ref<Float_> -> Ref<Float_> = function(_t:Float_):Float_ {
            _u._prec = _t._prec;
            _v._prec = _t._prec;
            _u.mul(_t, _t);
            _u.mul(_x, _u);
            _v.sub(_three, _u);
            _u.mul(_t, _v);
            _u._exp--;
            return _t.set(_u);
        };
        var __tmp__ = _x.float64(), _xf:GoFloat64 = __tmp__._0, _0:Accuracy = __tmp__._1;
        var _sqi:Ref<Float_> = _newFloat(_z._prec);
        _sqi.setFloat64(((1 : GoFloat64)) / stdgo.math.Math.sqrt(_xf));
        {
            var _prec:GoUInt32 = _z._prec + ((32 : GoUInt32));
            while (_sqi._prec < _prec) {
                _sqi._prec = _sqi._prec * (((2 : GoUInt32)));
                _sqi = _ng(_sqi);
            };
        };
        _z.mul(_x, _sqi);
    }
    @:keep
    public function sqrt(_x:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _x._prec;
        };
        if (_x.sign() == ((-1 : GoInt))) {
            throw Go.toInterface(((new ErrNaN(((("square root of negative operand" : GoString)))) : ErrNaN)));
        };
        if (_x._form != ((1 : GoUInt8))) {
            _z._acc = ((0 : GoInt8));
            _z._form = _x._form;
            _z._neg = _x._neg;
            return _z;
        };
        var _prec:GoUInt32 = _z._prec;
        var _b:GoInt = _x.mantExp(_z);
        _z._prec = _prec;
        if (_b % ((2 : GoInt)) == ((0 : GoInt))) {} else if (_b % ((2 : GoInt)) == ((1 : GoInt))) {
            _z._exp++;
        } else if (_b % ((2 : GoInt)) == ((-1 : GoInt))) {
            _z._exp--;
        };
        _z._sqrtInverse(_z);
        return _z.setMantExp(_z, _b / ((2 : GoInt)));
    }
    @:keep
    public function format(_s:stdgo.fmt.Fmt.State, _format:GoRune):Void {
        var _x = this;
        _x;
        var __tmp__ = _s.precision(), _prec:GoInt = __tmp__._0, _hasPrec:Bool = __tmp__._1;
        if (!_hasPrec) {
            _prec = ((6 : GoInt));
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _format == ((((("e" : GoString))).code : GoRune)) || _format == ((((("E" : GoString))).code : GoRune)) || _format == ((((("f" : GoString))).code : GoRune)) || _format == ((((("b" : GoString))).code : GoRune)) || _format == ((((("p" : GoString))).code : GoRune)) || _format == ((((("x" : GoString))).code : GoRune)))) {
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _format == ((((("F" : GoString))).code : GoRune)))) {
                    _format = ((((("f" : GoString))).code : GoRune));
                    break;
                    break;
                } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _format == ((((("v" : GoString))).code : GoRune)))) {
                    _format = ((((("g" : GoString))).code : GoRune));
                    @:fallthrough {
                        __switchIndex__ = 3;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _format == ((((("g" : GoString))).code : GoRune)) || _format == ((((("G" : GoString))).code : GoRune)))) {
                    if (!_hasPrec) {
                        _prec = ((-1 : GoInt));
                    };
                    break;
                    break;
                } else {
                    stdgo.fmt.Fmt.fprintf(_s, ((("%%!%c(*big.Float=%s)" : GoString))), Go.toInterface(_format), Go.toInterface(((_x.toString() : GoString))));
                    return;
                    break;
                };
                break;
            };
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        _buf = _x.append(_buf, ((_format : GoByte)), _prec);
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _buf = ((((("?" : GoString))) : Slice<GoByte>));
        };
        var _sign:GoString = (("" : GoString));
        if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))) {
            _sign = ((("-" : GoString)));
            _buf = ((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        } else if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("+" : GoString))).code : GoRune))) {
            _sign = ((("+" : GoString)));
            if (_s.flag((((((" " : GoString))).code : GoRune)))) {
                _sign = (((" " : GoString)));
            };
            _buf = ((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        } else if (_s.flag(((((("+" : GoString))).code : GoRune)))) {
            _sign = ((("+" : GoString)));
        } else if (_s.flag((((((" " : GoString))).code : GoRune)))) {
            _sign = (((" " : GoString)));
        };
        var _padding:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _hasWidth:Bool = __tmp__._1;
            if (_hasWidth && (_width > ((_sign != null ? _sign.length : ((0 : GoInt))) + (_buf != null ? _buf.length : ((0 : GoInt)))))) {
                _padding = (_width - (_sign != null ? _sign.length : ((0 : GoInt)))) - (_buf != null ? _buf.length : ((0 : GoInt)));
            };
        };
        if (_s.flag(((((("0" : GoString))).code : GoRune))) && !_x.isInf()) {
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _writeMultiple(_s, ((("0" : GoString))), _padding);
            _s.write(_buf);
        } else if (_s.flag(((((("-" : GoString))).code : GoRune)))) {
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _s.write(_buf);
            _writeMultiple(_s, (((" " : GoString))), _padding);
        } else {
            _writeMultiple(_s, (((" " : GoString))), _padding);
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _s.write(_buf);
        };
    }
    @:keep
    public function _fmtP(_buf:Slice<GoByte>):Slice<GoByte> {
        var _x = this;
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            return (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        var _i:GoInt = ((0 : GoInt));
        while ((_i < (_m != null ? _m.length : ((0 : GoInt)))) && ((_m != null ? _m[_i] : new Word()) == ((0 : GoUInt)))) {
            _i++;
        };
        _m = (((_m.__slice__(_i) : T_nat)) == null ? null : ((_m.__slice__(_i) : T_nat)).__copy__());
        _buf = (_buf != null ? _buf.__append__(...((("0x." : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x." : GoString))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(...stdgo.bytes.Bytes.trimRight(_m._utoa(((16 : GoInt))), ((("0" : GoString)))).__toArray__()) : new Slice<GoUInt8>(...stdgo.bytes.Bytes.trimRight(_m._utoa(((16 : GoInt))), ((("0" : GoString)))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        if (_x._exp >= ((0 : GoInt32))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, ((_x._exp : GoInt64)), ((10 : GoInt)));
    }
    @:keep
    public function _fmtX(_buf:Slice<GoByte>, _prec:GoInt):Slice<GoByte> {
        var _x = this;
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            _buf = (_buf != null ? _buf.__append__(...((("0x0" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x0" : GoString))).__toArray__()));
            if (_prec > ((0 : GoInt))) {
                _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _prec, _i++, {
                        _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                    });
                };
            };
            _buf = (_buf != null ? _buf.__append__(...((("p+00" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("p+00" : GoString))).__toArray__()));
            return _buf;
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _n:GoUInt = ((0 : GoUInt));
        if (_prec < ((0 : GoInt))) {
            _n = ((1 : GoUInt)) + ((((_x.minPrec() - ((1 : GoUInt))) + ((3 : GoUInt))) / ((4 : GoUInt))) * ((4 : GoUInt)));
        } else {
            _n = ((1 : GoUInt)) + (((4 : GoUInt)) * ((_prec : GoUInt)));
        };
        _x = new Float_().setPrec(_n).setMode(_x._mode).set(_x);
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _w:GoUInt = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt));
            if (_w < _n) {
                _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), _n - _w) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), _n - _w).__copy__());
            } else if (_w > _n) {
                _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _w - _n) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _w - _n).__copy__());
            };
        };
        var _exp64:GoInt64 = ((_x._exp : GoInt64)) - ((1 : GoInt64));
        var _hm:Slice<GoUInt8> = _m._utoa(((16 : GoInt)));
        if (false && ((_hm != null ? _hm[((0 : GoInt))] : ((0 : GoUInt8))) != ((((("1" : GoString))).code : GoRune)))) {
            throw Go.toInterface(((("incorrect mantissa: " : GoString))) + ((_hm : GoString)));
        };
        _buf = (_buf != null ? _buf.__append__(...((("0x1" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x1" : GoString))).__toArray__()));
        if ((_hm != null ? _hm.length : ((0 : GoInt))) > ((1 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            _buf = (_buf != null ? _buf.__append__(...((_hm.__slice__(((1 : GoInt))) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_hm.__slice__(((1 : GoInt))) : Slice<GoUInt8>)).__toArray__()));
        };
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        if (_exp64 >= ((0 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        } else {
            _exp64 = -_exp64;
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        if (_exp64 < ((10 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _exp64, ((10 : GoInt)));
    }
    @:keep
    public function _fmtB(_buf:Slice<GoByte>):Slice<GoByte> {
        var _x = this;
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            return (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _w:GoUInt32 = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt32)) * ((32 : GoUInt32));
            if (_w < _x._prec) {
                _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), (((_x._prec - _w) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), (((_x._prec - _w) : GoUInt))).__copy__());
            } else if (_w > _x._prec) {
                _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), (((_w - _x._prec) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), (((_w - _x._prec) : GoUInt))).__copy__());
            };
        };
        _buf = (_buf != null ? _buf.__append__(..._m._utoa(((10 : GoInt))).__toArray__()) : new Slice<GoUInt8>(..._m._utoa(((10 : GoInt))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        var _e:GoInt64 = ((_x._exp : GoInt64)) - ((_x._prec : GoInt64));
        if (_e >= ((0 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _e, ((10 : GoInt)));
    }
    @:keep
    public function append(_buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt):Slice<GoByte> {
        var _x = this;
        _x;
        if (_x._neg) {
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        if (_x._form == ((2 : GoUInt8))) {
            if (!_x._neg) {
                _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
            };
            return (_buf != null ? _buf.__append__(...((("Inf" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("Inf" : GoString))).__toArray__()));
        };
        if (_fmt == ((((("b" : GoString))).code : GoRune))) {
            return _x._fmtB(_buf);
        } else if (_fmt == ((((("p" : GoString))).code : GoRune))) {
            return _x._fmtP(_buf);
        } else if (_fmt == ((((("x" : GoString))).code : GoRune))) {
            return _x._fmtX(_buf, _prec);
        };
        var _d:T_decimal = new T_decimal();
        if (_x._form == ((1 : GoUInt8))) {
            _d._init((_x._mant == null ? null : _x._mant.__copy__()), ((_x._exp : GoInt)) - _x._mant._bitLen());
        };
        var _shortest:Bool = false;
        if (_prec < ((0 : GoInt))) {
            _shortest = true;
            _roundShortest(_d, _x);
            if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt))) - ((1 : GoInt));
            } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
                _prec = _max((_d._mant != null ? _d._mant.length : ((0 : GoInt))) - _d._exp, ((0 : GoInt)));
            } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
        } else {
            if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
                _d._round(((1 : GoInt)) + _prec);
            } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
                _d._round(_d._exp + _prec);
            } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
                if (_prec == ((0 : GoInt))) {
                    _prec = ((1 : GoInt));
                };
                _d._round(_prec);
            };
        };
        if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
            return _fmtE(_buf, _fmt, _prec, (_d == null ? null : _d.__copy__()));
        } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
            return _fmtF(_buf, _prec, (_d == null ? null : _d.__copy__()));
        } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
            var _eprec:GoInt = _prec;
            if ((_eprec > (_d._mant != null ? _d._mant.length : ((0 : GoInt)))) && ((_d._mant != null ? _d._mant.length : ((0 : GoInt))) >= _d._exp)) {
                _eprec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
            if (_shortest) {
                _eprec = ((6 : GoInt));
            };
            var _exp:GoInt = _d._exp - ((1 : GoInt));
            if ((_exp < ((-4 : GoInt))) || (_exp >= _eprec)) {
                if (_prec > (_d._mant != null ? _d._mant.length : ((0 : GoInt)))) {
                    _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
                };
                return _fmtE(_buf, (_fmt + ((((("e" : GoString))).code : GoRune))) - ((((("g" : GoString))).code : GoRune)), _prec - ((1 : GoInt)), (_d == null ? null : _d.__copy__()));
            };
            if (_prec > _d._exp) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
            return _fmtF(_buf, _max(_prec - _d._exp, ((0 : GoInt))), (_d == null ? null : _d.__copy__()));
        };
        if (_x._neg) {
            _buf = ((_buf.__slice__(0, (_buf != null ? _buf.length : ((0 : GoInt))) - ((1 : GoInt))) : Slice<GoUInt8>));
        };
        return (_buf != null ? _buf.__append__(((((("%" : GoString))).code : GoRune)), _fmt) : new Slice<GoUInt8>(((((("%" : GoString))).code : GoRune)), _fmt));
    }
    @:keep
    public function toString():GoString {
        var _x = this;
        _x;
        return _x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)));
    }
    @:keep
    public function text(_format:GoByte, _prec:GoInt):GoString {
        var _x = this;
        _x;
        var _cap:GoInt = ((10 : GoInt));
        if (_prec > ((0 : GoInt))) {
            _cap = _cap + (_prec);
        };
        return ((_x.append(new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((_cap : GoInt)).toBasic()), _format, _prec) : GoString));
    }
    @:keep
    public function unmarshalText(_text:Slice<GoByte>):Error {
        var _z = this;
        _z;
        var __tmp__ = _z.parse(((_text : GoString)), ((0 : GoInt))), _0:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if (_err != null) {
            _err = stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Float (%v)" : GoString))), Go.toInterface(_text), Go.toInterface(_err));
        };
        return _err;
    }
    @:keep
    public function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x == null) {
            return { _0 : ((((("<nil>" : GoString))) : Slice<GoByte>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        return { _0 : _x.append(_buf, ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt))), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function gobDecode(_buf:Slice<GoByte>):Error {
        var _z = this;
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Float_() : Float_));
                _z._prec = __tmp__._prec;
                _z._mode = __tmp__._mode;
                _z._acc = __tmp__._acc;
                _z._form = __tmp__._form;
                _z._neg = __tmp__._neg;
                _z._mant = __tmp__._mant;
                _z._exp = __tmp__._exp;
            };
            return ((null : stdgo.Error));
        };
        if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Float.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)))));
        };
        var _oldPrec:GoUInt32 = _z._prec;
        var _oldMode:RoundingMode = _z._mode;
        var _b:GoUInt8 = (_buf != null ? _buf[((1 : GoInt))] : ((0 : GoUInt8)));
        _z._mode = ((((_b >> ((5 : GoUnTypedInt))) & ((7 : GoUInt8))) : RoundingMode));
        _z._acc = ((((_b >> ((3 : GoUnTypedInt))) & ((3 : GoUInt8))) : Accuracy)) - ((1 : GoInt8));
        _z._form = ((((_b >> ((1 : GoUnTypedInt))) & ((3 : GoUInt8))) : T_form));
        _z._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._prec = stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((2 : GoInt))) : Slice<GoUInt8>)));
        if (_z._form == ((1 : GoUInt8))) {
            _z._exp = ((stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((6 : GoInt))) : Slice<GoUInt8>))) : GoInt32));
            _z._mant = (_z._mant._setBytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>))) == null ? null : _z._mant._setBytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>))).__copy__());
        };
        if (_oldPrec != ((0 : GoUInt32))) {
            _z._mode = _oldMode;
            _z.setPrec(((_oldPrec : GoUInt)));
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _sz:GoInt = ((6 : GoInt));
        var _n:GoInt = ((0 : GoInt));
        if (_x._form == ((1 : GoUInt8))) {
            _n = ((((_x._prec + ((31 : GoUInt32))) / ((32 : GoUInt32))) : GoInt));
            if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) < _n) {
                _n = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
            };
            _sz = _sz + (((4 : GoInt)) + (_n * ((4 : GoInt))));
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_sz : GoInt)).toBasic()) ((0 : GoUInt8))]);
        if (_buf != null) _buf[((0 : GoInt))] = ((1 : GoUInt8));
        var _b:GoUInt8 = (((((_x._mode & ((7 : GoUInt8))) : GoByte)) << ((5 : GoUnTypedInt))) | (((((_x._acc + ((1 : GoInt8))) & ((3 : GoInt8))) : GoByte)) << ((3 : GoUnTypedInt)))) | ((((_x._form & ((3 : GoUInt8))) : GoByte)) << ((1 : GoUnTypedInt)));
        if (_x._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[((1 : GoInt))] = _b;
        stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(((2 : GoInt))) : Slice<GoUInt8>)), _x._prec);
        if (_x._form == ((1 : GoUInt8))) {
            stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(((6 : GoInt))) : Slice<GoUInt8>)), ((_x._exp : GoUInt32)));
            ((_x._mant.__slice__((_x._mant != null ? _x._mant.length : ((0 : GoInt))) - _n) : T_nat))._bytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>)));
        };
        return { _0 : _buf, _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var _z = this;
        _z;
        _s.skipSpace();
        var __tmp__ = _z._scan(((new T_byteReader(_s) : T_byteReader)), ((0 : GoInt))), _0:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        return _err;
    }
    @:keep
    public function parse(_s:GoString, _base:GoInt):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        var _z = this;
        _z;
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        if (((_s != null ? _s.length : ((0 : GoInt))) == ((3 : GoInt))) && ((_s == ((("Inf" : GoString)))) || (_s == ((("inf" : GoString)))))) {
            _f = _z.setInf(false);
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((((_s != null ? _s.length : ((0 : GoInt))) == ((4 : GoInt))) && (((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("+" : GoString))).code : GoRune))) || ((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))))) && ((((_s.__slice__(((1 : GoInt))) : GoString)) == ((("Inf" : GoString)))) || (((_s.__slice__(((1 : GoInt))) : GoString)) == ((("inf" : GoString)))))) {
            _f = _z.setInf((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_s);
        {
            {
                var __tmp__ = _z._scan(_r, _base);
                _f = __tmp__._0;
                _b = __tmp__._1;
                _err = __tmp__._2;
            };
            if (_err != null) {
                return { _0 : _f, _1 : _b, _2 : _err };
            };
        };
        {
            var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err2:stdgo.Error = __tmp__._1;
            if (_err2 == null) {
                _err = stdgo.fmt.Fmt.errorf(((("expected end of string, found %q" : GoString))), Go.toInterface(_ch));
            } else if (_err2 != stdgo.io.Io.eof) {
                _err = _err2;
            };
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    @:keep
    public function _pow5(_n:GoUInt64):Float_ {
        var _z = this;
        _z;
        {};
        if (_n <= ((27 : GoUInt64))) {
            return _z.setUint64((_pow5tab != null ? _pow5tab[_n] : ((0 : GoUInt64))));
        };
        _z.setUint64((_pow5tab != null ? _pow5tab[((27 : GoUInt64))] : ((0 : GoUInt64))));
        _n = _n - (((27 : GoUInt64)));
        var _f:Ref<Float_> = new Float_().setPrec(_z.prec() + ((64 : GoUInt))).setUint64(((5 : GoUInt64)));
        while (_n > ((0 : GoUInt64))) {
            if ((_n & ((1 : GoUInt64))) != ((0 : GoUInt64))) {
                _z.mul(_z, _f);
            };
            _f.mul(_f, _f);
            _n = _n >> (((1 : GoUnTypedInt)));
        };
        return _z;
    }
    @:keep
    public function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        var _z = this;
        _z;
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        var _prec:GoUInt32 = _z._prec;
        if (_prec == ((0 : GoUInt32))) {
            _prec = ((64 : GoUInt32));
        };
        _z._form = ((0 : GoUInt8));
        {
            var __tmp__ = _scanSign(_r);
            _z._neg = __tmp__._0;
            _err = __tmp__._1;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _fcount:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _z._mant._scan(_r, _base, true);
            _z._mant = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _b = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp:GoInt64 = ((0 : GoInt64));
        var _ebase:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _scanExponent(_r, true, _base == ((0 : GoInt)));
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((_z._mant != null ? _z._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._prec = _prec;
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _f = _z;
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp2:GoInt64 = ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__()));
        var _exp5:GoInt64 = ((((0 : GoInt64)) : GoInt64));
        if (_fcount < ((0 : GoInt))) {
            var _d:GoInt64 = ((_fcount : GoInt64));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _b == ((10 : GoInt)))) {
                        _exp5 = _d;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _b == ((2 : GoInt)))) {
                        _exp2 = _exp2 + (_d);
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _b == ((8 : GoInt)))) {
                        _exp2 = _exp2 + (_d * ((3 : GoInt64)));
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _b == ((16 : GoInt)))) {
                        _exp2 = _exp2 + (_d * ((4 : GoInt64)));
                        break;
                        break;
                    } else {
                        throw Go.toInterface(((("unexpected mantissa base" : GoString))));
                        break;
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ebase == ((10 : GoInt)))) {
                    _exp5 = _exp5 + (_exp);
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ebase == ((2 : GoInt)))) {
                    _exp2 = _exp2 + (_exp);
                    break;
                    break;
                } else {
                    throw Go.toInterface(((("unexpected exponent base" : GoString))));
                    break;
                };
                break;
            };
        };
        if ((((-2147483648 : GoInt64)) <= _exp2) && (_exp2 <= ((2147483647 : GoInt64)))) {
            _z._prec = _prec;
            _z._form = ((1 : GoUInt8));
            _z._exp = ((_exp2 : GoInt32));
            _f = _z;
        } else {
            _err = stdgo.fmt.Fmt.errorf(((("exponent overflow" : GoString))));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if (_exp5 == ((0 : GoInt64))) {
            _z._round(((0 : GoUInt)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _p:Ref<Float_> = new Float_().setPrec(_z.prec() + ((64 : GoUInt)));
        if (_exp5 < ((0 : GoInt64))) {
            _z.quo(_z, _p._pow5(((-_exp5 : GoUInt64))));
        } else {
            _z.mul(_z, _p._pow5(((_exp5 : GoUInt64))));
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    @:keep
    public function setString(_s:GoString):{ var _0 : Float_; var _1 : Bool; } {
        var _z = this;
        _z;
        {
            var __tmp__ = _z.parse(_s, ((0 : GoInt))), _f:Ref<Float_> = __tmp__._0, _0:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err == null) {
                return { _0 : _f, _1 : true };
            };
        };
        return { _0 : null, _1 : false };
    }
    @:keep
    public function _int64():GoInt64 {
        var _x = this;
        _x;
        var __tmp__ = _x.int64(), _i:GoInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
        if (_acc != ((0 : GoInt8))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("%s is not an int64" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt))))));
        };
        return _i;
    }
    @:keep
    public function _uint64():GoUInt64 {
        var _x = this;
        _x;
        var __tmp__ = _x.uint64(), _u:GoUInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
        if (_acc != ((0 : GoInt8))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("%s is not a uint64" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt))))));
        };
        return _u;
    }
    @:keep
    public function _ord():GoInt {
        var _x = this;
        _x;
        var _m:GoInt = ((0 : GoInt));
        if (_x._form == ((1 : GoUInt8))) {
            _m = ((1 : GoInt));
        } else if (_x._form == ((0 : GoUInt8))) {
            return ((0 : GoInt));
        } else if (_x._form == ((2 : GoUInt8))) {
            _m = ((2 : GoInt));
        };
        if (_x._neg) {
            _m = -_m;
        };
        return _m;
    }
    @:keep
    public function cmp(_y:Float_):GoInt {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
            _y._validate();
        };
        var _mx:GoInt = _x._ord();
        var _my:GoInt = _y._ord();
        if (_mx < _my) {
            return ((-1 : GoInt));
        } else if (_mx > _my) {
            return ((1 : GoInt));
        };
        if (_mx == ((-1 : GoInt))) {
            return _y._ucmp(_x);
        } else if (_mx == ((1 : GoInt))) {
            return _x._ucmp(_y);
        };
        return ((0 : GoInt));
    }
    @:keep
    public function quo(_x:Float_, _y:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != _y._neg;
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            _z._uquo(_x, _y);
            return _z;
        };
        _z._acc = ((0 : GoInt8));
        if (((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) || ((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8))))) {
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("division of zero by zero or infinity by infinity" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) || (_y._form == ((2 : GoUInt8)))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._form = ((2 : GoUInt8));
        return _z;
    }
    @:keep
    public function mul(_x:Float_, _y:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != _y._neg;
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            _z._umul(_x, _y);
            return _z;
        };
        _z._acc = ((0 : GoInt8));
        if (((_x._form == ((0 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) || ((_x._form == ((2 : GoUInt8))) && (_y._form == ((0 : GoUInt8))))) {
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("multiplication of zero with infinity" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((2 : GoUInt8)))) {
            _z._form = ((2 : GoUInt8));
            return _z;
        };
        _z._form = ((0 : GoUInt8));
        return _z;
    }
    @:keep
    public function sub(_x:Float_, _y:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg != _yneg) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > ((0 : GoInt))) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == ((0 : GoUInt8))) && (_z._mode == ((4 : GoUInt8)))) && (_z._acc == ((0 : GoInt8)))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) && (_x._neg == _y._neg)) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("subtraction of infinities with equal signs" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = _x._neg && !_y._neg;
            return _z;
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((0 : GoUInt8)))) {
            return _z.set(_x);
        };
        return _z.neg(_y);
    }
    @:keep
    public function add(_x:Float_, _y:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg == _yneg) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > ((0 : GoInt))) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == ((0 : GoUInt8))) && (_z._mode == ((4 : GoUInt8)))) && (_z._acc == ((0 : GoInt8)))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) && (_x._neg != _y._neg)) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("addition of infinities with opposite signs" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = _x._neg && _y._neg;
            return _z;
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((0 : GoUInt8)))) {
            return _z.set(_x);
        };
        return _z.set(_y);
    }
    @:keep
    public function _ucmp(_y:Float_):GoInt {
        var _x = this;
        _x;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        if (_x._exp < _y._exp) {
            return ((-1 : GoInt));
        } else if (_x._exp > _y._exp) {
            return ((1 : GoInt));
        };
        var _i:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        var _j:GoInt = (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) || (_j > ((0 : GoInt)))) {
            var _xm:Word = new Word(), _ym:Word = new Word();
            if (_i > ((0 : GoInt))) {
                _i--;
                _xm = (_x._mant != null ? _x._mant[_i] : new Word());
            };
            if (_j > ((0 : GoInt))) {
                _j--;
                _ym = (_y._mant != null ? _y._mant[_j] : new Word());
            };
            if (_xm < _ym) {
                return ((-1 : GoInt));
            } else if (_xm > _ym) {
                return ((1 : GoInt));
            };
        };
        return ((0 : GoInt));
    }
    @:keep
    public function _uquo(_x:Float_, _y:Float_):Void {
        var _z = this;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _n:GoInt = (((_z._prec / ((32 : GoUInt32))) : GoInt)) + ((1 : GoInt));
        var _xadj:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _d:GoInt = (_n - (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) + (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
            if (_d > ((0 : GoInt))) {
                _xadj = new Slice<Word>(...[for (i in 0 ... (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) + _d : GoInt)).toBasic()) new Word()]);
                Go.copySlice(((_xadj.__slice__(_d) : T_nat)), _x._mant);
            };
        };
        var _d:GoInt = (_xadj != null ? _xadj.length : ((0 : GoInt))) - (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
        var _r:T_nat = new T_nat();
        {
            var __tmp__ = _z._mant._div(null, (_xadj == null ? null : _xadj.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
            _z._mant = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        var _e:GoInt64 = (((_x._exp : GoInt64)) - ((_y._exp : GoInt64))) - ((((_d - (_z._mant != null ? _z._mant.length : ((0 : GoInt)))) : GoInt64)) * ((32 : GoInt64)));
        var _sbit:GoUInt = ((0 : GoUInt));
        if ((_r != null ? _r.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _sbit = ((1 : GoUInt));
        };
        _z._setExpAndRound(_e - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), _sbit);
    }
    @:keep
    public function _umul(_x:Float_, _y:Float_):Void {
        var _z = this;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _e:GoInt64 = ((_x._exp : GoInt64)) + ((_y._exp : GoInt64));
        if (_x == _y) {
            _z._mant = (_z._mant._sqr((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._sqr((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
        } else {
            _z._mant = (_z._mant._mul((_x._mant == null ? null : _x._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._mul((_x._mant == null ? null : _x._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
        };
        _z._setExpAndRound(_e - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public function _usub(_x:Float_, _y:Float_):Void {
        var _z = this;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = ((_x._exp : GoInt64)) - ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _ey:GoInt64 = ((_y._exp : GoInt64)) - ((((_y._mant != null ? _y._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _al:Bool = _alias((_z._mant == null ? null : _z._mant.__copy__()), (_x._mant == null ? null : _x._mant.__copy__())) || _alias((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
        if (_ex < _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_t._sub((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())) == null ? null : _t._sub((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : _z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._sub((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())) == null ? null : _z._mant._sub((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())).__copy__());
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_t._sub((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _t._sub((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : _z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._sub((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._sub((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            };
            _ex = _ey;
        };
        if ((_z._mant != null ? _z._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            return;
        };
        _z._setExpAndRound((_ex + ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public function _uadd(_x:Float_, _y:Float_):Void {
        var _z = this;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = ((_x._exp : GoInt64)) - ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _ey:GoInt64 = ((_y._exp : GoInt64)) - ((((_y._mant != null ? _y._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _al:Bool = _alias((_z._mant == null ? null : _z._mant.__copy__()), (_x._mant == null ? null : _x._mant.__copy__())) || _alias((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
        if (_ex < _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())) == null ? null : _z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : _z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())) == null ? null : _z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())).__copy__());
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._add((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : _z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._add((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            };
            _ex = _ey;
        };
        _z._setExpAndRound((_ex + ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public function neg(_x:Float_):Float_ {
        var _z = this;
        _z;
        _z.set(_x);
        _z._neg = !_z._neg;
        return _z;
    }
    @:keep
    public function abs(_x:Float_):Float_ {
        var _z = this;
        _z;
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    @:keep
    public function rat(_z:Rat):{ var _0 : Rat; var _1 : Accuracy; } {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if ((_z == null) && (_x._form <= ((1 : GoUInt8)))) {
            _z = new Rat();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _allBits:GoInt32 = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt32)) * ((32 : GoInt32));
            _z._a._neg = _x._neg;
            if (_x._exp > _allBits) {
                _z._a._abs = (_z._a._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_x._exp - _allBits) : GoUInt))) == null ? null : _z._a._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_x._exp - _allBits) : GoUInt))).__copy__());
                _z._b._abs = (((_z._b._abs.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z._b._abs.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            } else if (_x._exp < _allBits) {
                _z._a._abs = (_z._a._abs._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._a._abs._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
                var _t:T_nat = (_z._b._abs._setUint64(((1 : GoUInt64))) == null ? null : _z._b._abs._setUint64(((1 : GoUInt64))).__copy__());
                _z._b._abs = (_t._shl((_t == null ? null : _t.__copy__()), (((_allBits - _x._exp) : GoUInt))) == null ? null : _t._shl((_t == null ? null : _t.__copy__()), (((_allBits - _x._exp) : GoUInt))).__copy__());
                _z._norm();
            };
            return { _0 : _z, _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : _z.setInt64(((0 : GoInt64))), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            return { _0 : null, _1 : _makeAcc(_x._neg) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function int(_z:Int_):{ var _0 : Int_; var _1 : Accuracy; } {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if ((_z == null) && (_x._form <= ((1 : GoUInt8)))) {
            _z = new Int_();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _acc:Accuracy = _makeAcc(_x._neg);
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : _z.setInt64(((0 : GoInt64))), _1 : _acc };
            };
            var _allBits:GoUInt = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt));
            var _exp:GoUInt = ((_x._exp : GoUInt));
            if (_x.minPrec() <= _exp) {
                _acc = ((0 : GoInt8));
            };
            if (_z == null) {
                _z = new Int_();
            };
            _z._neg = _x._neg;
            if (_exp > _allBits) {
                _z._abs = (_z._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), _exp - _allBits) == null ? null : _z._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), _exp - _allBits).__copy__());
            } else if (_exp < _allBits) {
                _z._abs = (_z._abs._shr((_x._mant == null ? null : _x._mant.__copy__()), _allBits - _exp) == null ? null : _z._abs._shr((_x._mant == null ? null : _x._mant.__copy__()), _allBits - _exp).__copy__());
            };
            return { _0 : _z, _1 : _acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : _z.setInt64(((0 : GoInt64))), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            return { _0 : null, _1 : _makeAcc(_x._neg) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function float64():{ var _0 : GoFloat64; var _1 : Accuracy; } {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            {};
            var _e:GoInt32 = _x._exp - ((1 : GoInt32));
            var _p:GoInt = ((53 : GoInt));
            if (_e < ((-1022 : GoInt32))) {
                _p = ((1075 : GoInt)) + ((_e : GoInt));
                if ((_p < ((0 : GoInt))) || ((_p == ((0 : GoInt))) && (_x._mant._sticky(((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - ((1 : GoUInt))) == ((0 : GoUInt))))) {
                    if (_x._neg) {
                        var _z:GoFloat64 = ((0 : GoFloat64));
                        return { _0 : -_z, _1 : ((1 : GoInt8)) };
                    };
                    return { _0 : ((0 : GoFloat64)), _1 : ((-1 : GoInt8)) };
                };
                if (_p == ((0 : GoInt))) {
                    if (_x._neg) {
                        return { _0 : ((-5e-324 : GoFloat64)), _1 : ((-1 : GoInt8)) };
                    };
                    return { _0 : ((5e-324 : GoFloat64)), _1 : ((1 : GoInt8)) };
                };
            };
            var _r:Float_ = new Float_();
            _r._prec = ((_p : GoUInt32));
            _r.set(_x);
            _e = _r._exp - ((1 : GoInt32));
            if ((_r._form == ((2 : GoUInt8))) || (_e > ((1023 : GoInt32)))) {
                if (_x._neg) {
                    return { _0 : stdgo.math.Math.inf(((-1 : GoInt))), _1 : ((-1 : GoInt8)) };
                };
                return { _0 : stdgo.math.Math.inf(((1 : GoInt))), _1 : ((1 : GoInt8)) };
            };
            var _sign:GoUInt64 = ((0 : GoUInt64)), _bexp:GoUInt64 = ((0 : GoUInt64)), _mant:GoUInt64 = ((0 : GoUInt64));
            if (_x._neg) {
                _sign = (("9223372036854775808" : GoUInt64));
            };
            if (_e < ((-1022 : GoInt32))) {
                _p = ((1075 : GoInt)) + ((_e : GoInt));
                _mant = _msb64((_r._mant == null ? null : _r._mant.__copy__())) >> (((((64 : GoInt)) - _p) : GoUInt));
            } else {
                _bexp = (((_e + ((1023 : GoInt32))) : GoUInt64)) << ((52 : GoUnTypedInt));
                _mant = (_msb64((_r._mant == null ? null : _r._mant.__copy__())) >> ((11 : GoUnTypedInt))) & (("4503599627370495" : GoUInt64));
            };
            return { _0 : stdgo.math.Math.float64frombits((_sign | _bexp) | _mant), _1 : _r._acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            if (_x._neg) {
                var _z:GoFloat64 = ((0 : GoFloat64));
                return { _0 : -_z, _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((0 : GoFloat64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : stdgo.math.Math.inf(((-1 : GoInt))), _1 : ((0 : GoInt8)) };
            };
            return { _0 : stdgo.math.Math.inf(((1 : GoInt))), _1 : ((0 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function float32():{ var _0 : GoFloat32; var _1 : Accuracy; } {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            {};
            var _e:GoInt32 = _x._exp - ((1 : GoInt32));
            var _p:GoInt = ((24 : GoInt));
            if (_e < ((-126 : GoInt32))) {
                _p = ((150 : GoInt)) + ((_e : GoInt));
                if ((_p < ((0 : GoInt))) || ((_p == ((0 : GoInt))) && (_x._mant._sticky(((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - ((1 : GoUInt))) == ((0 : GoUInt))))) {
                    if (_x._neg) {
                        var _z:GoFloat32 = ((0 : GoFloat32));
                        return { _0 : -_z, _1 : ((1 : GoInt8)) };
                    };
                    return { _0 : ((0 : GoFloat32)), _1 : ((-1 : GoInt8)) };
                };
                if (_p == ((0 : GoInt))) {
                    if (_x._neg) {
                        return { _0 : ((-1.401298464324817e-45 : GoFloat32)), _1 : ((-1 : GoInt8)) };
                    };
                    return { _0 : ((1.401298464324817e-45 : GoFloat32)), _1 : ((1 : GoInt8)) };
                };
            };
            var _r:Float_ = new Float_();
            _r._prec = ((_p : GoUInt32));
            _r.set(_x);
            _e = _r._exp - ((1 : GoInt32));
            if ((_r._form == ((2 : GoUInt8))) || (_e > ((127 : GoInt32)))) {
                if (_x._neg) {
                    return { _0 : ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)), _1 : ((-1 : GoInt8)) };
                };
                return { _0 : ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), _1 : ((1 : GoInt8)) };
            };
            var _sign:GoUInt32 = ((0 : GoUInt32)), _bexp:GoUInt32 = ((0 : GoUInt32)), _mant:GoUInt32 = ((0 : GoUInt32));
            if (_x._neg) {
                _sign = (("2147483648" : GoUInt32));
            };
            if (_e < ((-126 : GoInt32))) {
                _p = ((150 : GoInt)) + ((_e : GoInt));
                _mant = _msb32((_r._mant == null ? null : _r._mant.__copy__())) >> (((((32 : GoInt)) - _p) : GoUInt));
            } else {
                _bexp = (((_e + ((127 : GoInt32))) : GoUInt32)) << ((23 : GoUnTypedInt));
                _mant = (_msb32((_r._mant == null ? null : _r._mant.__copy__())) >> ((8 : GoUnTypedInt))) & ((8388607 : GoUInt32));
            };
            return { _0 : stdgo.math.Math.float32frombits((_sign | _bexp) | _mant), _1 : _r._acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            if (_x._neg) {
                var _z:GoFloat32 = ((0 : GoFloat32));
                return { _0 : -_z, _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((0 : GoFloat32)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)), _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), _1 : ((0 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function int64():{ var _0 : GoInt64; var _1 : Accuracy; } {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _acc:Accuracy = _makeAcc(_x._neg);
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : ((0 : GoInt64)), _1 : _acc };
            };
            if (_x._exp <= ((63 : GoInt32))) {
                var _i:GoInt64 = (((_msb64((_x._mant == null ? null : _x._mant.__copy__())) >> (((64 : GoUInt32)) - ((_x._exp : GoUInt32)))) : GoInt64));
                if (_x._neg) {
                    _i = -_i;
                };
                if (_x.minPrec() <= ((_x._exp : GoUInt))) {
                    return { _0 : _i, _1 : ((0 : GoInt8)) };
                };
                return { _0 : _i, _1 : _acc };
            };
            if (_x._neg) {
                if ((_x._exp == ((64 : GoInt32))) && (_x.minPrec() == ((1 : GoUInt)))) {
                    _acc = ((0 : GoInt8));
                };
                return { _0 : (("-9223372036854775808" : GoInt64)), _1 : _acc };
            };
            return { _0 : (("9223372036854775807" : GoInt64)), _1 : ((-1 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : ((0 : GoInt64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : (("-9223372036854775808" : GoInt64)), _1 : ((1 : GoInt8)) };
            };
            return { _0 : (("9223372036854775807" : GoInt64)), _1 : ((-1 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function uint64():{ var _0 : GoUInt64; var _1 : Accuracy; } {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((0 : GoUInt64)), _1 : ((1 : GoInt8)) };
            };
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : ((0 : GoUInt64)), _1 : ((-1 : GoInt8)) };
            };
            if (_x._exp <= ((64 : GoInt32))) {
                var _u:GoUInt64 = _msb64((_x._mant == null ? null : _x._mant.__copy__())) >> (((64 : GoUInt32)) - ((_x._exp : GoUInt32)));
                if (_x.minPrec() <= ((64 : GoUInt))) {
                    return { _0 : _u, _1 : ((0 : GoInt8)) };
                };
                return { _0 : _u, _1 : ((-1 : GoInt8)) };
            };
            return { _0 : (("18446744073709551615" : GoUInt64)), _1 : ((-1 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : ((0 : GoUInt64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((0 : GoUInt64)), _1 : ((1 : GoInt8)) };
            };
            return { _0 : (("18446744073709551615" : GoUInt64)), _1 : ((-1 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function copy(_x:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
        };
        if (_z != _x) {
            _z._prec = _x._prec;
            _z._mode = _x._mode;
            _z._acc = _x._acc;
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_z._form == ((1 : GoUInt8))) {
                _z._mant = (_z._mant._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
                _z._exp = _x._exp;
            };
        };
        return _z;
    }
    @:keep
    public function set(_x:Float_):Float_ {
        var _z = this;
        _z;
        if (false) {
            _x._validate();
        };
        _z._acc = ((0 : GoInt8));
        if (_z != _x) {
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_x._form == ((1 : GoUInt8))) {
                _z._exp = _x._exp;
                _z._mant = (_z._mant._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
            };
            if (_z._prec == ((0 : GoUInt32))) {
                _z._prec = _x._prec;
            } else if (_z._prec < _x._prec) {
                _z._round(((0 : GoUInt)));
            };
        };
        return _z;
    }
    @:keep
    public function setInf(_signbit:Bool):Float_ {
        var _z = this;
        _z;
        _z._acc = ((0 : GoInt8));
        _z._form = ((2 : GoUInt8));
        _z._neg = _signbit;
        return _z;
    }
    @:keep
    public function setRat(_x:Rat):Float_ {
        var _z = this;
        _z;
        if (_x.isInt()) {
            return _z.setInt(_x.num());
        };
        var _a:Float_ = new Float_(), _b:Float_ = new Float_();
        _a.setInt(_x.num());
        _b.setInt(_x.denom());
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_a._prec, _b._prec);
        };
        return _z.quo(_a, _b);
    }
    @:keep
    public function setInt(_x:Int_):Float_ {
        var _z = this;
        _z;
        var _bits:GoUInt32 = ((_x.bitLen() : GoUInt32));
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_bits, ((64 : GoUInt32)));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = _x._neg;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._mant = (_z._mant._set((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._mant._set((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
        _fnorm((_z._mant == null ? null : _z._mant.__copy__()));
        _z._setExpAndRound(((_bits : GoInt64)), ((0 : GoUInt)));
        return _z;
    }
    @:keep
    public function setFloat64(_x:GoFloat64):Float_ {
        var _z = this;
        _z;
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = ((53 : GoUInt32));
        };
        if (stdgo.math.Math.isNaN(_x)) {
            throw Go.toInterface(((new ErrNaN(((("Float.SetFloat64(NaN)" : GoString)))) : ErrNaN)));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = stdgo.math.Math.signbit(_x);
        if (_x == ((0 : GoFloat64))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        if (stdgo.math.Math.isInf(_x, ((0 : GoInt)))) {
            _z._form = ((2 : GoUInt8));
            return _z;
        };
        _z._form = ((1 : GoUInt8));
        var __tmp__ = stdgo.math.Math.frexp(_x), _fmant:GoFloat64 = __tmp__._0, _exp:GoInt = __tmp__._1;
        _z._mant = (_z._mant._setUint64((("9223372036854775808" : GoUInt64)) | (stdgo.math.Math.float64bits(_fmant) << ((11 : GoUnTypedInt)))) == null ? null : _z._mant._setUint64((("9223372036854775808" : GoUInt64)) | (stdgo.math.Math.float64bits(_fmant) << ((11 : GoUnTypedInt)))).__copy__());
        _z._exp = ((_exp : GoInt32));
        if (_z._prec < ((53 : GoUInt32))) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public function setInt64(_x:GoInt64):Float_ {
        var _z = this;
        _z;
        var _u:GoInt64 = _x;
        if (_u < ((0 : GoInt64))) {
            _u = -_u;
        };
        return _z._setBits64(_x < ((0 : GoInt64)), ((_u : GoUInt64)));
    }
    @:keep
    public function setUint64(_x:GoUInt64):Float_ {
        var _z = this;
        _z;
        return _z._setBits64(false, _x);
    }
    @:keep
    public function _setBits64(_neg:Bool, _x:GoUInt64):Float_ {
        var _z = this;
        _z;
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = ((64 : GoUInt32));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = _neg;
        if (_x == ((0 : GoUInt64))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._form = ((1 : GoUInt8));
        var _s:GoInt = stdgo.math.bits.Bits.leadingZeros64(_x);
        _z._mant = (_z._mant._setUint64(_x << ((_s : GoUInt))) == null ? null : _z._mant._setUint64(_x << ((_s : GoUInt))).__copy__());
        _z._exp = (((((64 : GoInt)) - _s) : GoInt32));
        if (_z._prec < ((64 : GoUInt32))) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public function _round(_sbit:GoUInt):Void {
        var _z = this;
        _z;
        if (false) {
            _z._validate();
        };
        _z._acc = ((0 : GoInt8));
        if (_z._form != ((1 : GoUInt8))) {
            return;
        };
        var _m:GoUInt32 = (((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoUInt32));
        var _bits:GoUInt32 = _m * ((32 : GoUInt32));
        if (_bits <= _z._prec) {
            return;
        };
        var _r:GoUInt = ((((_bits - _z._prec) - ((1 : GoUInt32))) : GoUInt));
        var _rbit:GoUInt = _z._mant._bit(_r) & ((1 : GoUInt));
        if ((_sbit == ((0 : GoUInt))) && ((_rbit == ((0 : GoUInt))) || (_z._mode == ((0 : GoUInt8))))) {
            _sbit = _z._mant._sticky(_r);
        };
        _sbit = _sbit & (((1 : GoUInt)));
        var _n:GoUInt32 = (_z._prec + ((31 : GoUInt32))) / ((32 : GoUInt32));
        if (_m > _n) {
            Go.copySlice(_z._mant, ((_z._mant.__slice__(_m - _n) : T_nat)));
            _z._mant = (((_z._mant.__slice__(0, _n) : T_nat)) == null ? null : ((_z._mant.__slice__(0, _n) : T_nat)).__copy__());
        };
        var _ntz:GoUInt32 = (_n * ((32 : GoUInt32))) - _z._prec;
        var _lsb:Word = ((((1 : GoUInt)) : Word)) << _ntz;
        if ((_rbit | _sbit) != ((0 : GoUInt))) {
            var _inc:Bool = false;
            if (_z._mode == ((4 : GoUInt8))) {
                _inc = _z._neg;
            } else if (_z._mode == ((2 : GoUInt8))) {} else if (_z._mode == ((0 : GoUInt8))) {
                _inc = (_rbit != ((0 : GoUInt))) && ((_sbit != ((0 : GoUInt))) || (((_z._mant != null ? _z._mant[((0 : GoInt))] : new Word()) & _lsb) != ((0 : GoUInt))));
            } else if (_z._mode == ((1 : GoUInt8))) {
                _inc = _rbit != ((0 : GoUInt));
            } else if (_z._mode == ((3 : GoUInt8))) {
                _inc = true;
            } else if (_z._mode == ((5 : GoUInt8))) {
                _inc = !_z._neg;
            } else {
                throw Go.toInterface(((("unreachable" : GoString))));
            };
            _z._acc = _makeAcc(_inc != _z._neg);
            if (_inc) {
                if (_addVW(_z._mant, _z._mant, _lsb) != ((0 : GoUInt))) {
                    if (_z._exp >= ((2147483647 : GoInt32))) {
                        _z._form = ((2 : GoUInt8));
                        return;
                    };
                    _z._exp++;
                    _shrVU(_z._mant, _z._mant, ((1 : GoUInt)));
                    {};
                    if (_z._mant != null) (_z._mant != null ? _z._mant[_n - ((1 : GoUInt32))] : new Word()) | ((("2147483648" : GoUInt)));
                };
            };
        };
        if (_z._mant != null) (_z._mant != null ? _z._mant[((0 : GoInt))] : new Word()) & ((_lsb - ((1 : GoUInt))) ^ ((-1 : GoUnTypedInt)));
        if (false) {
            _z._validate();
        };
    }
    @:keep
    public function _validate():Void {
        var _x = this;
        _x;
        if (true) {
            throw Go.toInterface(((("validate called but debugFloat is not set" : GoString))));
        };
        if (_x._form != ((1 : GoUInt8))) {
            return;
        };
        var _m:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        if (_m == ((0 : GoInt))) {
            throw Go.toInterface(((("nonzero finite number with empty mantissa" : GoString))));
        };
        {};
        if (((_x._mant != null ? _x._mant[_m - ((1 : GoInt))] : new Word()) & (("2147483648" : GoUInt))) == ((0 : GoUInt))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("msb not set in last word %#x of %s" : GoString))), Go.toInterface((_x._mant != null ? _x._mant[_m - ((1 : GoInt))] : new Word())), Go.toInterface(_x.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt))))));
        };
        if (_x._prec == ((0 : GoUInt32))) {
            throw Go.toInterface(((("zero precision finite number" : GoString))));
        };
    }
    @:keep
    public function isInt():Bool {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form != ((1 : GoUInt8))) {
            return _x._form == ((0 : GoUInt8));
        };
        if (_x._exp <= ((0 : GoInt32))) {
            return false;
        };
        return (_x._prec <= ((_x._exp : GoUInt32))) || (_x.minPrec() <= ((_x._exp : GoUInt)));
    }
    @:keep
    public function isInf():Bool {
        var _x = this;
        _x;
        return _x._form == ((2 : GoUInt8));
    }
    @:keep
    public function signbit():Bool {
        var _x = this;
        _x;
        return _x._neg;
    }
    @:keep
    public function setMantExp(_mant:Float_, _exp:GoInt):Float_ {
        var _z = this;
        _z;
        if (false) {
            _z._validate();
            _mant._validate();
        };
        _z.copy(_mant);
        if (_z._form == ((1 : GoUInt8))) {
            _z._setExpAndRound(((_z._exp : GoInt64)) + ((_exp : GoInt64)), ((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public function _setExpAndRound(_exp:GoInt64, _sbit:GoUInt):Void {
        var _z = this;
        _z;
        if (_exp < ((-2147483648 : GoInt64))) {
            _z._acc = _makeAcc(_z._neg);
            _z._form = ((0 : GoUInt8));
            return;
        };
        if (_exp > ((2147483647 : GoInt64))) {
            _z._acc = _makeAcc(!_z._neg);
            _z._form = ((2 : GoUInt8));
            return;
        };
        _z._form = ((1 : GoUInt8));
        _z._exp = ((_exp : GoInt32));
        _z._round(_sbit);
    }
    @:keep
    public function mantExp(_mant:Float_):GoInt {
        var _x = this;
        _x;
        var _exp:GoInt = ((0 : GoInt));
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            _exp = ((_x._exp : GoInt));
        };
        if (_mant != null) {
            _mant.copy(_x);
            if (_mant._form == ((1 : GoUInt8))) {
                _mant._exp = ((0 : GoInt32));
            };
        };
        return _exp;
    }
    @:keep
    public function sign():GoInt {
        var _x = this;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((0 : GoUInt8))) {
            return ((0 : GoInt));
        };
        if (_x._neg) {
            return ((-1 : GoInt));
        };
        return ((1 : GoInt));
    }
    @:keep
    public function acc():Accuracy {
        var _x = this;
        _x;
        return _x._acc;
    }
    @:keep
    public function mode():RoundingMode {
        var _x = this;
        _x;
        return _x._mode;
    }
    @:keep
    public function minPrec():GoUInt {
        var _x = this;
        _x;
        if (_x._form != ((1 : GoUInt8))) {
            return ((0 : GoUInt));
        };
        return ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - _x._mant._trailingZeroBits();
    }
    @:keep
    public function prec():GoUInt {
        var _x = this;
        _x;
        return ((_x._prec : GoUInt));
    }
    @:keep
    public function setMode(_mode:RoundingMode):Float_ {
        var _z = this;
        _z;
        _z._mode = _mode;
        _z._acc = ((0 : GoInt8));
        return _z;
    }
    @:keep
    public function setPrec(_prec:GoUInt):Float_ {
        var _z = this;
        _z;
        _z._acc = ((0 : GoInt8));
        if (_prec == ((0 : GoUInt))) {
            _z._prec = ((0 : GoUInt32));
            if (_z._form == ((1 : GoUInt8))) {
                _z._acc = _makeAcc(_z._neg);
                _z._form = ((0 : GoUInt8));
            };
            return _z;
        };
        if (_prec > (("4294967295" : GoUInt))) {
            _prec = (("4294967295" : GoUInt));
        };
        var _old:GoUInt32 = _z._prec;
        _z._prec = ((_prec : GoUInt32));
        if (_z._prec < _old) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    public var _prec : GoUInt32 = ((0 : GoUInt32));
    public var _mode : RoundingMode = new RoundingMode();
    public var _acc : Accuracy = new Accuracy();
    public var _form : T_form = new T_form();
    public var _neg : Bool = false;
    public var _mant : T_nat = new T_nat();
    public var _exp : GoInt32 = ((0 : GoInt32));
    public function new(?_prec:GoUInt32, ?_mode:RoundingMode, ?_acc:Accuracy, ?_form:T_form, ?_neg:Bool, ?_mant:T_nat, ?_exp:GoInt32) {
        if (_prec != null) this._prec = _prec;
        if (_mode != null) this._mode = _mode;
        if (_acc != null) this._acc = _acc;
        if (_form != null) this._form = _form;
        if (_neg != null) this._neg = _neg;
        if (_mant != null) this._mant = _mant;
        if (_exp != null) this._exp = _exp;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new Float_(_prec, _mode, _acc, _form, _neg, _mant, _exp);
    }
}
@:structInit @:using(stdgo.math.big.Big.ErrNaN_static_extension) class ErrNaN {
    @:keep
    public function error():GoString {
        var _err = this;
        (_err == null ? null : _err.__copy__());
        return _err._msg;
    }
    public var _msg : GoString = (("" : GoString));
    public function new(?_msg:GoString) {
        if (_msg != null) this._msg = _msg;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new ErrNaN(_msg);
    }
}
@:structInit @:using(stdgo.math.big.Big.T_matrix_static_extension) class T_matrix {
    @:keep
    public function toString():GoString {
        var _a = this;
        _a;
        var _s:GoString = ((("" : GoString)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _a._m, _j++, {
                        _s = _s + (stdgo.fmt.Fmt.sprintf(((("\t%s" : GoString))), Go.toInterface(_a._at(_i, _j))));
                    });
                };
                _s = _s + (((("\n" : GoString))));
            });
        };
        return _s;
    }
    @:keep
    public function _eql(_b:T_matrix):Bool {
        var _a = this;
        _a;
        if ((_a._n != _b._n) || (_a._m != _b._m)) {
            return false;
        };
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _a._m, _j++, {
                        if (_a._at(_i, _j).cmp(_b._at(_i, _j)) != ((0 : GoInt))) {
                            return false;
                        };
                    });
                };
            });
        };
        return true;
    }
    @:keep
    public function _mul(_b:T_matrix):T_matrix {
        var _a = this;
        _a;
        if (_a._m != _b._n) {
            throw Go.toInterface(((("illegal matrix multiply" : GoString))));
        };
        var _c:Ref<T_matrix> = _newMatrix(_a._n, _b._m);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _c._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _c._m, _j++, {
                        var _x:Ref<Rat> = newRat(((0 : GoInt64)), ((1 : GoInt64)));
                        {
                            var _k:GoInt = ((0 : GoInt));
                            Go.cfor(_k < _a._m, _k++, {
                                _x.add(_x, new Rat().mul(_a._at(_i, _k), _b._at(_k, _j)));
                            });
                        };
                        _c._set(_i, _j, _x);
                    });
                };
            });
        };
        return _c;
    }
    @:keep
    public function _set(_i:GoInt, _j:GoInt, _x:Rat):Void {
        var _a = this;
        _a;
        if (!((((((0 : GoInt)) <= _i) && (_i < _a._n)) && (((0 : GoInt)) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(((("index out of range" : GoString))));
        };
        if (_a._a != null) _a._a[(_i * _a._m) + _j] = _x;
    }
    @:keep
    public function _at(_i:GoInt, _j:GoInt):Rat {
        var _a = this;
        _a;
        if (!((((((0 : GoInt)) <= _i) && (_i < _a._n)) && (((0 : GoInt)) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(((("index out of range" : GoString))));
        };
        return (_a._a != null ? _a._a[(_i * _a._m) + _j] : ((null : Ref<Rat>)));
    }
    public var _n : GoInt = ((0 : GoInt));
    public var _m : GoInt = ((0 : GoInt));
    public var _a : Slice<Ref<Rat>> = ((null : Slice<Ref<Rat>>));
    public function new(?_n:GoInt, ?_m:GoInt, ?_a:Slice<Ref<Rat>>) {
        if (_n != null) this._n = _n;
        if (_m != null) this._m = _m;
        if (_a != null) this._a = _a;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_matrix(_n, _m, _a);
    }
}
@:structInit @:using(stdgo.math.big.Big.Int__static_extension) class Int_ {
    @:keep
    public function _scaleDenom(_x:Int_, _f:T_nat):Void {
        var _z = this;
        _z;
        if ((_f != null ? _f.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z.set(_x);
            return;
        };
        _z._abs = (_z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_f == null ? null : _f.__copy__())) == null ? null : _z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_f == null ? null : _f.__copy__())).__copy__());
        _z._neg = _x._neg;
    }
    @:keep
    public function probablyPrime(_n:GoInt):Bool {
        var _x = this;
        _x;
        if (_n < ((0 : GoInt))) {
            throw Go.toInterface(((("negative n for ProbablyPrime" : GoString))));
        };
        if (_x._neg || ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            return false;
        };
        {};
        var _w:Word = (_x._abs != null ? _x._abs[((0 : GoInt))] : new Word());
        if (((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((1 : GoInt))) && (_w < ((64 : GoUInt)))) {
            return ((("2891462833508853932" : GoUInt64)) & (((1 : GoUInt64)) << _w)) != ((0 : GoUInt64));
        };
        if ((_w & ((1 : GoUInt))) == ((0 : GoUInt))) {
            return false;
        };
        {};
        {};
        var _rA:GoUInt32 = ((0 : GoUInt32)), _rB:GoUInt32 = ((0 : GoUInt32));
        if (((32 : GoInt)) == ((32 : GoInt))) {
            _rA = ((_x._abs._modW((("4127218095" : GoUInt))) : GoUInt32));
            _rB = ((_x._abs._modW((("3948078067" : GoUInt))) : GoUInt32));
        } else if (((32 : GoInt)) == ((64 : GoInt))) {
            var _r:Word = _x._abs._modW(((820596253 : GoUInt)));
            _rA = (((_r % (("4127218095" : GoUInt))) : GoUInt32));
            _rB = (((_r % (("3948078067" : GoUInt))) : GoUInt32));
        } else {
            throw Go.toInterface(((("math/big: invalid word size" : GoString))));
        };
        if ((((((((((((((((_rA % ((3 : GoUInt32))) == ((0 : GoUInt32))) || ((_rA % ((5 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((7 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((11 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((13 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((17 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((19 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((23 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((37 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((29 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((31 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((41 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((43 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((47 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((53 : GoUInt32))) == ((0 : GoUInt32)))) {
            return false;
        };
        return _x._abs._probablyPrimeMillerRabin(_n + ((1 : GoInt)), true) && _x._abs._probablyPrimeLucas();
    }
    @:keep
    public function unmarshalJSON(_text:Slice<GoByte>):Error {
        var _z = this;
        _z;
        if (((_text : GoString)) == ((("null" : GoString)))) {
            return ((null : stdgo.Error));
        };
        return _z.unmarshalText(_text);
    }
    @:keep
    public function marshalJSON():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        return _x.marshalText();
    }
    @:keep
    public function unmarshalText(_text:Slice<GoByte>):Error {
        var _z = this;
        _z;
        {
            var __tmp__ = _z._setFromScanner(stdgo.bytes.Bytes.newReader(_text), ((0 : GoInt))), _0:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Int" : GoString))), Go.toInterface(_text));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x == null) {
            return { _0 : ((((("<nil>" : GoString))) : Slice<GoByte>)), _1 : ((null : stdgo.Error)) };
        };
        return { _0 : _x._abs._itoa(_x._neg, ((10 : GoInt))), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function gobDecode(_buf:Slice<GoByte>):Error {
        var _z = this;
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Int_() : Int_));
                _z._neg = __tmp__._neg;
                _z._abs = __tmp__._abs;
            };
            return ((null : stdgo.Error));
        };
        var _b:GoUInt8 = (_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)));
        if ((_b >> ((1 : GoUnTypedInt))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Int.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface(_b >> ((1 : GoUnTypedInt))));
        };
        _z._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._abs = (_z._abs._setBytes(((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>))) == null ? null : _z._abs._setBytes(((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>))).__copy__());
        return ((null : stdgo.Error));
    }
    @:keep
    public function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((1 : GoInt)) + ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) * ((4 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _i:GoInt = _x._abs._bytes(_buf) - ((1 : GoInt));
        var _b:GoUInt8 = ((2 : GoUInt8));
        if (_x._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[_i] = _b;
        return { _0 : ((_buf.__slice__(_i) : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var _z = this;
        _z;
        _s.skipSpace();
        var _base:GoInt = ((0 : GoInt));
        if (_ch == ((((("b" : GoString))).code : GoRune))) {
            _base = ((2 : GoInt));
        } else if (_ch == ((((("o" : GoString))).code : GoRune))) {
            _base = ((8 : GoInt));
        } else if (_ch == ((((("d" : GoString))).code : GoRune))) {
            _base = ((10 : GoInt));
        } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
            _base = ((16 : GoInt));
        } else if (_ch == ((((("s" : GoString))).code : GoRune)) || _ch == ((((("v" : GoString))).code : GoRune))) {} else {
            return stdgo.errors.Errors.new_(((("Int.Scan: invalid verb" : GoString))));
        };
        var __tmp__ = _z._scan(((new T_byteReader(_s) : T_byteReader)), _base), _0:Ref<Int_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        return _err;
    }
    @:keep
    public function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Int_; var _1 : GoInt; var _2 : Error; } {
        var _z = this;
        _z;
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : ((0 : GoInt)), _2 : _err };
        };
        {
            var __tmp__ = _z._abs._scan(_r, _base, false);
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _base = __tmp__._1;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : _base, _2 : _err };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return { _0 : _z, _1 : _base, _2 : ((null : stdgo.Error)) };
    }
    @:keep
    public function format(_s:stdgo.fmt.Fmt.State, _ch:GoRune):Void {
        var _x = this;
        _x;
        var _base:GoInt = ((0 : GoInt));
        if (_ch == ((((("b" : GoString))).code : GoRune))) {
            _base = ((2 : GoInt));
        } else if (_ch == ((((("o" : GoString))).code : GoRune)) || _ch == ((((("O" : GoString))).code : GoRune))) {
            _base = ((8 : GoInt));
        } else if (_ch == ((((("d" : GoString))).code : GoRune)) || _ch == ((((("s" : GoString))).code : GoRune)) || _ch == ((((("v" : GoString))).code : GoRune))) {
            _base = ((10 : GoInt));
        } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
            _base = ((16 : GoInt));
        } else {
            stdgo.fmt.Fmt.fprintf(_s, ((("%%!%c(big.Int=%s)" : GoString))), Go.toInterface(_ch), Go.toInterface(((_x.toString() : GoString))));
            return;
        };
        if (_x == null) {
            stdgo.fmt.Fmt.fprint(_s, ((("<nil>" : GoString))));
            return;
        };
        var _sign:GoString = ((("" : GoString)));
        if (_x._neg) {
            _sign = ((("-" : GoString)));
        } else if (_s.flag(((((("+" : GoString))).code : GoRune)))) {
            _sign = ((("+" : GoString)));
        } else if (_s.flag((((((" " : GoString))).code : GoRune)))) {
            _sign = (((" " : GoString)));
        };
        var _prefix:GoString = ((("" : GoString)));
        if (_s.flag(((((("#" : GoString))).code : GoRune)))) {
            if (_ch == ((((("b" : GoString))).code : GoRune))) {
                _prefix = ((("0b" : GoString)));
            } else if (_ch == ((((("o" : GoString))).code : GoRune))) {
                _prefix = ((("0" : GoString)));
            } else if (_ch == ((((("x" : GoString))).code : GoRune))) {
                _prefix = ((("0x" : GoString)));
            } else if (_ch == ((((("X" : GoString))).code : GoRune))) {
                _prefix = ((("0X" : GoString)));
            };
        };
        if (_ch == ((((("O" : GoString))).code : GoRune))) {
            _prefix = ((("0o" : GoString)));
        };
        var _digits:Slice<GoUInt8> = _x._abs._utoa(_base);
        if (_ch == ((((("X" : GoString))).code : GoRune))) {
            for (_i => _d in _digits) {
                if ((((((("a" : GoString))).code : GoRune)) <= _d) && (_d <= ((((("z" : GoString))).code : GoRune)))) {
                    if (_digits != null) _digits[_i] = ((((("A" : GoString))).code : GoRune)) + (_d - ((((("a" : GoString))).code : GoRune)));
                };
            };
        };
        var _left:GoInt = ((0 : GoInt));
        var _zeros:GoInt = ((0 : GoInt));
        var _right:GoInt = ((0 : GoInt));
        var __tmp__ = _s.precision(), _precision:GoInt = __tmp__._0, _precisionSet:Bool = __tmp__._1;
        if (_precisionSet) {
            if ((_digits != null ? _digits.length : ((0 : GoInt))) < _precision) {
                _zeros = _precision - (_digits != null ? _digits.length : ((0 : GoInt)));
            } else if ((((_digits != null ? _digits.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_digits != null ? _digits[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) && (_precision == ((0 : GoInt)))) {
                return;
            };
        };
        var _length:GoInt = (((_sign != null ? _sign.length : ((0 : GoInt))) + (_prefix != null ? _prefix.length : ((0 : GoInt)))) + _zeros) + (_digits != null ? _digits.length : ((0 : GoInt)));
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _widthSet:Bool = __tmp__._1;
            if (_widthSet && (_length < _width)) {
                {
                    var _d:GoInt = _width - _length;
                    if (_s.flag(((((("-" : GoString))).code : GoRune)))) {
                        _right = _d;
                    } else if (_s.flag(((((("0" : GoString))).code : GoRune))) && !_precisionSet) {
                        _zeros = _d;
                    } else {
                        _left = _d;
                    };
                };
            };
        };
        _writeMultiple(_s, (((" " : GoString))), _left);
        _writeMultiple(_s, _sign, ((1 : GoInt)));
        _writeMultiple(_s, _prefix, ((1 : GoInt)));
        _writeMultiple(_s, ((("0" : GoString))), _zeros);
        _s.write(_digits);
        _writeMultiple(_s, (((" " : GoString))), _right);
    }
    @:keep
    public function toString():GoString {
        var _x = this;
        _x;
        return _x.text(((10 : GoInt)));
    }
    @:keep
    public function append(_buf:Slice<GoByte>, _base:GoInt):Slice<GoByte> {
        var _x = this;
        _x;
        if (_x == null) {
            return (_buf != null ? _buf.__append__(...((("<nil>" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("<nil>" : GoString))).__toArray__()));
        };
        return (_buf != null ? _buf.__append__(..._x._abs._itoa(_x._neg, _base).__toArray__()) : new Slice<GoUInt8>(..._x._abs._itoa(_x._neg, _base).__toArray__()));
    }
    @:keep
    public function text(_base:GoInt):GoString {
        var _x = this;
        _x;
        if (_x == null) {
            return ((("<nil>" : GoString)));
        };
        return ((_x._abs._itoa(_x._neg, _base) : GoString));
    }
    @:keep
    public function sqrt(_x:Int_):Int_ {
        var _z = this;
        _z;
        if (_x._neg) {
            throw Go.toInterface(((("square root of negative number" : GoString))));
        };
        _z._neg = false;
        _z._abs = (_z._abs._sqrt((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sqrt((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
        return _z;
    }
    @:keep
    public function not(_x:Int_):Int_ {
        var _z = this;
        _z;
        if (_x._neg) {
            _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public function xor(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._xor((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
                _z._neg = false;
                return _z;
            };
            _z._abs = (_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._add((_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public function or(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._add((_z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._neg = true;
                return _z;
            };
            _z._abs = (_z._abs._or((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._add((_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public function andNot(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x1 == null ? null : _x1.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x1 == null ? null : _x1.__copy__())).__copy__());
                _z._neg = false;
                return _z;
            };
            _z._abs = (_z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._abs = (_z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = true;
            return _z;
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function and(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._neg = true;
                return _z;
            };
            _z._abs = (_z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function setBit(_x:Int_, _i:GoInt, _b:GoUInt):Int_ {
        var _z = this;
        _z;
        if (_i < ((0 : GoInt))) {
            throw Go.toInterface(((("negative bit index" : GoString))));
        };
        if (_x._neg) {
            var _t:T_nat = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _t = (_t._setBit((_t == null ? null : _t.__copy__()), ((_i : GoUInt)), _b ^ ((1 : GoUInt))) == null ? null : _t._setBit((_t == null ? null : _t.__copy__()), ((_i : GoUInt)), _b ^ ((1 : GoUInt))).__copy__());
            _z._abs = (_t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = (_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt));
            return _z;
        };
        _z._abs = (_z._abs._setBit((_x._abs == null ? null : _x._abs.__copy__()), ((_i : GoUInt)), _b) == null ? null : _z._abs._setBit((_x._abs == null ? null : _x._abs.__copy__()), ((_i : GoUInt)), _b).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function bit(_i:GoInt):GoUInt {
        var _x = this;
        _x;
        if (_i == ((0 : GoInt))) {
            if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
                return ((((_x._abs != null ? _x._abs[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) : GoUInt));
            };
            return ((0 : GoUInt));
        };
        if (_i < ((0 : GoInt))) {
            throw Go.toInterface(((("negative bit index" : GoString))));
        };
        if (_x._neg) {
            var _t:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            return _t._bit(((_i : GoUInt))) ^ ((1 : GoUInt));
        };
        return _x._abs._bit(((_i : GoUInt)));
    }
    @:keep
    public function rsh(_x:Int_, _n:GoUInt):Int_ {
        var _z = this;
        _z;
        if (_x._neg) {
            var _t:T_nat = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _t = (_t._shr((_t == null ? null : _t.__copy__()), _n) == null ? null : _t._shr((_t == null ? null : _t.__copy__()), _n).__copy__());
            _z._abs = (_t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = true;
            return _z;
        };
        _z._abs = (_z._abs._shr((_x._abs == null ? null : _x._abs.__copy__()), _n) == null ? null : _z._abs._shr((_x._abs == null ? null : _x._abs.__copy__()), _n).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function lsh(_x:Int_, _n:GoUInt):Int_ {
        var _z = this;
        _z;
        _z._abs = (_z._abs._shl((_x._abs == null ? null : _x._abs.__copy__()), _n) == null ? null : _z._abs._shl((_x._abs == null ? null : _x._abs.__copy__()), _n).__copy__());
        _z._neg = _x._neg;
        return _z;
    }
    @:keep
    public function modSqrt(_x:Int_, _p:Int_):Int_ {
        var _z = this;
        _z;
        {
            var __switchIndex__ = -1;
            while (true) {
                if (jacobi(_x, _p) == ((-1 : GoInt))) {
                    return null;
                    break;
                } else if (jacobi(_x, _p) == ((0 : GoInt))) {
                    return _z.setInt64(((0 : GoInt64)));
                    break;
                } else if (jacobi(_x, _p) == ((1 : GoInt))) {
                    break;
                    break;
                };
                break;
            };
        };
        if (_x._neg || (_x.cmp(_p) >= ((0 : GoInt)))) {
            _x = new Int_().mod(_x, _p);
        };
        if (((_p._abs != null ? _p._abs[((0 : GoInt))] : new Word()) % ((4 : GoUInt))) == ((3 : GoUInt))) {
            return _z._modSqrt3Mod4Prime(_x, _p);
        } else if (((_p._abs != null ? _p._abs[((0 : GoInt))] : new Word()) % ((8 : GoUInt))) == ((5 : GoUInt))) {
            return _z._modSqrt5Mod8Prime(_x, _p);
        } else {
            return _z._modSqrtTonelliShanks(_x, _p);
        };
    }
    @:keep
    public function _modSqrtTonelliShanks(_x:Int_, _p:Int_):Int_ {
        var _z = this;
        _z;
        var _s:Int_ = new Int_();
        _s.sub(_p, _intOne);
        var _e:GoUInt = _s._abs._trailingZeroBits();
        _s.rsh(_s, _e);
        var _n:Int_ = new Int_();
        _n.setInt64(((2 : GoInt64)));
        while (jacobi(_n, _p) != ((-1 : GoInt))) {
            _n.add(_n, _intOne);
        };
        var _y:Int_ = new Int_(), _b:Int_ = new Int_(), _g:Int_ = new Int_(), _t:Int_ = new Int_();
        _y.add(_s, _intOne);
        _y.rsh(_y, ((1 : GoUInt)));
        _y.exp(_x, _y, _p);
        _b.exp(_x, _s, _p);
        _g.exp(_n, _s, _p);
        var _r:GoUInt = _e;
        while (true) {
            var _m:GoUInt = ((0 : GoUInt));
            _t.set(_b);
            while (_t.cmp(_intOne) != ((0 : GoInt))) {
                _t.mul(_t, _t).mod(_t, _p);
                _m++;
            };
            if (_m == ((0 : GoUInt))) {
                return _z.set(_y);
            };
            _t.setInt64(((0 : GoInt64))).setBit(_t, ((((_r - _m) - ((1 : GoUInt))) : GoInt)), ((1 : GoUInt))).exp(_g, _t, _p);
            _g.mul(_t, _t).mod(_g, _p);
            _y.mul(_y, _t).mod(_y, _p);
            _b.mul(_b, _g).mod(_b, _p);
            _r = _m;
        };
    }
    @:keep
    public function _modSqrt5Mod8Prime(_x:Int_, _p:Int_):Int_ {
        var _z = this;
        _z;
        var _e:Ref<Int_> = new Int_().rsh(_p, ((3 : GoUInt)));
        var _tx:Ref<Int_> = new Int_().lsh(_x, ((1 : GoUInt)));
        var _alpha:Ref<Int_> = new Int_().exp(_tx, _e, _p);
        var _beta:Ref<Int_> = new Int_().mul(_alpha, _alpha);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _tx);
        _beta.mod(_beta, _p);
        _beta.sub(_beta, _intOne);
        _beta.mul(_beta, _x);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _alpha);
        _z.mod(_beta, _p);
        return _z;
    }
    @:keep
    public function _modSqrt3Mod4Prime(_x:Int_, _p:Int_):Int_ {
        var _z = this;
        _z;
        var _e:Ref<Int_> = new Int_().add(_p, _intOne);
        _e.rsh(_e, ((2 : GoUInt)));
        _z.exp(_x, _e, _p);
        return _z;
    }
    @:keep
    public function modInverse(_g:Int_, _n:Int_):Int_ {
        var _z = this;
        _z;
        if (_n._neg) {
            var _n2:Int_ = new Int_();
            _n = _n2.neg(_n);
        };
        if (_g._neg) {
            var _g2:Int_ = new Int_();
            _g = _g2.mod(_g, _n);
        };
        var _d:Int_ = new Int_(), _x:Int_ = new Int_();
        _d.gcd(_x, null, _g, _n);
        if (_d.cmp(_intOne) != ((0 : GoInt))) {
            return null;
        };
        if (_x._neg) {
            _z.add(_x, _n);
        } else {
            _z.set(_x);
        };
        return _z;
    }
    @:keep
    public function rand(_rnd:stdgo.math.rand.Rand.Rand, _n:Int_):Int_ {
        var _z = this;
        _z;
        _z._neg = false;
        if (_n._neg || ((_n._abs != null ? _n._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            _z._abs = null;
            return _z;
        };
        _z._abs = (_z._abs._random(_rnd, (_n._abs == null ? null : _n._abs.__copy__()), _n._abs._bitLen()) == null ? null : _z._abs._random(_rnd, (_n._abs == null ? null : _n._abs.__copy__()), _n._abs._bitLen()).__copy__());
        return _z;
    }
    @:keep
    public function _lehmerGCD(_x:Int_, _y:Int_, _a:Int_, _b:Int_):Int_ {
        var _z = this;
        _z;
        var a:Int_ = ((null : Ref<Int_>)), b:Int_ = ((null : Ref<Int_>)), ua:Int_ = ((null : Ref<Int_>)), ub:Int_ = ((null : Ref<Int_>));
        a = new Int_().abs(_a);
        b = new Int_().abs(_b);
        var _extended:Bool = (_x != null) || (_y != null);
        if (_extended) {
            ua = new Int_().setInt64(((1 : GoInt64)));
            ub = new Int_();
        };
        var _q:Ref<Int_> = new Int_();
        var _r:Ref<Int_> = new Int_();
        var _s:Ref<Int_> = new Int_();
        var _t:Ref<Int_> = new Int_();
        if (a._abs._cmp((b._abs == null ? null : b._abs.__copy__())) < ((0 : GoInt))) {
            {
                final __tmp__0 = b;
                final __tmp__1 = a;
                a = __tmp__0;
                b = __tmp__1;
            };
            {
                final __tmp__0 = ua;
                final __tmp__1 = ub;
                ub = __tmp__0;
                ua = __tmp__1;
            };
        };
        while ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((1 : GoInt))) {
            var __tmp__ = _lehmerSimulate(a, b), _u0:Word = __tmp__._0, _u1:Word = __tmp__._1, _v0:Word = __tmp__._2, _v1:Word = __tmp__._3, _even:Bool = __tmp__._4;
            if (_v0 != ((0 : GoUInt))) {
                _lehmerUpdate(a,
b,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                if (_extended) {
                    _lehmerUpdate(ua,
ub,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                };
            } else {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
        };
        if ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
            if ((a._abs != null ? a._abs.length : ((0 : GoInt))) > ((1 : GoInt))) {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
            if ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
                var _aWord:Word = (a._abs != null ? a._abs[((0 : GoInt))] : new Word()), _bWord:Word = (b._abs != null ? b._abs[((0 : GoInt))] : new Word());
                if (_extended) {
                    var _ua:Word = new Word(), _ub:Word = new Word(), _va:Word = new Word(), _vb:Word = new Word();
                    {
                        final __tmp__0 = ((1 : GoUInt));
                        final __tmp__1 = ((0 : GoUInt));
                        _ua = __tmp__0;
                        _ub = __tmp__1;
                    };
                    {
                        final __tmp__0 = ((0 : GoUInt));
                        final __tmp__1 = ((1 : GoUInt));
                        _va = __tmp__0;
                        _vb = __tmp__1;
                    };
                    var _even:Bool = true;
                    while (_bWord != ((0 : GoUInt))) {
                        var _q:Word = _aWord / _bWord, _r:Word = _aWord % _bWord;
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _r;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                        {
                            final __tmp__0 = _ub;
                            final __tmp__1 = _ua + (_q * _ub);
                            _ua = __tmp__0;
                            _ub = __tmp__1;
                        };
                        {
                            final __tmp__0 = _vb;
                            final __tmp__1 = _va + (_q * _vb);
                            _va = __tmp__0;
                            _vb = __tmp__1;
                        };
                        _even = !_even;
                    };
                    _t._abs = (_t._abs._setWord(_ua) == null ? null : _t._abs._setWord(_ua).__copy__());
                    _s._abs = (_s._abs._setWord(_va) == null ? null : _s._abs._setWord(_va).__copy__());
                    _t._neg = !_even;
                    _s._neg = _even;
                    _t.mul(ua, _t);
                    _s.mul(ub, _s);
                    ua.add(_t, _s);
                } else {
                    while (_bWord != ((0 : GoUInt))) {
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _aWord % _bWord;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                    };
                };
                if (a._abs != null) a._abs[((0 : GoInt))] = _aWord;
            };
        };
        var _negA:Bool = _a._neg;
        if (_y != null) {
            if (_y == _b) {
                b.set(_b);
            } else {
                b = _b;
            };
            _y.mul(_a, ua);
            if (_negA) {
                _y._neg = !_y._neg;
            };
            _y.sub(a, _y);
            _y.div(_y, b);
        };
        if (_x != null) {
            {
                var __tmp__ = (ua == null ? null : ua.__copy__());
                _x._neg = __tmp__._neg;
                _x._abs = __tmp__._abs;
            };
            if (_negA) {
                _x._neg = !_x._neg;
            };
        };
        {
            var __tmp__ = (a == null ? null : a.__copy__());
            _z._neg = __tmp__._neg;
            _z._abs = __tmp__._abs;
        };
        return _z;
    }
    @:keep
    public function gcd(_x:Int_, _y:Int_, _a:Int_, _b:Int_):Int_ {
        var _z = this;
        _z;
        if (((_a._abs != null ? _a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || ((_b._abs != null ? _b._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            var _lenA:GoInt = (_a._abs != null ? _a._abs.length : ((0 : GoInt))), _lenB:GoInt = (_b._abs != null ? _b._abs.length : ((0 : GoInt))), _negA:Bool = _a._neg, _negB:Bool = _b._neg;
            if (_lenA == ((0 : GoInt))) {
                _z.set(_b);
            } else {
                _z.set(_a);
            };
            _z._neg = false;
            if (_x != null) {
                if (_lenA == ((0 : GoInt))) {
                    _x.setUint64(((0 : GoUInt64)));
                } else {
                    _x.setUint64(((1 : GoUInt64)));
                    _x._neg = _negA;
                };
            };
            if (_y != null) {
                if (_lenB == ((0 : GoInt))) {
                    _y.setUint64(((0 : GoUInt64)));
                } else {
                    _y.setUint64(((1 : GoUInt64)));
                    _y._neg = _negB;
                };
            };
            return _z;
        };
        return _z._lehmerGCD(_x, _y, _a, _b);
    }
    @:keep
    public function exp(_x:Int_, _y:Int_, _m:Int_):Int_ {
        var _z = this;
        _z;
        var _xWords:T_nat = (_x._abs == null ? null : _x._abs.__copy__());
        if (_y._neg) {
            if ((_m == null) || ((_m._abs != null ? _m._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                return _z.setInt64(((1 : GoInt64)));
            };
            var _inverse:Ref<Int_> = new Int_().modInverse(_x, _m);
            if (_inverse == null) {
                return null;
            };
            _xWords = (_inverse._abs == null ? null : _inverse._abs.__copy__());
        };
        var _yWords:T_nat = (_y._abs == null ? null : _y._abs.__copy__());
        var _mWords:T_nat = new T_nat();
        if (_m != null) {
            _mWords = (_m._abs == null ? null : _m._abs.__copy__());
        };
        _z._abs = (_z._abs._expNN((_xWords == null ? null : _xWords.__copy__()), (_yWords == null ? null : _yWords.__copy__()), (_mWords == null ? null : _mWords.__copy__())) == null ? null : _z._abs._expNN((_xWords == null ? null : _xWords.__copy__()), (_yWords == null ? null : _yWords.__copy__()), (_mWords == null ? null : _mWords.__copy__())).__copy__());
        _z._neg = ((((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg) && ((_yWords != null ? _yWords.length : ((0 : GoInt))) > ((0 : GoInt)))) && (((_yWords != null ? _yWords[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((1 : GoUInt)));
        if (_z._neg && ((_mWords != null ? _mWords.length : ((0 : GoInt))) > ((0 : GoInt)))) {
            _z._abs = (_z._abs._sub((_mWords == null ? null : _mWords.__copy__()), (_z._abs == null ? null : _z._abs.__copy__())) == null ? null : _z._abs._sub((_mWords == null ? null : _mWords.__copy__()), (_z._abs == null ? null : _z._abs.__copy__())).__copy__());
            _z._neg = false;
        };
        return _z;
    }
    @:keep
    public function trailingZeroBits():GoUInt {
        var _x = this;
        _x;
        return _x._abs._trailingZeroBits();
    }
    @:keep
    public function bitLen():GoInt {
        var _x = this;
        _x;
        return _x._abs._bitLen();
    }
    @:keep
    public function fillBytes(_buf:Slice<GoByte>):Slice<GoByte> {
        var _x = this;
        _x;
        for (_i => _ in _buf) {
            if (_buf != null) _buf[_i] = ((0 : GoUInt8));
        };
        _x._abs._bytes(_buf);
        return _buf;
    }
    @:keep
    public function bytes():Slice<GoByte> {
        var _x = this;
        _x;
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... (((_x._abs != null ? _x._abs.length : ((0 : GoInt))) * ((4 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        return ((_buf.__slice__(_x._abs._bytes(_buf)) : Slice<GoUInt8>));
    }
    @:keep
    public function setBytes(_buf:Slice<GoByte>):Int_ {
        var _z = this;
        _z;
        _z._abs = (_z._abs._setBytes(_buf) == null ? null : _z._abs._setBytes(_buf).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function _setFromScanner(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Int_; var _1 : Bool; } {
        var _z = this;
        _z;
        {
            var __tmp__ = _z._scan(_r, _base), _0:Ref<Int_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err != null) {
                return { _0 : null, _1 : false };
            };
        };
        {
            var __tmp__ = _r.readByte(), _2:GoUInt8 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != stdgo.io.Io.eof) {
                return { _0 : null, _1 : false };
            };
        };
        return { _0 : _z, _1 : true };
    }
    @:keep
    public function setString(_s:GoString, _base:GoInt):{ var _0 : Int_; var _1 : Bool; } {
        var _z = this;
        _z;
        return _z._setFromScanner(stdgo.strings.Strings.newReader(_s), _base);
    }
    @:keep
    public function isUint64():Bool {
        var _x = this;
        _x;
        return !_x._neg && ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) <= ((2 : GoInt)));
    }
    @:keep
    public function isInt64():Bool {
        var _x = this;
        _x;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) <= ((2 : GoInt))) {
            var _w:GoInt64 = ((_low64((_x._abs == null ? null : _x._abs.__copy__())) : GoInt64));
            return (_w >= ((0 : GoInt64))) || (_x._neg && (_w == -_w));
        };
        return false;
    }
    @:keep
    public function uint64():GoUInt64 {
        var _x = this;
        _x;
        return _low64((_x._abs == null ? null : _x._abs.__copy__()));
    }
    @:keep
    public function int64():GoInt64 {
        var _x = this;
        _x;
        var _v:GoInt64 = ((_low64((_x._abs == null ? null : _x._abs.__copy__())) : GoInt64));
        if (_x._neg) {
            _v = -_v;
        };
        return _v;
    }
    @:keep
    public function cmpAbs(_y:Int_):GoInt {
        var _x = this;
        _x;
        return _x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__()));
    }
    @:keep
    public function cmp(_y:Int_):GoInt {
        var _x = this;
        _x;
        var _r:GoInt = ((0 : GoInt));
        if (_x == _y) {} else if (_x._neg == _y._neg) {
            _r = _x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__()));
            if (_x._neg) {
                _r = -_r;
            };
        } else if (_x._neg) {
            _r = ((-1 : GoInt));
        } else {
            _r = ((1 : GoInt));
        };
        return _r;
    }
    @:keep
    public function divMod(_x:Int_, _y:Int_, _m:Int_):{ var _0 : Int_; var _1 : Int_; } {
        var _z = this;
        _z;
        var _y0:Ref<Int_> = _y;
        if ((_z == _y) || _alias((_z._abs == null ? null : _z._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()))) {
            _y0 = new Int_().set(_y);
        };
        _z.quoRem(_x, _y, _m);
        if (_m._neg) {
            if (_y0._neg) {
                _z.add(_z, _intOne);
                _m.sub(_m, _y0);
            } else {
                _z.sub(_z, _intOne);
                _m.add(_m, _y0);
            };
        };
        return { _0 : _z, _1 : _m };
    }
    @:keep
    public function mod(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        var _y0:Ref<Int_> = _y;
        if ((_z == _y) || _alias((_z._abs == null ? null : _z._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()))) {
            _y0 = new Int_().set(_y);
        };
        var _q:Int_ = new Int_();
        _q.quoRem(_x, _y, _z);
        if (_z._neg) {
            if (_y0._neg) {
                _z.sub(_z, _y0);
            } else {
                _z.add(_z, _y0);
            };
        };
        return _z;
    }
    @:keep
    public function div(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        var _y_neg:Bool = _y._neg;
        var _r:Int_ = new Int_();
        _z.quoRem(_x, _y, _r);
        if (_r._neg) {
            if (_y_neg) {
                _z.add(_z, _intOne);
            } else {
                _z.sub(_z, _intOne);
            };
        };
        return _z;
    }
    @:keep
    public function quoRem(_x:Int_, _y:Int_, _r:Int_):{ var _0 : Int_; var _1 : Int_; } {
        var _z = this;
        _z;
        {
            var __tmp__ = _z._abs._div((_r._abs == null ? null : _r._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r._abs = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        {
            final __tmp__0 = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
            final __tmp__1 = ((_r._abs != null ? _r._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg;
            _z._neg = __tmp__0;
            _r._neg = __tmp__1;
        };
        return { _0 : _z, _1 : _r };
    }
    @:keep
    public function rem(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        {
            var __tmp__ = ((new T_nat() : T_nat))._div((_z._abs == null ? null : _z._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg;
        return _z;
    }
    @:keep
    public function quo(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        {
            var __tmp__ = _z._abs._div(null, (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
        return _z;
    }
    @:keep
    public function binomial(_n:GoInt64, _k:GoInt64):Int_ {
        var _z = this;
        _z;
        if (((_n / ((2 : GoInt64))) < _k) && (_k <= _n)) {
            _k = _n - _k;
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a.mulRange((_n - _k) + ((1 : GoInt64)), _n);
        _b.mulRange(((1 : GoInt64)), _k);
        return _z.quo(_a, _b);
    }
    @:keep
    public function mulRange(_a:GoInt64, _b:GoInt64):Int_ {
        var _z = this;
        _z;
        if (_a > _b) {
            return _z.setInt64(((1 : GoInt64)));
        } else if ((_a <= ((0 : GoInt64))) && (_b >= ((0 : GoInt64)))) {
            return _z.setInt64(((0 : GoInt64)));
        };
        var _neg:Bool = false;
        if (_a < ((0 : GoInt64))) {
            _neg = ((_b - _a) & ((1 : GoInt64))) == ((0 : GoInt64));
            {
                final __tmp__0 = -_b;
                final __tmp__1 = -_a;
                _a = __tmp__0;
                _b = __tmp__1;
            };
        };
        _z._abs = (_z._abs._mulRange(((_a : GoUInt64)), ((_b : GoUInt64))) == null ? null : _z._abs._mulRange(((_a : GoUInt64)), ((_b : GoUInt64))).__copy__());
        _z._neg = _neg;
        return _z;
    }
    @:keep
    public function mul(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        if (_x == _y) {
            _z._abs = (_z._abs._sqr((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sqr((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        _z._abs = (_z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
        return _z;
    }
    @:keep
    public function sub(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        var _neg:Bool = _x._neg;
        if (_x._neg != _y._neg) {
            _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        } else {
            if (_x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__())) >= ((0 : GoInt))) {
                _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            } else {
                _neg = !_neg;
                _z._abs = (_z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return _z;
    }
    @:keep
    public function add(_x:Int_, _y:Int_):Int_ {
        var _z = this;
        _z;
        var _neg:Bool = _x._neg;
        if (_x._neg == _y._neg) {
            _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        } else {
            if (_x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__())) >= ((0 : GoInt))) {
                _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            } else {
                _neg = !_neg;
                _z._abs = (_z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return _z;
    }
    @:keep
    public function neg(_x:Int_):Int_ {
        var _z = this;
        _z;
        _z.set(_x);
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && !_z._neg;
        return _z;
    }
    @:keep
    public function abs(_x:Int_):Int_ {
        var _z = this;
        _z;
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    @:keep
    public function setBits(_abs:Slice<Word>):Int_ {
        var _z = this;
        _z;
        _z._abs = (((_abs : T_nat))._norm() == null ? null : ((_abs : T_nat))._norm().__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function bits():Slice<Word> {
        var _x = this;
        _x;
        return _x._abs;
    }
    @:keep
    public function set(_x:Int_):Int_ {
        var _z = this;
        _z;
        if (_z != _x) {
            _z._abs = (_z._abs._set((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._set((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            _z._neg = _x._neg;
        };
        return _z;
    }
    @:keep
    public function setUint64(_x:GoUInt64):Int_ {
        var _z = this;
        _z;
        _z._abs = (_z._abs._setUint64(_x) == null ? null : _z._abs._setUint64(_x).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function setInt64(_x:GoInt64):Int_ {
        var _z = this;
        _z;
        var _neg:Bool = false;
        if (_x < ((0 : GoInt64))) {
            _neg = true;
            _x = -_x;
        };
        _z._abs = (_z._abs._setUint64(((_x : GoUInt64))) == null ? null : _z._abs._setUint64(((_x : GoUInt64))).__copy__());
        _z._neg = _neg;
        return _z;
    }
    @:keep
    public function sign():GoInt {
        var _x = this;
        _x;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoInt));
        };
        if (_x._neg) {
            return ((-1 : GoInt));
        };
        return ((1 : GoInt));
    }
    public var _neg : Bool = false;
    public var _abs : T_nat = new T_nat();
    public function new(?_neg:Bool, ?_abs:T_nat) {
        if (_neg != null) this._neg = _neg;
        if (_abs != null) this._abs = _abs;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new Int_(_neg, _abs);
    }
}
@:structInit class T_argZZ {
    public var _z : Ref<Int_> = ((null : Ref<Int_>));
    public var _x : Ref<Int_> = ((null : Ref<Int_>));
    public var _y : Ref<Int_> = ((null : Ref<Int_>));
    public function new(?_z:Ref<Int_>, ?_x:Ref<Int_>, ?_y:Ref<Int_>) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argZZ(_z, _x, _y);
    }
}
@:structInit class T_intShiftTest {
    public var _in : GoString = (("" : GoString));
    public var _shift : GoUInt = ((0 : GoUInt));
    public var _out : GoString = (("" : GoString));
    public function new(?_in:GoString, ?_shift:GoUInt, ?_out:GoString) {
        if (_in != null) this._in = _in;
        if (_shift != null) this._shift = _shift;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_intShiftTest(_in, _shift, _out);
    }
}
@:structInit @:using(stdgo.math.big.Big.T_byteReader_static_extension) class T_byteReader {
    @:keep
    public function unreadByte():Error {
        var _r = this;
        (_r == null ? null : _r.__copy__());
        return _r.unreadRune();
    }
    @:keep
    public function readByte():{ var _0 : GoByte; var _1 : Error; } {
        var _r = this;
        (_r == null ? null : _r.__copy__());
        var __tmp__ = _r.readRune(), _ch:GoInt32 = __tmp__._0, _size:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if ((_size != ((1 : GoInt))) && (_err == null)) {
            _err = stdgo.fmt.Fmt.errorf(((("invalid rune %#U" : GoString))), Go.toInterface(_ch));
        };
        return { _0 : ((_ch : GoByte)), _1 : _err };
    }
    @:embedded
    public var scanState : stdgo.fmt.Fmt.ScanState = ((null : stdgo.fmt.Fmt.ScanState));
    public function new(?scanState:stdgo.fmt.Fmt.ScanState) {
        if (scanState != null) this.scanState = scanState;
    }
    public function read(_buf:Slice<GoUInt8>):{ var _0 : GoInt; var _1 : stdgo.Error; } return scanState.read(_buf);
    public function readRune():{ var _0 : GoInt32; var _1 : GoInt; var _2 : stdgo.Error; } return scanState.readRune();
    public function skipSpace() scanState.skipSpace();
    public function token(_skipSpace:Bool, _f:GoInt32 -> Bool):{ var _0 : Slice<GoUInt8>; var _1 : stdgo.Error; } return scanState.token(_skipSpace, _f);
    public function unreadRune():stdgo.Error return scanState.unreadRune();
    public function width():{ var _0 : GoInt; var _1 : Bool; } return scanState.width();
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_byteReader(scanState);
    }
}
@:structInit class T_argNN {
    public var _z : T_nat = new T_nat();
    public var _x : T_nat = new T_nat();
    public var _y : T_nat = new T_nat();
    public function new(?_z:T_nat, ?_x:T_nat, ?_y:T_nat) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_argNN(_z, _x, _y);
    }
}
@:structInit class T_shiftTest {
    public var _in : T_nat = new T_nat();
    public var _shift : GoUInt = ((0 : GoUInt));
    public var _out : T_nat = new T_nat();
    public function new(?_in:T_nat, ?_shift:GoUInt, ?_out:T_nat) {
        if (_in != null) this._in = _in;
        if (_shift != null) this._shift = _shift;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_shiftTest(_in, _shift, _out);
    }
}
@:structInit class T_modWTest {
    public var _in : GoString = (("" : GoString));
    public var _dividend : GoString = (("" : GoString));
    public var _out : GoString = (("" : GoString));
    public function new(?_in:GoString, ?_dividend:GoString, ?_out:GoString) {
        if (_in != null) this._in = _in;
        if (_dividend != null) this._dividend = _dividend;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_modWTest(_in, _dividend, _out);
    }
}
@:structInit class T_divisor {
    public var _bbb : T_nat = new T_nat();
    public var _nbits : GoInt = ((0 : GoInt));
    public var _ndigits : GoInt = ((0 : GoInt));
    public function new(?_bbb:T_nat, ?_nbits:GoInt, ?_ndigits:GoInt) {
        if (_bbb != null) this._bbb = _bbb;
        if (_nbits != null) this._nbits = _nbits;
        if (_ndigits != null) this._ndigits = _ndigits;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_divisor(_bbb, _nbits, _ndigits);
    }
}
@:structInit @:using(stdgo.math.big.Big.Rat_static_extension) class Rat {
    @:keep
    public function unmarshalText(_text:Slice<GoByte>):Error {
        var _z = this;
        _z;
        {
            var __tmp__ = _z.setString(((_text : GoString))), _0:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Rat" : GoString))), Go.toInterface(_text));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x.isInt()) {
            return _x._a.marshalText();
        };
        return { _0 : _x._marshal(), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function gobDecode(_buf:Slice<GoByte>):Error {
        var _z = this;
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Rat() : Rat));
                _z._a = __tmp__._a;
                _z._b = __tmp__._b;
            };
            return ((null : stdgo.Error));
        };
        var _b:GoUInt8 = (_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)));
        if ((_b >> ((1 : GoUnTypedInt))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Rat.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface(_b >> ((1 : GoUnTypedInt))));
        };
        {};
        var _i:GoUInt32 = ((5 : GoUInt32)) + stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((1 : GoInt)), ((5 : GoInt))) : Slice<GoUInt8>)));
        _z._a._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._a._abs = (_z._a._abs._setBytes(((_buf.__slice__(((5 : GoInt)), _i) : Slice<GoUInt8>))) == null ? null : _z._a._abs._setBytes(((_buf.__slice__(((5 : GoInt)), _i) : Slice<GoUInt8>))).__copy__());
        _z._b._abs = (_z._b._abs._setBytes(((_buf.__slice__(_i) : Slice<GoUInt8>))) == null ? null : _z._b._abs._setBytes(((_buf.__slice__(_i) : Slice<GoUInt8>))).__copy__());
        return ((null : stdgo.Error));
    }
    @:keep
    public function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = this;
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((5 : GoInt)) + (((_x._a._abs != null ? _x._a._abs.length : ((0 : GoInt))) + (_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt)))) * ((4 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _i:GoInt = _x._b._abs._bytes(_buf);
        var _j:GoInt = _x._a._abs._bytes(((_buf.__slice__(0, _i) : Slice<GoUInt8>)));
        var _n:GoInt = _i - _j;
        if (((((_n : GoUInt32)) : GoInt)) != _n) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : stdgo.errors.Errors.new_(((("Rat.GobEncode: numerator too large" : GoString)))) };
        };
        stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(_j - ((4 : GoInt)), _j) : Slice<GoUInt8>)), ((_n : GoUInt32)));
        _j = _j - (((5 : GoInt)));
        var _b:GoUInt8 = ((2 : GoUInt8));
        if (_x._a._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[_j] = _b;
        return { _0 : ((_buf.__slice__(_j) : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function floatString(_prec:GoInt):GoString {
        var _x = this;
        _x;
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        if (_x.isInt()) {
            _buf = _x._a.append(_buf, ((10 : GoInt)));
            if (_prec > ((0 : GoInt))) {
                _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
                {
                    var _i:GoInt = _prec;
                    Go.cfor(_i > ((0 : GoInt)), _i--, {
                        _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                    });
                };
            };
            return ((_buf : GoString));
        };
        var __tmp__ = ((new T_nat() : T_nat))._div(((new T_nat() : T_nat)), (_x._a._abs == null ? null : _x._a._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__())), _q:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
        var _p:T_nat = (_natOne == null ? null : _natOne.__copy__());
        if (_prec > ((0 : GoInt))) {
            _p = (((new T_nat() : T_nat))._expNN((_natTen == null ? null : _natTen.__copy__()), (((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))) == null ? null : ((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))).__copy__()), null) == null ? null : ((new T_nat() : T_nat))._expNN((_natTen == null ? null : _natTen.__copy__()), (((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))) == null ? null : ((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))).__copy__()), null).__copy__());
        };
        _r = (_r._mul((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())) == null ? null : _r._mul((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())).__copy__());
        var __tmp__ = _r._div(((new T_nat() : T_nat)), (_r == null ? null : _r.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__())), _r:T_nat = __tmp__._0, _r2:T_nat = __tmp__._1;
        _r2 = (_r2._add((_r2 == null ? null : _r2.__copy__()), (_r2 == null ? null : _r2.__copy__())) == null ? null : _r2._add((_r2 == null ? null : _r2.__copy__()), (_r2 == null ? null : _r2.__copy__())).__copy__());
        if (_x._b._abs._cmp((_r2 == null ? null : _r2.__copy__())) <= ((0 : GoInt))) {
            _r = (_r._add((_r == null ? null : _r.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _r._add((_r == null ? null : _r.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            if (_r._cmp((_p == null ? null : _p.__copy__())) >= ((0 : GoInt))) {
                _q = (((new T_nat() : T_nat))._add((_q == null ? null : _q.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._add((_q == null ? null : _q.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _r = (((new T_nat() : T_nat))._sub((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())).__copy__());
            };
        };
        if (_x._a._neg) {
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        _buf = (_buf != null ? _buf.__append__(..._q._utoa(((10 : GoInt))).__toArray__()) : new Slice<GoUInt8>(..._q._utoa(((10 : GoInt))).__toArray__()));
        if (_prec > ((0 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            var _rs:Slice<GoUInt8> = _r._utoa(((10 : GoInt)));
            {
                var _i:GoInt = _prec - (_rs != null ? _rs.length : ((0 : GoInt)));
                Go.cfor(_i > ((0 : GoInt)), _i--, {
                    _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                });
            };
            _buf = (_buf != null ? _buf.__append__(..._rs.__toArray__()) : new Slice<GoUInt8>(..._rs.__toArray__()));
        };
        return ((_buf : GoString));
    }
    @:keep
    public function ratString():GoString {
        var _x = this;
        _x;
        if (_x.isInt()) {
            return ((_x._a.toString() : GoString));
        };
        return ((_x.toString() : GoString));
    }
    @:keep
    public function _marshal():Slice<GoByte> {
        var _x = this;
        _x;
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        _buf = _x._a.append(_buf, ((10 : GoInt)));
        _buf = (_buf != null ? _buf.__append__(((((("/" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("/" : GoString))).code : GoRune))));
        if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) != ((0 : GoInt))) {
            _buf = _x._b.append(_buf, ((10 : GoInt)));
        } else {
            _buf = (_buf != null ? _buf.__append__(((((("1" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("1" : GoString))).code : GoRune))));
        };
        return _buf;
    }
    @:keep
    public function toString():GoString {
        var _x = this;
        _x;
        return ((_x._marshal() : GoString));
    }
    @:keep
    public function setString(_s:GoString):{ var _0 : Rat; var _1 : Bool; } {
        var _z = this;
        _z;
        if ((_s != null ? _s.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return { _0 : null, _1 : false };
        };
        {
            var _sep:GoInt = stdgo.strings.Strings.index(_s, ((("/" : GoString))));
            if (_sep >= ((0 : GoInt))) {
                {
                    var __tmp__ = _z._a.setString(((_s.__slice__(0, _sep) : GoString)), ((0 : GoInt))), _0:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : false };
                    };
                };
                var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(((_s.__slice__(_sep + ((1 : GoInt))) : GoString)));
                var _err:Error = ((null : stdgo.Error));
                {
                    {
                        var __tmp__ = _z._b._abs._scan(_r, ((0 : GoInt)), false);
                        _z._b._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _err = __tmp__._3;
                    };
                    if (_err != null) {
                        return { _0 : null, _1 : false };
                    };
                };
                {
                    {
                        var __tmp__ = _r.readByte();
                        _err = __tmp__._1;
                    };
                    if (_err != stdgo.io.Io.eof) {
                        return { _0 : null, _1 : false };
                    };
                };
                if ((_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                    return { _0 : null, _1 : false };
                };
                return { _0 : _z._norm(), _1 : true };
            };
        };
        var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_s);
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _base:GoInt = ((0 : GoInt));
        var _fcount:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _z._a._abs._scan(_r, ((0 : GoInt)), true);
            _z._a._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _base = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _exp:GoInt64 = ((0 : GoInt64));
        var _ebase:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _scanExponent(_r, true, true);
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        {
            {
                var __tmp__ = _r.readByte();
                _err = __tmp__._1;
            };
            if (_err != stdgo.io.Io.eof) {
                return { _0 : null, _1 : false };
            };
        };
        if ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return { _0 : _z, _1 : true };
        };
        var _exp2:GoInt64 = ((0 : GoInt64)), _exp5:GoInt64 = ((0 : GoInt64));
        if (_fcount < ((0 : GoInt))) {
            var _d:GoInt64 = ((_fcount : GoInt64));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _base == ((10 : GoInt)))) {
                        _exp5 = _d;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _base == ((2 : GoInt)))) {
                        _exp2 = _d;
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _base == ((8 : GoInt)))) {
                        _exp2 = _d * ((3 : GoInt64));
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _base == ((16 : GoInt)))) {
                        _exp2 = _d * ((4 : GoInt64));
                        break;
                        break;
                    } else {
                        throw Go.toInterface(((("unexpected mantissa base" : GoString))));
                        break;
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ebase == ((10 : GoInt)))) {
                    _exp5 = _exp5 + (_exp);
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ebase == ((2 : GoInt)))) {
                    _exp2 = _exp2 + (_exp);
                    break;
                    break;
                } else {
                    throw Go.toInterface(((("unexpected exponent base" : GoString))));
                    break;
                };
                break;
            };
        };
        if (_exp5 != ((0 : GoInt64))) {
            var _n:GoInt64 = _exp5;
            if (_n < ((0 : GoInt64))) {
                _n = -_n;
                if (_n < ((0 : GoInt64))) {
                    return { _0 : null, _1 : false };
                };
            };
            if (_n > ((1e+06 : GoInt64))) {
                return { _0 : null, _1 : false };
            };
            var _pow5:T_nat = (_z._b._abs._expNN((_natFive == null ? null : _natFive.__copy__()), (((new T_nat() : T_nat))._setWord(((_n : Word))) == null ? null : ((new T_nat() : T_nat))._setWord(((_n : Word))).__copy__()), null) == null ? null : _z._b._abs._expNN((_natFive == null ? null : _natFive.__copy__()), (((new T_nat() : T_nat))._setWord(((_n : Word))) == null ? null : ((new T_nat() : T_nat))._setWord(((_n : Word))).__copy__()), null).__copy__());
            if (_exp5 > ((0 : GoInt64))) {
                _z._a._abs = (_z._a._abs._mul((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_pow5 == null ? null : _pow5.__copy__())) == null ? null : _z._a._abs._mul((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_pow5 == null ? null : _pow5.__copy__())).__copy__());
                _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
            } else {
                _z._b._abs = (_pow5 == null ? null : _pow5.__copy__());
            };
        } else {
            _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        };
        if ((_exp2 < ((-10000000 : GoInt64))) || (_exp2 > ((1e+07 : GoInt64)))) {
            return { _0 : null, _1 : false };
        };
        if (_exp2 > ((0 : GoInt64))) {
            _z._a._abs = (_z._a._abs._shl((_z._a._abs == null ? null : _z._a._abs.__copy__()), ((_exp2 : GoUInt))) == null ? null : _z._a._abs._shl((_z._a._abs == null ? null : _z._a._abs.__copy__()), ((_exp2 : GoUInt))).__copy__());
        } else if (_exp2 < ((0 : GoInt64))) {
            _z._b._abs = (_z._b._abs._shl((_z._b._abs == null ? null : _z._b._abs.__copy__()), ((-_exp2 : GoUInt))) == null ? null : _z._b._abs._shl((_z._b._abs == null ? null : _z._b._abs.__copy__()), ((-_exp2 : GoUInt))).__copy__());
        };
        _z._a._neg = _neg && ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) > ((0 : GoInt)));
        return { _0 : _z._norm(), _1 : true };
    }
    @:keep
    public function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var _z = this;
        _z;
        var __tmp__ = _s.token(true, _ratTok), _tok:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return _err;
        };
        if (!stdgo.strings.Strings.containsRune(((("efgEFGv" : GoString))), _ch)) {
            return stdgo.errors.Errors.new_(((("Rat.Scan: invalid verb" : GoString))));
        };
        {
            var __tmp__ = _z.setString(((_tok : GoString))), _0:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.errors.Errors.new_(((("Rat.Scan: invalid syntax" : GoString))));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function quo(_x:Rat, _y:Rat):Rat {
        var _z = this;
        _z;
        if ((_y._a._abs != null ? _y._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _b._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a._abs = (_a._abs == null ? null : _a._abs.__copy__());
        _z._b._abs = (_b._abs == null ? null : _b._abs.__copy__());
        _z._a._neg = _a._neg != _b._neg;
        return _z._norm();
    }
    @:keep
    public function mul(_x:Rat, _y:Rat):Rat {
        var _z = this;
        _z;
        if (_x == _y) {
            _z._a._neg = false;
            _z._a._abs = (_z._a._abs._sqr((_x._a._abs == null ? null : _x._a._abs.__copy__())) == null ? null : _z._a._abs._sqr((_x._a._abs == null ? null : _x._a._abs.__copy__())).__copy__());
            if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
            } else {
                _z._b._abs = (_z._b._abs._sqr((_x._b._abs == null ? null : _x._b._abs.__copy__())) == null ? null : _z._b._abs._sqr((_x._b._abs == null ? null : _x._b._abs.__copy__())).__copy__());
            };
            return _z;
        };
        _z._a.mul(_x._a, _y._a);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function sub(_x:Rat, _y:Rat):Rat {
        var _z = this;
        _z;
        var _a1:Int_ = new Int_(), _a2:Int_ = new Int_();
        _a1._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _a2._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a.sub(_a1, _a2);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function add(_x:Rat, _y:Rat):Rat {
        var _z = this;
        _z;
        var _a1:Int_ = new Int_(), _a2:Int_ = new Int_();
        _a1._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _a2._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a.add(_a1, _a2);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function cmp(_y:Rat):GoInt {
        var _x = this;
        _x;
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _b._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        return _a.cmp(_b);
    }
    @:keep
    public function _norm():Rat {
        var _z = this;
        _z;
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                    _z._a._neg = false;
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                    _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
                    break;
                    break;
                } else {
                    var _neg:Bool = _z._a._neg;
                    _z._a._neg = false;
                    _z._b._neg = false;
                    {
                        var _f:Ref<Int_> = newInt(((0 : GoInt64)))._lehmerGCD(null, null, _z._a, _z._b);
                        if (_f.cmp(_intOne) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _z._a._abs._div(null, (_z._a._abs == null ? null : _z._a._abs.__copy__()), (_f._abs == null ? null : _f._abs.__copy__()));
                                _z._a._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            };
                            {
                                var __tmp__ = _z._b._abs._div(null, (_z._b._abs == null ? null : _z._b._abs.__copy__()), (_f._abs == null ? null : _f._abs.__copy__()));
                                _z._b._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            };
                        };
                    };
                    _z._a._neg = _neg;
                    break;
                };
                break;
            };
        };
        return _z;
    }
    @:keep
    public function denom():Int_ {
        var _x = this;
        _x;
        if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (({ _abs : ((new Slice<Word>(((1 : GoUInt))) : T_nat)), _neg : false } : Int_));
        };
        return _x._b;
    }
    @:keep
    public function num():Int_ {
        var _x = this;
        _x;
        return _x._a;
    }
    @:keep
    public function isInt():Bool {
        var _x = this;
        _x;
        return ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || (_x._b._abs._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt)));
    }
    @:keep
    public function sign():GoInt {
        var _x = this;
        _x;
        return _x._a.sign();
    }
    @:keep
    public function inv(_x:Rat):Rat {
        var _z = this;
        _z;
        if ((_x._a._abs != null ? _x._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        _z.set(_x);
        {
            final __tmp__0 = (_z._b._abs == null ? null : _z._b._abs.__copy__());
            final __tmp__1 = (_z._a._abs == null ? null : _z._a._abs.__copy__());
            _z._a._abs = __tmp__0;
            _z._b._abs = __tmp__1;
        };
        return _z;
    }
    @:keep
    public function neg(_x:Rat):Rat {
        var _z = this;
        _z;
        _z.set(_x);
        _z._a._neg = ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && !_z._a._neg;
        return _z;
    }
    @:keep
    public function abs(_x:Rat):Rat {
        var _z = this;
        _z;
        _z.set(_x);
        _z._a._neg = false;
        return _z;
    }
    @:keep
    public function set(_x:Rat):Rat {
        var _z = this;
        _z;
        if (_z != _x) {
            _z._a.set(_x._a);
            _z._b.set(_x._b);
        };
        if ((_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        };
        return _z;
    }
    @:keep
    public function setUint64(_x:GoUInt64):Rat {
        var _z = this;
        _z;
        _z._a.setUint64(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public function setInt64(_x:GoInt64):Rat {
        var _z = this;
        _z;
        _z._a.setInt64(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public function setInt(_x:Int_):Rat {
        var _z = this;
        _z;
        _z._a.set(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public function setFrac64(_a:GoInt64, _b:GoInt64):Rat {
        var _z = this;
        _z;
        if (_b == ((0 : GoInt64))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        _z._a.setInt64(_a);
        if (_b < ((0 : GoInt64))) {
            _b = -_b;
            _z._a._neg = !_z._a._neg;
        };
        _z._b._abs = (_z._b._abs._setUint64(((_b : GoUInt64))) == null ? null : _z._b._abs._setUint64(((_b : GoUInt64))).__copy__());
        return _z._norm();
    }
    @:keep
    public function setFrac(_a:Int_, _b:Int_):Rat {
        var _z = this;
        _z;
        _z._a._neg = _a._neg != _b._neg;
        var _babs:T_nat = (_b._abs == null ? null : _b._abs.__copy__());
        if ((_babs != null ? _babs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        if ((_z._a == _b) || _alias((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_babs == null ? null : _babs.__copy__()))) {
            _babs = (((new T_nat() : T_nat))._set((_babs == null ? null : _babs.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_babs == null ? null : _babs.__copy__())).__copy__());
        };
        _z._a._abs = (_z._a._abs._set((_a._abs == null ? null : _a._abs.__copy__())) == null ? null : _z._a._abs._set((_a._abs == null ? null : _a._abs.__copy__())).__copy__());
        _z._b._abs = (_z._b._abs._set((_babs == null ? null : _babs.__copy__())) == null ? null : _z._b._abs._set((_babs == null ? null : _babs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function float64():{ var _0 : GoFloat64; var _1 : Bool; } {
        var _x = this;
        _x;
        var _f:GoFloat64 = ((0 : GoFloat64)), _exact:Bool = false;
        var _b:T_nat = (_x._b._abs == null ? null : _x._b._abs.__copy__());
        if ((_b != null ? _b.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _b = (_natOne == null ? null : _natOne.__copy__());
        };
        {
            var __tmp__ = _quotToFloat64((_x._a._abs == null ? null : _x._a._abs.__copy__()), (_b == null ? null : _b.__copy__()));
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    @:keep
    public function float32():{ var _0 : GoFloat32; var _1 : Bool; } {
        var _x = this;
        _x;
        var _f:GoFloat32 = ((0 : GoFloat32)), _exact:Bool = false;
        var _b:T_nat = (_x._b._abs == null ? null : _x._b._abs.__copy__());
        if ((_b != null ? _b.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _b = (_natOne == null ? null : _natOne.__copy__());
        };
        {
            var __tmp__ = _quotToFloat32((_x._a._abs == null ? null : _x._a._abs.__copy__()), (_b == null ? null : _b.__copy__()));
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    @:keep
    public function setFloat64(_f:GoFloat64):Rat {
        var _z = this;
        _z;
        {};
        var _bits:GoUInt64 = stdgo.math.Math.float64bits(_f);
        var _mantissa:GoUInt64 = _bits & (("4503599627370495" : GoUInt64));
        var _exp:GoInt = ((((_bits >> ((52 : GoUnTypedInt))) & ((2047 : GoUInt64))) : GoInt));
        if (_exp == ((2047 : GoInt))) {
            return null;
        } else if (_exp == ((0 : GoInt))) {
            _exp = _exp - (((1022 : GoInt)));
        } else {
            _mantissa = _mantissa | ((("4503599627370496" : GoUInt64)));
            _exp = _exp - (((1023 : GoInt)));
        };
        var _shift:GoInt = ((52 : GoInt)) - _exp;
        while (((_mantissa & ((1 : GoUInt64))) == ((0 : GoUInt64))) && (_shift > ((0 : GoInt)))) {
            _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
            _shift--;
        };
        _z._a.setUint64(_mantissa);
        _z._a._neg = _f < ((0 : GoFloat64));
        _z._b.set(_intOne);
        if (_shift > ((0 : GoInt))) {
            _z._b.lsh(_z._b, ((_shift : GoUInt)));
        } else {
            _z._a.lsh(_z._a, ((-_shift : GoUInt)));
        };
        return _z._norm();
    }
    public var _a : Int_ = new Int_();
    public var _b : Int_ = new Int_();
    public function new(?_a:Int_, ?_b:Int_) {
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new Rat(_a, _b);
    }
}
@:structInit class T_ratBinArg {
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _z : GoString = (("" : GoString));
    public function new(?_x:GoString, ?_y:GoString, ?_z:GoString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_z != null) this._z = _z;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T_ratBinArg(_x, _y, _z);
    }
}
@:structInit class StringTest {
    public var _in : GoString = (("" : GoString));
    public var _out : GoString = (("" : GoString));
    public var _ok : Bool = false;
    public function new(?_in:GoString, ?_out:GoString, ?_ok:Bool) {
        if (_in != null) this._in = _in;
        if (_out != null) this._out = _out;
        if (_ok != null) this._ok = _ok;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new StringTest(_in, _out, _ok);
    }
}
@:structInit @:local class T__struct_0 {
    public var _x : Word = new Word();
    public var _y : Word = new Word();
    public var _q : Word = new Word();
    public var _r : Word = new Word();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_q) + " " + Go.string(_r) + "}";
    public function new(?_x:Word, ?_y:Word, ?_q:Word, ?_r:Word, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_q != null) this._q = _q;
        if (_r != null) this._r = _r;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_0(_x, _y, _q, _r);
    }
}
@:structInit @:local class T__struct_1 {
    public var _x : Word = new Word();
    public var _y : Word = new Word();
    public var _c : Word = new Word();
    public var _q : Word = new Word();
    public var _r : Word = new Word();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_c) + " " + Go.string(_q) + " " + Go.string(_r) + "}";
    public function new(?_x:Word, ?_y:Word, ?_c:Word, ?_q:Word, ?_r:Word, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_c != null) this._c = _c;
        if (_q != null) this._q = _q;
        if (_r != null) this._r = _r;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_1(_x, _y, _c, _q, _r);
    }
}
@:structInit @:local class T__struct_2 {
    public var _x1 : Word = new Word();
    public var _x0 : Word = new Word();
    public var _y : Word = new Word();
    public var _q : Word = new Word();
    public var _r : Word = new Word();
    public function toString():String return "{" + Go.string(_x1) + " " + Go.string(_x0) + " " + Go.string(_y) + " " + Go.string(_q) + " " + Go.string(_r) + "}";
    public function new(?_x1:Word, ?_x0:Word, ?_y:Word, ?_q:Word, ?_r:Word, ?toString) {
        if (_x1 != null) this._x1 = _x1;
        if (_x0 != null) this._x0 = _x0;
        if (_y != null) this._y = _y;
        if (_q != null) this._q = _q;
        if (_r != null) this._r = _r;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_2(_x1, _x0, _y, _q, _r);
    }
}
@:structInit @:local class T__struct_3 {
    public var _x : Bits = new Bits();
    public var _y : Bits = new Bits();
    public var _want : Bits = new Bits();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_want) + "}";
    public function new(?_x:Bits, ?_y:Bits, ?_want:Bits, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_3(_x, _y, _want);
    }
}
@:structInit @:local class T__struct_4 {
    public var _x : Bits = new Bits();
    public var _want : Bits = new Bits();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_want) + "}";
    public function new(?_x:Bits, ?_want:Bits, ?toString) {
        if (_x != null) this._x = _x;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_4(_x, _want);
    }
}
@:structInit @:local class T__struct_5 {
    public var _bits : Bits = new Bits();
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_bits) + " " + Go.string(_want) + "}";
    public function new(?_bits:Bits, ?_want:GoString, ?toString) {
        if (_bits != null) this._bits = _bits;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_5(_bits, _want);
    }
}
@:structInit @:local class T__struct_6 {
    public var _x : T_decimal = new T_decimal();
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_want) + "}";
    public function new(?_x:T_decimal, ?_want:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_6(_x, _want);
    }
}
@:structInit @:local class T__struct_7 {
    public var _x : Word = new Word();
    public var _shift : GoInt = ((0 : GoInt));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_shift) + " " + Go.string(_want) + "}";
    public function new(?_x:Word, ?_shift:GoInt, ?_want:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_shift != null) this._shift = _shift;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_7(_x, _shift, _want);
    }
}
@:structInit @:local class T__struct_8 {
    public var _x : GoUInt64 = ((0 : GoUInt64));
    public var _n : GoInt = ((0 : GoInt));
    public var _down : GoString = (("" : GoString));
    public var _even : GoString = (("" : GoString));
    public var _up : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_n) + " " + Go.string(_down) + " " + Go.string(_even) + " " + Go.string(_up) + "}";
    public function new(?_x:GoUInt64, ?_n:GoInt, ?_down:GoString, ?_even:GoString, ?_up:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_n != null) this._n = _n;
        if (_down != null) this._down = _down;
        if (_even != null) this._even = _even;
        if (_up != null) this._up = _up;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_8(_x, _n, _down, _even, _up);
    }
}
@:structInit @:local class T__struct_9 {
    public var _z : GoInt = ((0 : GoInt));
    public var _x : GoInt = ((0 : GoInt));
    public var _y : GoInt = ((0 : GoInt));
    public var _want : GoInt = ((0 : GoInt));
    public var _opname : GoInt32 = ((0 : GoInt32));
    public var _op : (Ref<Float_>, Ref<Float_>, Ref<Float_>) -> Ref<Float_> = null;
    public function toString():String return "{" + Go.string(_z) + " " + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_want) + " " + Go.string(_opname) + " " + Go.string(_op) + "}";
    public function new(?_z:GoInt, ?_x:GoInt, ?_y:GoInt, ?_want:GoInt, ?_opname:GoInt32, ?_op:(Ref<Float_>, Ref<Float_>, Ref<Float_>) -> Ref<Float_>, ?toString) {
        if (_z != null) this._z = _z;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_want != null) this._want = _want;
        if (_opname != null) this._opname = _opname;
        if (_op != null) this._op = _op;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_9(_z, _x, _y, _want, _opname, _op);
    }
}
@:structInit @:local class T__struct_10 {
    public var _x : GoString = (("" : GoString));
    public var _prec : GoUInt = ((0 : GoUInt));
    public var _want : GoString = (("" : GoString));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_prec) + " " + Go.string(_want) + " " + Go.string(_acc) + "}";
    public function new(?_x:GoString, ?_prec:GoUInt, ?_want:GoString, ?_acc:Accuracy, ?toString) {
        if (_x != null) this._x = _x;
        if (_prec != null) this._prec = _prec;
        if (_want != null) this._want = _want;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_10(_x, _prec, _want, _acc);
    }
}
@:structInit @:local class T__struct_11 {
    public var _x : GoString = (("" : GoString));
    public var _want : GoUInt = ((0 : GoUInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_want) + "}";
    public function new(?_x:GoString, ?_want:GoUInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_11(_x, _want);
    }
}
@:structInit @:local class T__struct_12 {
    public var _x : GoString = (("" : GoString));
    public var _s : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_s) + "}";
    public function new(?_x:GoString, ?_s:GoInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_s != null) this._s = _s;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_12(_x, _s);
    }
}
@:structInit @:local class T__struct_13 {
    public var _x : GoString = (("" : GoString));
    public var _mant : GoString = (("" : GoString));
    public var _exp : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_mant) + " " + Go.string(_exp) + "}";
    public function new(?_x:GoString, ?_mant:GoString, ?_exp:GoInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_mant != null) this._mant = _mant;
        if (_exp != null) this._exp = _exp;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_13(_x, _mant, _exp);
    }
}
@:structInit @:local class T__struct_14 {
    public var _frac : GoString = (("" : GoString));
    public var _exp : GoInt = ((0 : GoInt));
    public var _z : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_frac) + " " + Go.string(_exp) + " " + Go.string(_z) + "}";
    public function new(?_frac:GoString, ?_exp:GoInt, ?_z:GoString, ?toString) {
        if (_frac != null) this._frac = _frac;
        if (_exp != null) this._exp = _exp;
        if (_z != null) this._z = _z;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_14(_frac, _exp, _z);
    }
}
@:structInit @:local class T__struct_15 {
    public var _x : GoString = (("" : GoString));
    public var _sign : GoInt = ((0 : GoInt));
    public var _signbit : Bool = false;
    public var _inf : Bool = false;
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_sign) + " " + Go.string(_signbit) + " " + Go.string(_inf) + "}";
    public function new(?_x:GoString, ?_sign:GoInt, ?_signbit:Bool, ?_inf:Bool, ?toString) {
        if (_x != null) this._x = _x;
        if (_sign != null) this._sign = _sign;
        if (_signbit != null) this._signbit = _signbit;
        if (_inf != null) this._inf = _inf;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_15(_x, _sign, _signbit, _inf);
    }
}
@:structInit @:local class T__struct_16 {
    public var _prec : GoUInt = ((0 : GoUInt));
    public var _x : GoString = (("" : GoString));
    public var _zero : GoString = (("" : GoString));
    public var _neven : GoString = (("" : GoString));
    public var _naway : GoString = (("" : GoString));
    public var _away : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_prec) + " " + Go.string(_x) + " " + Go.string(_zero) + " " + Go.string(_neven) + " " + Go.string(_naway) + " " + Go.string(_away) + "}";
    public function new(?_prec:GoUInt, ?_x:GoString, ?_zero:GoString, ?_neven:GoString, ?_naway:GoString, ?_away:GoString, ?toString) {
        if (_prec != null) this._prec = _prec;
        if (_x != null) this._x = _x;
        if (_zero != null) this._zero = _zero;
        if (_neven != null) this._neven = _neven;
        if (_naway != null) this._naway = _naway;
        if (_away != null) this._away = _away;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_16(_prec, _x, _zero, _neven, _naway, _away);
    }
}
@:structInit @:local class T__struct_17 {
    public var _signbit : Bool = false;
    public var _prec : GoUInt = ((0 : GoUInt));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_signbit) + " " + Go.string(_prec) + " " + Go.string(_want) + "}";
    public function new(?_signbit:Bool, ?_prec:GoUInt, ?_want:GoString, ?toString) {
        if (_signbit != null) this._signbit = _signbit;
        if (_prec != null) this._prec = _prec;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_17(_signbit, _prec, _want);
    }
}
@:structInit @:local class T__struct_18 {
    public var _x : GoString = (("" : GoString));
    public var _out : GoUInt64 = ((0 : GoUInt64));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_out) + " " + Go.string(_acc) + "}";
    public function new(?_x:GoString, ?_out:GoUInt64, ?_acc:Accuracy, ?toString) {
        if (_x != null) this._x = _x;
        if (_out != null) this._out = _out;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_18(_x, _out, _acc);
    }
}
@:structInit @:local class T__struct_19 {
    public var _x : GoString = (("" : GoString));
    public var _out : GoInt64 = ((0 : GoInt64));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_out) + " " + Go.string(_acc) + "}";
    public function new(?_x:GoString, ?_out:GoInt64, ?_acc:Accuracy, ?toString) {
        if (_x != null) this._x = _x;
        if (_out != null) this._out = _out;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_19(_x, _out, _acc);
    }
}
@:structInit @:local class T__struct_20 {
    public var _x : GoString = (("" : GoString));
    public var _out : GoFloat32 = ((0 : GoFloat32));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_out) + " " + Go.string(_acc) + "}";
    public function new(?_x:GoString, ?_out:GoFloat32, ?_acc:Accuracy, ?toString) {
        if (_x != null) this._x = _x;
        if (_out != null) this._out = _out;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_20(_x, _out, _acc);
    }
}
@:structInit @:local class T__struct_21 {
    public var _x : GoString = (("" : GoString));
    public var _out : GoFloat64 = ((0 : GoFloat64));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_out) + " " + Go.string(_acc) + "}";
    public function new(?_x:GoString, ?_out:GoFloat64, ?_acc:Accuracy, ?toString) {
        if (_x != null) this._x = _x;
        if (_out != null) this._out = _out;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_21(_x, _out, _acc);
    }
}
@:structInit @:local class T__struct_22 {
    public var _x : GoString = (("" : GoString));
    public var _want : GoString = (("" : GoString));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_want) + " " + Go.string(_acc) + "}";
    public function new(?_x:GoString, ?_want:GoString, ?_acc:Accuracy, ?toString) {
        if (_x != null) this._x = _x;
        if (_want != null) this._want = _want;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_22(_x, _want, _acc);
    }
}
@:structInit @:local class T__struct_23 {
    public var _a : GoFloat64 = ((0 : GoFloat64));
    public var _b : GoFloat64 = ((0 : GoFloat64));
    public function toString():String return "{" + Go.string(_a) + " " + Go.string(_b) + "}";
    public function new(?_a:GoFloat64, ?_b:GoFloat64, ?toString) {
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_23(_a, _b);
    }
}
@:structInit @:local class T__struct_24 {
    public var _x : GoFloat64 = ((0 : GoFloat64));
    public var _y : GoFloat64 = ((0 : GoFloat64));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + "}";
    public function new(?_x:GoFloat64, ?_y:GoFloat64, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_24(_x, _y);
    }
}
@:structInit @:local class T__struct_25 {
    public var _prec : GoUInt = ((0 : GoUInt));
    public var _mode : RoundingMode = new RoundingMode();
    public var _op : GoUInt8 = ((0 : GoUInt8));
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _want : GoString = (("" : GoString));
    public var _acc : Accuracy = new Accuracy();
    public function toString():String return "{" + Go.string(_prec) + " " + Go.string(_mode) + " " + Go.string(_op) + " " + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_want) + " " + Go.string(_acc) + "}";
    public function new(?_prec:GoUInt, ?_mode:RoundingMode, ?_op:GoUInt8, ?_x:GoString, ?_y:GoString, ?_want:GoString, ?_acc:Accuracy, ?toString) {
        if (_prec != null) this._prec = _prec;
        if (_mode != null) this._mode = _mode;
        if (_op != null) this._op = _op;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_want != null) this._want = _want;
        if (_acc != null) this._acc = _acc;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_25(_prec, _mode, _op, _x, _y, _want, _acc);
    }
}
@:structInit @:local class T__struct_26 {
    public var _mode : RoundingMode = new RoundingMode();
    public var _prec : GoUInt = ((0 : GoUInt));
    public var _x : GoInt64 = ((0 : GoInt64));
    public var _y : GoInt64 = ((0 : GoInt64));
    public var _want : GoInt64 = ((0 : GoInt64));
    public var _op : GoUInt8 = ((0 : GoUInt8));
    public function toString():String return "{" + Go.string(_mode) + " " + Go.string(_prec) + " " + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_want) + " " + Go.string(_op) + "}";
    public function new(?_mode:RoundingMode, ?_prec:GoUInt, ?_x:GoInt64, ?_y:GoInt64, ?_want:GoInt64, ?_op:GoUInt8, ?toString) {
        if (_mode != null) this._mode = _mode;
        if (_prec != null) this._prec = _prec;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_want != null) this._want = _want;
        if (_op != null) this._op = _op;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_26(_mode, _prec, _x, _y, _want, _op);
    }
}
@:structInit @:local class T__struct_27 {
    public var _s : GoString = (("" : GoString));
    public var _x : GoFloat64 = ((0 : GoFloat64));
    public function toString():String return "{" + Go.string(_s) + " " + Go.string(_x) + "}";
    public function new(?_s:GoString, ?_x:GoFloat64, ?toString) {
        if (_s != null) this._s = _s;
        if (_x != null) this._x = _x;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_27(_s, _x);
    }
}
@:structInit @:local class T__struct_28 {
    public var _x : GoFloat64 = ((0 : GoFloat64));
    public var _format : GoUInt8 = ((0 : GoUInt8));
    public var _prec : GoInt = ((0 : GoInt));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_format) + " " + Go.string(_prec) + " " + Go.string(_want) + "}";
    public function new(?_x:GoFloat64, ?_format:GoUInt8, ?_prec:GoInt, ?_want:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_format != null) this._format = _format;
        if (_prec != null) this._prec = _prec;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_28(_x, _format, _prec, _want);
    }
}
@:structInit @:local class T__struct_29 {
    public var _x : GoString = (("" : GoString));
    public var _round : RoundingMode = new RoundingMode();
    public var _prec : GoUInt = ((0 : GoUInt));
    public var _format : GoUInt8 = ((0 : GoUInt8));
    public var _digits : GoInt = ((0 : GoInt));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_round) + " " + Go.string(_prec) + " " + Go.string(_format) + " " + Go.string(_digits) + " " + Go.string(_want) + "}";
    public function new(?_x:GoString, ?_round:RoundingMode, ?_prec:GoUInt, ?_format:GoUInt8, ?_digits:GoInt, ?_want:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_round != null) this._round = _round;
        if (_prec != null) this._prec = _prec;
        if (_format != null) this._format = _format;
        if (_digits != null) this._digits = _digits;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_29(_x, _round, _prec, _format, _digits, _want);
    }
}
@:structInit @:local class T__struct_30 {
    public var _format : GoString = (("" : GoString));
    public var _value : AnyInterface = ((null : AnyInterface));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_format) + " " + Go.string(_value) + " " + Go.string(_want) + "}";
    public function new(?_format:GoString, ?_value:AnyInterface, ?_want:GoString, ?toString) {
        if (_format != null) this._format = _format;
        if (_value != null) this._value = _value;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_30(_format, _value, _want);
    }
}
@:structInit @:local class T__struct_31 {
    public var _input : GoString = (("" : GoString));
    public var _format : GoString = (("" : GoString));
    public var _output : GoString = (("" : GoString));
    public var _remaining : GoInt = ((0 : GoInt));
    public var _wantErr : Bool = false;
    public function toString():String return "{" + Go.string(_input) + " " + Go.string(_format) + " " + Go.string(_output) + " " + Go.string(_remaining) + " " + Go.string(_wantErr) + "}";
    public function new(?_input:GoString, ?_format:GoString, ?_output:GoString, ?_remaining:GoInt, ?_wantErr:Bool, ?toString) {
        if (_input != null) this._input = _input;
        if (_format != null) this._format = _format;
        if (_output != null) this._output = _output;
        if (_remaining != null) this._remaining = _remaining;
        if (_wantErr != null) this._wantErr = _wantErr;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_31(_input, _format, _output, _remaining, _wantErr);
    }
}
@:structInit @:local class T__struct_32 {
    public var _a : GoInt64 = ((0 : GoInt64));
    public var _b : GoInt64 = ((0 : GoInt64));
    public var _prod : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_a) + " " + Go.string(_b) + " " + Go.string(_prod) + "}";
    public function new(?_a:GoInt64, ?_b:GoInt64, ?_prod:GoString, ?toString) {
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
        if (_prod != null) this._prod = _prod;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_32(_a, _b, _prod);
    }
}
@:structInit @:local class T__struct_33 {
    public var _n : GoInt64 = ((0 : GoInt64));
    public var _k : GoInt64 = ((0 : GoInt64));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_n) + " " + Go.string(_k) + " " + Go.string(_want) + "}";
    public function new(?_n:GoInt64, ?_k:GoInt64, ?_want:GoString, ?toString) {
        if (_n != null) this._n = _n;
        if (_k != null) this._k = _k;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_33(_n, _k, _want);
    }
}
@:structInit @:local class T__struct_34 {
    public var _x : GoInt64 = ((0 : GoInt64));
    public var _y : GoInt64 = ((0 : GoInt64));
    public var _q : GoInt64 = ((0 : GoInt64));
    public var _r : GoInt64 = ((0 : GoInt64));
    public var _d : GoInt64 = ((0 : GoInt64));
    public var _m : GoInt64 = ((0 : GoInt64));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_q) + " " + Go.string(_r) + " " + Go.string(_d) + " " + Go.string(_m) + "}";
    public function new(?_x:GoInt64, ?_y:GoInt64, ?_q:GoInt64, ?_r:GoInt64, ?_d:GoInt64, ?_m:GoInt64, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_q != null) this._q = _q;
        if (_r != null) this._r = _r;
        if (_d != null) this._d = _d;
        if (_m != null) this._m = _m;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_34(_x, _y, _q, _r, _d, _m);
    }
}
@:structInit @:local class T__struct_35 {
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _q : GoString = (("" : GoString));
    public var _r : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_q) + " " + Go.string(_r) + "}";
    public function new(?_x:GoString, ?_y:GoString, ?_q:GoString, ?_r:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_q != null) this._q = _q;
        if (_r != null) this._r = _r;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_35(_x, _y, _q, _r);
    }
}
@:structInit @:local class T__struct_36 {
    public var _in : GoString = (("" : GoString));
    public var _out : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_in) + " " + Go.string(_out) + "}";
    public function new(?_in:GoString, ?_out:GoInt, ?toString) {
        if (_in != null) this._in = _in;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_36(_in, _out);
    }
}
@:structInit @:local class T__struct_37 {
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _m : GoString = (("" : GoString));
    public var _out : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_m) + " " + Go.string(_out) + "}";
    public function new(?_x:GoString, ?_y:GoString, ?_m:GoString, ?_out:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_m != null) this._m = _m;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_37(_x, _y, _m, _out);
    }
}
@:structInit @:local class T__struct_38 {
    public var _d : GoString = (("" : GoString));
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _a : GoString = (("" : GoString));
    public var _b : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_d) + " " + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_a) + " " + Go.string(_b) + "}";
    public function new(?_d:GoString, ?_x:GoString, ?_y:GoString, ?_a:GoString, ?_b:GoString, ?toString) {
        if (_d != null) this._d = _d;
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_38(_d, _x, _y, _a, _b);
    }
}
@:structInit @:local class T__struct_39 {
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _and : GoString = (("" : GoString));
    public var _or : GoString = (("" : GoString));
    public var _xor : GoString = (("" : GoString));
    public var _andNot : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_and) + " " + Go.string(_or) + " " + Go.string(_xor) + " " + Go.string(_andNot) + "}";
    public function new(?_x:GoString, ?_y:GoString, ?_and:GoString, ?_or:GoString, ?_xor:GoString, ?_andNot:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_and != null) this._and = _and;
        if (_or != null) this._or = _or;
        if (_xor != null) this._xor = _xor;
        if (_andNot != null) this._andNot = _andNot;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_39(_x, _y, _and, _or, _xor, _andNot);
    }
}
@:structInit @:local class T__struct_40 {
    public var _x : GoString = (("" : GoString));
    public var _i : GoInt = ((0 : GoInt));
    public var _b : GoUInt = ((0 : GoUInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_i) + " " + Go.string(_b) + "}";
    public function new(?_x:GoString, ?_i:GoInt, ?_b:GoUInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_i != null) this._i = _i;
        if (_b != null) this._b = _b;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_40(_x, _i, _b);
    }
}
@:structInit @:local class T__struct_41 {
    public var _in : GoString = (("" : GoString));
    public var _out : GoUInt = ((0 : GoUInt));
    public function toString():String return "{" + Go.string(_in) + " " + Go.string(_out) + "}";
    public function new(?_in:GoString, ?_out:GoUInt, ?toString) {
        if (_in != null) this._in = _in;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_41(_in, _out);
    }
}
@:structInit @:local class T__struct_42 {
    public var _in : GoString = (("" : GoString));
    public var _out : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_in) + " " + Go.string(_out) + "}";
    public function new(?_in:GoString, ?_out:GoString, ?toString) {
        if (_in != null) this._in = _in;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_42(_in, _out);
    }
}
@:structInit @:local class T__struct_43 {
    public var _element : GoString = (("" : GoString));
    public var _modulus : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_element) + " " + Go.string(_modulus) + "}";
    public function new(?_element:GoString, ?_modulus:GoString, ?toString) {
        if (_element != null) this._element = _element;
        if (_modulus != null) this._modulus = _modulus;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_43(_element, _modulus);
    }
}
@:structInit @:local class T__struct_44 {
    public var _x : GoInt64 = ((0 : GoInt64));
    public var _y : GoInt64 = ((0 : GoInt64));
    public var _result : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_result) + "}";
    public function new(?_x:GoInt64, ?_y:GoInt64, ?_result:GoInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_result != null) this._result = _result;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_44(_x, _y, _result);
    }
}
@:structInit @:local class T__struct_45 {
    public var _in : GoString = (("" : GoString));
    public var _out : GoString = (("" : GoString));
    public var _base : GoInt = ((0 : GoInt));
    public var _val : GoInt64 = ((0 : GoInt64));
    public var _ok : Bool = false;
    public function toString():String return "{" + Go.string(_in) + " " + Go.string(_out) + " " + Go.string(_base) + " " + Go.string(_val) + " " + Go.string(_ok) + "}";
    public function new(?_in:GoString, ?_out:GoString, ?_base:GoInt, ?_val:GoInt64, ?_ok:Bool, ?toString) {
        if (_in != null) this._in = _in;
        if (_out != null) this._out = _out;
        if (_base != null) this._base = _base;
        if (_val != null) this._val = _val;
        if (_ok != null) this._ok = _ok;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_45(_in, _out, _base, _val, _ok);
    }
}
@:structInit @:local class T__struct_46 {
    public var _input : GoString = (("" : GoString));
    public var _format : GoString = (("" : GoString));
    public var _output : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_input) + " " + Go.string(_format) + " " + Go.string(_output) + "}";
    public function new(?_input:GoString, ?_format:GoString, ?_output:GoString, ?toString) {
        if (_input != null) this._input = _input;
        if (_format != null) this._format = _format;
        if (_output != null) this._output = _output;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_46(_input, _format, _output);
    }
}
@:structInit @:local class T__struct_47 {
    public var _input : GoString = (("" : GoString));
    public var _format : GoString = (("" : GoString));
    public var _output : GoString = (("" : GoString));
    public var _remaining : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_input) + " " + Go.string(_format) + " " + Go.string(_output) + " " + Go.string(_remaining) + "}";
    public function new(?_input:GoString, ?_format:GoString, ?_output:GoString, ?_remaining:GoInt, ?toString) {
        if (_input != null) this._input = _input;
        if (_format != null) this._format = _format;
        if (_output != null) this._output = _output;
        if (_remaining != null) this._remaining = _remaining;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_47(_input, _format, _output, _remaining);
    }
}
@:structInit @:local class T__struct_48 {
    public var _x : T_nat = new T_nat();
    public var _y : T_nat = new T_nat();
    public var _r : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_r) + "}";
    public function new(?_x:T_nat, ?_y:T_nat, ?_r:GoInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_r != null) this._r = _r;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_48(_x, _y, _r);
    }
}
@:structInit @:local class T__struct_49 {
    public var _a : GoUInt64 = ((0 : GoUInt64));
    public var _b : GoUInt64 = ((0 : GoUInt64));
    public var _prod : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_a) + " " + Go.string(_b) + " " + Go.string(_prod) + "}";
    public function new(?_a:GoUInt64, ?_b:GoUInt64, ?_prod:GoString, ?toString) {
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
        if (_prod != null) this._prod = _prod;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_49(_a, _b, _prod);
    }
}
@:structInit @:local class T__struct_50 {
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _m : GoString = (("" : GoString));
    public var _k0 : GoUInt64 = ((0 : GoUInt64));
    public var _out32 : GoString = (("" : GoString));
    public var _out64 : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_m) + " " + Go.string(_k0) + " " + Go.string(_out32) + " " + Go.string(_out64) + "}";
    public function new(?_x:GoString, ?_y:GoString, ?_m:GoString, ?_k0:GoUInt64, ?_out32:GoString, ?_out64:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_m != null) this._m = _m;
        if (_k0 != null) this._k0 = _k0;
        if (_out32 != null) this._out32 = _out32;
        if (_out64 != null) this._out64 = _out64;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_50(_x, _y, _m, _k0, _out32, _out64);
    }
}
@:structInit @:local class T__struct_51 {
    public var _x : GoString = (("" : GoString));
    public var _i : GoUInt = ((0 : GoUInt));
    public var _want : GoUInt = ((0 : GoUInt));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_i) + " " + Go.string(_want) + "}";
    public function new(?_x:GoString, ?_i:GoUInt, ?_want:GoUInt, ?toString) {
        if (_x != null) this._x = _x;
        if (_i != null) this._i = _i;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_51(_x, _i, _want);
    }
}
@:structInit @:local class T__struct_52 {
    @:embedded
    public var mutex : stdgo.sync.Sync.Mutex = new stdgo.sync.Sync.Mutex();
    public var _table : GoArray<T_divisor> = new GoArray<T_divisor>(...[for (i in 0 ... 64) new T_divisor()]);
    public function toString():String return "{" + Go.string(mutex) + " " + Go.string(_table) + "}";
    public function new(?mutex:stdgo.sync.Sync.Mutex, ?_table:GoArray<T_divisor>, ?toString) {
        if (mutex != null) this.mutex = mutex;
        if (_table != null) this._table = _table;
    }
    public function lock() mutex.lock();
    public function tryLock():Bool return mutex.tryLock();
    public function unlock() mutex.unlock();
    public function _lockSlow() mutex._lockSlow();
    public function _unlockSlow(_new:GoInt32) mutex._unlockSlow(_new);
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_52(mutex, _table);
    }
}
@:structInit @:local class T__struct_53 {
    public var _x : T_nat = new T_nat();
    public var _b : GoInt = ((0 : GoInt));
    public var _s : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_b) + " " + Go.string(_s) + "}";
    public function new(?_x:T_nat, ?_b:GoInt, ?_s:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_b != null) this._b = _b;
        if (_s != null) this._s = _s;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_53(_x, _b, _s);
    }
}
@:structInit @:local class T__struct_54 {
    public var _s : GoString = (("" : GoString));
    public var _base : GoInt = ((0 : GoInt));
    public var _frac : Bool = false;
    public var _x : T_nat = new T_nat();
    public var _b : GoInt = ((0 : GoInt));
    public var _count : GoInt = ((0 : GoInt));
    public var _err : stdgo.Error = ((null : stdgo.Error));
    public var _next : GoInt32 = ((0 : GoInt32));
    public function toString():String return "{" + Go.string(_s) + " " + Go.string(_base) + " " + Go.string(_frac) + " " + Go.string(_x) + " " + Go.string(_b) + " " + Go.string(_count) + " " + Go.string(_err) + " " + Go.string(_next) + "}";
    public function new(?_s:GoString, ?_base:GoInt, ?_frac:Bool, ?_x:T_nat, ?_b:GoInt, ?_count:GoInt, ?_err:stdgo.Error, ?_next:GoInt32, ?toString) {
        if (_s != null) this._s = _s;
        if (_base != null) this._base = _base;
        if (_frac != null) this._frac = _frac;
        if (_x != null) this._x = _x;
        if (_b != null) this._b = _b;
        if (_count != null) this._count = _count;
        if (_err != null) this._err = _err;
        if (_next != null) this._next = _next;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_54(_s, _base, _frac, _x, _b, _count, _err, _next);
    }
}
@:structInit @:local class T__struct_55 {
    public var _rat1 : GoString = (("" : GoString));
    public var _rat2 : GoString = (("" : GoString));
    public var _out : GoInt = ((0 : GoInt));
    public function toString():String return "{" + Go.string(_rat1) + " " + Go.string(_rat2) + " " + Go.string(_out) + "}";
    public function new(?_rat1:GoString, ?_rat2:GoString, ?_out:GoInt, ?toString) {
        if (_rat1 != null) this._rat1 = _rat1;
        if (_rat2 != null) this._rat2 = _rat2;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_55(_rat1, _rat2, _out);
    }
}
@:structInit @:local class T__struct_56 {
    public var _x : GoString = (("" : GoString));
    public var _y : GoString = (("" : GoString));
    public var _sum : GoString = (("" : GoString));
    public var _prod : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_y) + " " + Go.string(_sum) + " " + Go.string(_prod) + "}";
    public function new(?_x:GoString, ?_y:GoString, ?_sum:GoString, ?_prod:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_y != null) this._y = _y;
        if (_sum != null) this._sum = _sum;
        if (_prod != null) this._prod = _prod;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_56(_x, _y, _sum, _prod);
    }
}
@:structInit @:local class T__struct_57 {
    public var _a : GoInt64 = ((0 : GoInt64));
    public var _b : GoInt64 = ((0 : GoInt64));
    public var _out : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_a) + " " + Go.string(_b) + " " + Go.string(_out) + "}";
    public function new(?_a:GoInt64, ?_b:GoInt64, ?_out:GoString, ?toString) {
        if (_a != null) this._a = _a;
        if (_b != null) this._b = _b;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_57(_a, _b, _out);
    }
}
@:structInit @:local class T__struct_58 {
    public var _name : GoString = (("" : GoString));
    public var _f : Ref<Rat> -> Void = null;
    public function toString():String return "{" + Go.string(_name) + " " + Go.string(_f) + "}";
    public function new(?_name:GoString, ?_f:Ref<Rat> -> Void, ?toString) {
        if (_name != null) this._name = _name;
        if (_f != null) this._f = _f;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_58(_name, _f);
    }
}
@:structInit @:local class T__struct_59 {
    public var _s : GoString = (("" : GoString));
    public var _base2ok : Bool = false;
    public var _sepOk : Bool = false;
    public var _x : GoInt64 = ((0 : GoInt64));
    public var _b : GoInt = ((0 : GoInt));
    public var _err : stdgo.Error = ((null : stdgo.Error));
    public var _next : GoInt32 = ((0 : GoInt32));
    public function toString():String return "{" + Go.string(_s) + " " + Go.string(_base2ok) + " " + Go.string(_sepOk) + " " + Go.string(_x) + " " + Go.string(_b) + " " + Go.string(_err) + " " + Go.string(_next) + "}";
    public function new(?_s:GoString, ?_base2ok:Bool, ?_sepOk:Bool, ?_x:GoInt64, ?_b:GoInt, ?_err:stdgo.Error, ?_next:GoInt32, ?toString) {
        if (_s != null) this._s = _s;
        if (_base2ok != null) this._base2ok = _base2ok;
        if (_sepOk != null) this._sepOk = _sepOk;
        if (_x != null) this._x = _x;
        if (_b != null) this._b = _b;
        if (_err != null) this._err = _err;
        if (_next != null) this._next = _next;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_59(_s, _base2ok, _sepOk, _x, _b, _err, _next);
    }
}
@:structInit @:local class T__struct_60 {
    public var _in : GoString = (("" : GoString));
    public var _prec : GoInt = ((0 : GoInt));
    public var _out : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_in) + " " + Go.string(_prec) + " " + Go.string(_out) + "}";
    public function new(?_in:GoString, ?_prec:GoInt, ?_out:GoString, ?toString) {
        if (_in != null) this._in = _in;
        if (_prec != null) this._prec = _prec;
        if (_out != null) this._out = _out;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_60(_in, _prec, _out);
    }
}
@:structInit @:local class T__struct_61 {
    public var _input : GoString = (("" : GoString));
    public var _want : Bool = false;
    public function toString():String return "{" + Go.string(_input) + " " + Go.string(_want) + "}";
    public function new(?_input:GoString, ?_want:Bool, ?toString) {
        if (_input != null) this._input = _input;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_61(_input, _want);
    }
}
@:structInit @:local class T__struct_62 {
    @:embedded
    public var once : stdgo.sync.Sync.Once = new stdgo.sync.Sync.Once();
    public var _v : Ref<Float_> = ((null : Ref<Float_>));
    public function toString():String return "{" + Go.string(once) + " " + Go.string(_v) + "}";
    public function new(?once:stdgo.sync.Sync.Once, ?_v:Ref<Float_>, ?toString) {
        if (once != null) this.once = once;
        if (_v != null) this._v = _v;
    }
    public function do_(_f:() -> Void) once.do_(_f);
    public function _doSlow(_f:() -> Void) once._doSlow(_f);
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_62(once, _v);
    }
}
@:structInit @:local class T__struct_63 {
    public var _x : GoString = (("" : GoString));
    public var _want : GoString = (("" : GoString));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_want) + "}";
    public function new(?_x:GoString, ?_want:GoString, ?toString) {
        if (_x != null) this._x = _x;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_63(_x, _want);
    }
}
@:structInit @:local class T__struct_64 {
    public var _x : Ref<Float_> = ((null : Ref<Float_>));
    public var _want : Ref<Float_> = ((null : Ref<Float_>));
    public function toString():String return "{" + Go.string(_x) + " " + Go.string(_want) + "}";
    public function new(?_x:Ref<Float_>, ?_want:Ref<Float_>, ?toString) {
        if (_x != null) this._x = _x;
        if (_want != null) this._want = _want;
    }
    public function __underlying__():AnyInterface return Go.toInterface(this);
    public function __copy__() {
        return new T__struct_64(_x, _want);
    }
}
@:named typedef Word = GoUInt;
@:named typedef T_funVV = (Slice<Word>, Slice<Word>, Slice<Word>) -> Word;
@:named typedef T_funVW = (Slice<Word>, Slice<Word>, Word) -> Word;
@:named typedef T_funVWW = (Slice<Word>, Slice<Word>, Word, Word) -> Word;
@:named typedef T_funWVW = (Slice<Word>, Word, Slice<Word>, Word) -> Word;
@:named @:using(stdgo.math.big.Big.Bits_static_extension) typedef Bits = Slice<GoInt>;
@:named typedef T_form = GoUInt8;
@:named @:using(stdgo.math.big.Big.RoundingMode_static_extension) typedef RoundingMode = GoUInt8;
@:named @:using(stdgo.math.big.Big.Accuracy_static_extension) typedef Accuracy = GoInt8;
@:named typedef T_funZZ = (Ref<Int_>, Ref<Int_>, Ref<Int_>) -> Ref<Int_>;
@:named typedef T_bitFun = (Ref<Int_>, Ref<Int_>, Ref<Int_>) -> Ref<Int_>;
@:named @:using(stdgo.math.big.Big.T_nat_static_extension) typedef T_nat = Slice<Word>;
@:named typedef T_funNN = (T_nat, T_nat, T_nat) -> T_nat;
@:named typedef T_ratBinFun = (Ref<Rat>, Ref<Rat>, Ref<Rat>) -> Ref<Rat>;
function _mulWW_g(_x:Word, _y:Word):{ var _0 : Word; var _1 : Word; } {
        var _z1:Word = new Word(), _z0:Word = new Word();
        var __tmp__ = stdgo.math.bits.Bits.mul(((_x : GoUInt)), ((_y : GoUInt))), _hi:GoUInt = __tmp__._0, _lo:GoUInt = __tmp__._1;
        return { _0 : ((_hi : Word)), _1 : ((_lo : Word)) };
    }
function _mulAddWWW_g(_x:Word, _y:Word, _c:Word):{ var _0 : Word; var _1 : Word; } {
        var _z1:Word = new Word(), _z0:Word = new Word();
        var __tmp__ = stdgo.math.bits.Bits.mul(((_x : GoUInt)), ((_y : GoUInt))), _hi:GoUInt = __tmp__._0, _lo:GoUInt = __tmp__._1;
        var _cc:GoUInt = ((0 : GoUInt));
        {
            var __tmp__ = stdgo.math.bits.Bits.add(_lo, ((_c : GoUInt)), ((0 : GoUInt)));
            _lo = __tmp__._0;
            _cc = __tmp__._1;
        };
        return { _0 : (((_hi + _cc) : Word)), _1 : ((_lo : Word)) };
    }
function _nlz(_x:Word):GoUInt {
        return ((stdgo.math.bits.Bits.leadingZeros(((_x : GoUInt))) : GoUInt));
    }
function _addVV_g(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = new Word();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt))))) && (_i < (_y != null ? _y.length : ((0 : GoInt)))), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.add((((_x != null ? _x[_i] : new Word()) : GoUInt)), (((_y != null ? _y[_i] : new Word()) : GoUInt)), ((_c : GoUInt))), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                if (_z != null) _z[_i] = ((_zi : Word));
                _c = ((_cc : Word));
            });
        };
        return _c;
    }
function _subVV_g(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = new Word();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt))))) && (_i < (_y != null ? _y.length : ((0 : GoInt)))), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.sub((((_x != null ? _x[_i] : new Word()) : GoUInt)), (((_y != null ? _y[_i] : new Word()) : GoUInt)), ((_c : GoUInt))), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                if (_z != null) _z[_i] = ((_zi : Word));
                _c = ((_cc : Word));
            });
        };
        return _c;
    }
function _addVW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        _c = _y;
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt)))), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.add((((_x != null ? _x[_i] : new Word()) : GoUInt)), ((_c : GoUInt)), ((0 : GoUInt))), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                if (_z != null) _z[_i] = ((_zi : Word));
                _c = ((_cc : Word));
            });
        };
        return _c;
    }
function _addVWlarge(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        _c = _y;
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt)))), _i++, {
                if (_c == ((0 : GoUInt))) {
                    Go.copySlice(((_z.__slice__(_i) : Slice<Word>)), ((_x.__slice__(_i) : Slice<Word>)));
                    return _c;
                };
                var __tmp__ = stdgo.math.bits.Bits.add((((_x != null ? _x[_i] : new Word()) : GoUInt)), ((_c : GoUInt)), ((0 : GoUInt))), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                if (_z != null) _z[_i] = ((_zi : Word));
                _c = ((_cc : Word));
            });
        };
        return _c;
    }
function _subVW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        _c = _y;
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt)))), _i++, {
                var __tmp__ = stdgo.math.bits.Bits.sub((((_x != null ? _x[_i] : new Word()) : GoUInt)), ((_c : GoUInt)), ((0 : GoUInt))), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                if (_z != null) _z[_i] = ((_zi : Word));
                _c = ((_cc : Word));
            });
        };
        return _c;
    }
function _subVWlarge(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        _c = _y;
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt)))), _i++, {
                if (_c == ((0 : GoUInt))) {
                    Go.copySlice(((_z.__slice__(_i) : Slice<Word>)), ((_x.__slice__(_i) : Slice<Word>)));
                    return _c;
                };
                var __tmp__ = stdgo.math.bits.Bits.sub((((_x != null ? _x[_i] : new Word()) : GoUInt)), ((_c : GoUInt)), ((0 : GoUInt))), _zi:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                if (_z != null) _z[_i] = ((_zi : Word));
                _c = ((_cc : Word));
            });
        };
        return _c;
    }
function _shlVU_g(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = new Word();
        if (_s == ((0 : GoUInt))) {
            Go.copySlice(_z, _x);
            return _c;
        };
        if ((_z != null ? _z.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return _c;
        };
        _s = _s & (((31 : GoUInt)));
        var __349:GoUInt = ((32 : GoUInt)) - _s;
        __349 = __349 & (((31 : GoUInt)));
        _c = (_x != null ? _x[(_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) >> __349;
        {
            var _i:GoInt = (_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_i > ((0 : GoInt)), _i--, {
                if (_z != null) _z[_i] = ((_x != null ? _x[_i] : new Word()) << _s) | ((_x != null ? _x[_i - ((1 : GoInt))] : new Word()) >> __349);
            });
        };
        if (_z != null) _z[((0 : GoInt))] = (_x != null ? _x[((0 : GoInt))] : new Word()) << _s;
        return _c;
    }
function _shrVU_g(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = new Word();
        if (_s == ((0 : GoUInt))) {
            Go.copySlice(_z, _x);
            return _c;
        };
        if ((_z != null ? _z.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return _c;
        };
        if ((_x != null ? _x.length : ((0 : GoInt))) != (_z != null ? _z.length : ((0 : GoInt)))) {
            throw Go.toInterface(((("len(x) != len(z)" : GoString))));
        };
        _s = _s & (((31 : GoUInt)));
        var __349:GoUInt = ((32 : GoUInt)) - _s;
        __349 = __349 & (((31 : GoUInt)));
        _c = (_x != null ? _x[((0 : GoInt))] : new Word()) << __349;
        {
            var _i:GoInt = ((1 : GoInt));
            Go.cfor(_i < (_z != null ? _z.length : ((0 : GoInt))), _i++, {
                if (_z != null) _z[_i - ((1 : GoInt))] = ((_x != null ? _x[_i - ((1 : GoInt))] : new Word()) >> _s) | ((_x != null ? _x[_i] : new Word()) << __349);
            });
        };
        if (_z != null) _z[(_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt))] = (_x != null ? _x[(_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) >> _s;
        return _c;
    }
function _mulAddVWW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word, _r:Word):Word {
        var _c:Word = new Word();
        _c = _r;
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt)))), _i++, {
                {
                    var __tmp__ = _mulAddWWW_g((_x != null ? _x[_i] : new Word()), _y, _c);
                    _c = __tmp__._0;
                    if (_z != null) _z[_i] = __tmp__._1;
                };
            });
        };
        return _c;
    }
function _addMulVVW_g(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor((_i < (_z != null ? _z.length : ((0 : GoInt)))) && (_i < (_x != null ? _x.length : ((0 : GoInt)))), _i++, {
                var __tmp__ = _mulAddWWW_g((_x != null ? _x[_i] : new Word()), _y, (_z != null ? _z[_i] : new Word())), _z1:Word = __tmp__._0, _z0:Word = __tmp__._1;
                var __tmp__ = stdgo.math.bits.Bits.add(((_z0 : GoUInt)), ((_c : GoUInt)), ((0 : GoUInt))), _lo:GoUInt = __tmp__._0, _cc:GoUInt = __tmp__._1;
                {
                    final __tmp__0 = ((_cc : Word));
                    final __tmp__1 = ((_lo : Word));
                    _c = __tmp__0;
                    if (_z != null) _z[_i] = __tmp__1;
                };
                _c = _c + (_z1);
            });
        };
        return _c;
    }
function _divWW(_x1:Word, _x0:Word, _y:Word, _m:Word):{ var _0 : Word; var _1 : Word; } {
        var _q:Word = new Word(), _r:Word = new Word();
        var _s:GoUInt = _nlz(_y);
        if (_s != ((0 : GoUInt))) {
            _x1 = (_x1 << _s) | (_x0 >> (((32 : GoUInt)) - _s));
            _x0 = _x0 << (_s);
            _y = _y << (_s);
        };
        var _d:GoUInt = ((_y : GoUInt));
        var __tmp__ = stdgo.math.bits.Bits.mul(((_m : GoUInt)), ((_x1 : GoUInt))), _t1:GoUInt = __tmp__._0, _t0:GoUInt = __tmp__._1;
        var __tmp__ = stdgo.math.bits.Bits.add(_t0, ((_x0 : GoUInt)), ((0 : GoUInt))), _0:GoUInt = __tmp__._0, _c:GoUInt = __tmp__._1;
        {
            var __tmp__ = stdgo.math.bits.Bits.add(_t1, ((_x1 : GoUInt)), _c);
            _t1 = __tmp__._0;
        };
        var _qq:GoUInt = _t1;
        var __tmp__ = stdgo.math.bits.Bits.mul(_d, _qq), _dq1:GoUInt = __tmp__._0, _dq0:GoUInt = __tmp__._1;
        var __tmp__ = stdgo.math.bits.Bits.sub(((_x0 : GoUInt)), _dq0, ((0 : GoUInt))), _r0:GoUInt = __tmp__._0, _b:GoUInt = __tmp__._1;
        var __tmp__ = stdgo.math.bits.Bits.sub(((_x1 : GoUInt)), _dq1, _b), _r1:GoUInt = __tmp__._0, _1:GoUInt = __tmp__._1;
        if (_r1 != ((0 : GoUInt))) {
            _qq++;
            _r0 = _r0 - (_d);
        };
        if (_r0 >= _d) {
            _qq++;
            _r0 = _r0 - (_d);
        };
        return { _0 : ((_qq : Word)), _1 : (((_r0 >> _s) : Word)) };
    }
function _reciprocalWord(_d1:Word):Word {
        var _u:GoUInt = (((_d1 << _nlz(_d1)) : GoUInt));
        var _x1:GoUInt = (-1 ^ _u);
        var _x0:GoUInt = (((("4294967295" : GoUInt)) : GoUInt));
        var __tmp__ = stdgo.math.bits.Bits.div(_x1, _x0, _u), _rec:GoUInt = __tmp__._0, _0:GoUInt = __tmp__._1;
        return ((_rec : Word));
    }
function _mulWW(_x:Word, _y:Word):{ var _0 : Word; var _1 : Word; } {
        var _z1:Word = new Word(), _z0:Word = new Word();
        return _mulWW_g(_x, _y);
    }
function _addVV(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = new Word();
        return _addVV_g(_z, _x, _y);
    }
function _subVV(_z:Slice<Word>, _x:Slice<Word>, _y:Slice<Word>):Word {
        var _c:Word = new Word();
        return _subVV_g(_z, _x, _y);
    }
function _addVW(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        var _fn:(Slice<Word>, Slice<Word>, Word) -> Word = _addVW_g;
        if ((_z != null ? _z.length : ((0 : GoInt))) > ((32 : GoInt))) {
            _fn = _addVWlarge;
        };
        return _fn(_z, _x, _y);
    }
function _subVW(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        var _fn:(Slice<Word>, Slice<Word>, Word) -> Word = _subVW_g;
        if ((_z != null ? _z.length : ((0 : GoInt))) > ((32 : GoInt))) {
            _fn = _subVWlarge;
        };
        return _fn(_z, _x, _y);
    }
function _shlVU(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = new Word();
        return _shlVU_g(_z, _x, _s);
    }
function _shrVU(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt):Word {
        var _c:Word = new Word();
        return _shrVU_g(_z, _x, _s);
    }
function _mulAddVWW(_z:Slice<Word>, _x:Slice<Word>, _y:Word, _r:Word):Word {
        var _c:Word = new Word();
        return _mulAddVWW_g(_z, _x, _y, _r);
    }
function _addMulVVW(_z:Slice<Word>, _x:Slice<Word>, _y:Word):Word {
        var _c:Word = new Word();
        return _addMulVVW_g(_z, _x, _y);
    }
function _testFunVV(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funVV, _a:T_argVV):Void {
        var _z:T_nat = new Slice<Word>(...[for (i in 0 ... (((_a._z != null ? _a._z.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        var _c:Word = _f(_z, _a._x, _a._y);
        for (_i => _zi in _z) {
            if (_zi != (_a._z != null ? _a._z[_i] : new Word())) {
                _t.errorf(((("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface((_a._z != null ? _a._z[_i] : new Word())));
                break;
            };
        };
        if (_c != _a._c) {
            _t.errorf(((("%s%+v\n\tgot c = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
function testFunVV(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _sumVV) {
            var _arg:T_argVV = (_a == null ? null : _a.__copy__());
            _testFunVV(_t, ((("addVV_g" : GoString))), _addVV_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVV(_t, ((("addVV" : GoString))), _addVV, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argVV((_a._z == null ? null : _a._z.__copy__()), (_a._y == null ? null : _a._y.__copy__()), (_a._x == null ? null : _a._x.__copy__()), _a._c) : T_argVV));
            _testFunVV(_t, ((("addVV_g symmetric" : GoString))), _addVV_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVV(_t, ((("addVV symmetric" : GoString))), _addVV, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argVV((_a._x == null ? null : _a._x.__copy__()), (_a._z == null ? null : _a._z.__copy__()), (_a._y == null ? null : _a._y.__copy__()), _a._c) : T_argVV));
            _testFunVV(_t, ((("subVV_g" : GoString))), _subVV_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVV(_t, ((("subVV" : GoString))), _subVV, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argVV((_a._y == null ? null : _a._y.__copy__()), (_a._z == null ? null : _a._z.__copy__()), (_a._x == null ? null : _a._x.__copy__()), _a._c) : T_argVV));
            _testFunVV(_t, ((("subVV_g symmetric" : GoString))), _subVV_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVV(_t, ((("subVV symmetric" : GoString))), _subVV, (_arg == null ? null : _arg.__copy__()));
        };
    }
function _rndW():Word {
        return ((((_rnd.int63() << ((1 : GoUnTypedInt))) | _rnd.int63n(((2 : GoInt64)))) : Word));
    }
function _rndV(_n:GoInt):Slice<Word> {
        var _v:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
        for (_i => _ in _v) {
            if (_v != null) _v[_i] = _rndW();
        };
        return _v;
    }
function benchmarkAddVV(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _y:Slice<Word> = _rndV(_n);
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((32 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _addVV(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkSubVV(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _y:Slice<Word> = _rndV(_n);
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((32 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _subVV(_z, _x, _y);
                    });
                };
            });
        };
    }
function _testFunVW(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funVW, _a:T_argVW):Void {
        var _z:T_nat = new Slice<Word>(...[for (i in 0 ... (((_a._z != null ? _a._z.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        var _c:Word = _f(_z, _a._x, _a._y);
        for (_i => _zi in _z) {
            if (_zi != (_a._z != null ? _a._z[_i] : new Word())) {
                _t.errorf(((("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface((_a._z != null ? _a._z[_i] : new Word())));
                break;
            };
        };
        if (_c != _a._c) {
            _t.errorf(((("%s%+v\n\tgot c = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
function _testFunVWext(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funVW, _f_g:T_funVW, _a:T_argVW):Void {
        var _z_g:T_nat = new Slice<Word>(...[for (i in 0 ... (((_a._z != null ? _a._z.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        var _c_g:Word = _f_g(_z_g, _a._x, _a._y);
        var _c:Word = _f(_a._z, _a._x, _a._y);
        for (_i => _zi in _a._z) {
            if (_zi != (_z_g != null ? _z_g[_i] : new Word())) {
                _t.errorf(((("%s\n\tgot z[%d] = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface((_z_g != null ? _z_g[_i] : new Word())));
                break;
            };
        };
        if (_c != _c_g) {
            _t.errorf(((("%s\n\tgot c = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_c), Go.toInterface(_c_g));
        };
    }
function _makeFunVW(_f:(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt) -> Word):T_funVW {
        return function(_z:Slice<Word>, _x:Slice<Word>, _s:Word):Word {
            var _c:Word = new Word();
            return _f(_z, _x, ((_s : GoUInt)));
        };
    }
function testFunVW(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _sumVW) {
            var _arg:T_argVW = (_a == null ? null : _a.__copy__());
            _testFunVW(_t, ((("addVW_g" : GoString))), _addVW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVW(_t, ((("addVW" : GoString))), _addVW, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argVW((_a._x == null ? null : _a._x.__copy__()), (_a._z == null ? null : _a._z.__copy__()), _a._y, _a._c) : T_argVW));
            _testFunVW(_t, ((("subVW_g" : GoString))), _subVW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVW(_t, ((("subVW" : GoString))), _subVW, (_arg == null ? null : _arg.__copy__()));
        };
        var _shlVW_g:T_funVW = _makeFunVW(_shlVU_g);
        var _shlVW:T_funVW = _makeFunVW(_shlVU);
        for (_1 => _a in _lshVW) {
            var _arg:T_argVW = (_a == null ? null : _a.__copy__());
            _testFunVW(_t, ((("shlVU_g" : GoString))), _shlVW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVW(_t, ((("shlVU" : GoString))), _shlVW, (_arg == null ? null : _arg.__copy__()));
        };
        var _shrVW_g:T_funVW = _makeFunVW(_shrVU_g);
        var _shrVW:T_funVW = _makeFunVW(_shrVU);
        for (_2 => _a in _rshVW) {
            var _arg:T_argVW = (_a == null ? null : _a.__copy__());
            _testFunVW(_t, ((("shrVU_g" : GoString))), _shrVW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVW(_t, ((("shrVU" : GoString))), _shrVW, (_arg == null ? null : _arg.__copy__()));
        };
    }
function _makeWordVec(_e:Word, _n:GoInt):Slice<Word> {
        var _v:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
        for (_i => _ in _v) {
            if (_v != null) _v[_i] = _e;
        };
        return _v;
    }
function testFunVWExt(_t:stdgo.testing.Testing.T_):Void {
        var _vwSizes:Slice<GoInt> = ((new Slice<GoInt>(
((0 : GoInt)),
((1 : GoInt)),
((3 : GoInt)),
((4 : GoInt)),
((5 : GoInt)),
((8 : GoInt)),
((9 : GoInt)),
((23 : GoInt)),
((31 : GoInt)),
((32 : GoInt)),
((33 : GoInt)),
((34 : GoInt)),
((35 : GoInt)),
((36 : GoInt)),
((50 : GoInt)),
((120 : GoInt))) : Slice<GoInt>));
        for (_0 => _n in _vwSizes) {
            var _x:Slice<Word> = _rndV(_n);
            var _y:Word = _rndW();
            var _z:T_nat = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            var _arg:T_argVW = ((new T_argVW((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), _y, ((0 : GoUInt))) : T_argVW));
            _testFunVWext(_t, ((("addVW, random inputs" : GoString))), _addVW, _addVW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVWext(_t, ((("subVW, random inputs" : GoString))), _subVW, _subVW_g, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argVW((_x == null ? null : _x.__copy__()), (_x == null ? null : _x.__copy__()), _y, ((0 : GoUInt))) : T_argVW));
            _testFunVWext(_t, ((("addVW, random inputs, sharing storage" : GoString))), _addVW, _addVW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVWext(_t, ((("subVW, random inputs, sharing storage" : GoString))), _subVW, _subVW_g, (_arg == null ? null : _arg.__copy__()));
            _y = (("4294967295" : GoUInt));
            _x = _makeWordVec(_y, _n);
            _arg = ((new T_argVW((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), _y, ((0 : GoUInt))) : T_argVW));
            _testFunVWext(_t, ((("addVW, vector of max uint" : GoString))), _addVW, _addVW_g, (_arg == null ? null : _arg.__copy__()));
            _x = _makeWordVec(((0 : GoUInt)), _n);
            _arg = ((new T_argVW((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), ((1 : GoUInt)), ((0 : GoUInt))) : T_argVW));
            _testFunVWext(_t, ((("subVW, vector of zero" : GoString))), _subVW, _subVW_g, (_arg == null ? null : _arg.__copy__()));
        };
    }
function _testShiftFunc(_t:stdgo.testing.Testing.T_, _f:(_z:Slice<Word>, _x:Slice<Word>, _s:GoUInt) -> Word, _a:T_argVU):Void {
        var _b:Slice<Word> = new Slice<Word>(...[for (i in 0 ... (((_a._d != null ? _a._d.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        Go.copySlice(_b, _a._d);
        var _z:Slice<Word> = ((_b.__slice__(_a._zp, _a._zp + _a._l) : Slice<Word>));
        var _x:Slice<Word> = ((_b.__slice__(_a._xp, _a._xp + _a._l) : Slice<Word>));
        var _c:Word = _f(_z, _x, _a._s);
        for (_i => _zi in _z) {
            if (_zi != (_a._r != null ? _a._r[_i] : new Word())) {
                _t.errorf(((("d := %v, %s(d[%d:%d], d[%d:%d], %d)\n\tgot z[%d] = %#x; want %#x" : GoString))),
Go.toInterface(_a._d),
Go.toInterface(_a._m),
Go.toInterface(_a._zp),
Go.toInterface(_a._zp + _a._l),
Go.toInterface(_a._xp),
Go.toInterface(_a._xp + _a._l),
Go.toInterface(_a._s),
Go.toInterface(_i),
Go.toInterface(_zi),
Go.toInterface((_a._r != null ? _a._r[_i] : new Word())));
                break;
            };
        };
        if (_c != _a._c) {
            _t.errorf(((("d := %v, %s(d[%d:%d], d[%d:%d], %d)\n\tgot c = %#x; want %#x" : GoString))), Go.toInterface(_a._d), Go.toInterface(_a._m), Go.toInterface(_a._zp), Go.toInterface(_a._zp + _a._l), Go.toInterface(_a._xp), Go.toInterface(_a._xp + _a._l), Go.toInterface(_a._s), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
function testShiftOverlap(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _argshlVU) {
            var _arg:T_argVU = (_a == null ? null : _a.__copy__());
            _testShiftFunc(_t, _shlVU, (_arg == null ? null : _arg.__copy__()));
        };
        for (_1 => _a in _argshrVU) {
            var _arg:T_argVU = (_a == null ? null : _a.__copy__());
            _testShiftFunc(_t, _shrVU, (_arg == null ? null : _arg.__copy__()));
        };
    }
function testIssue31084(_t:stdgo.testing.Testing.T_):Void {
        {};
        var _p:T_nat = (((new T_nat() : T_nat))._expNN(((new Slice<Word>(((5 : GoUInt))) : T_nat)), ((new Slice<Word>(((165 : GoUInt))) : T_nat)), null) == null ? null : ((new T_nat() : T_nat))._expNN(((new Slice<Word>(((5 : GoUInt))) : T_nat)), ((new Slice<Word>(((165 : GoUInt))) : T_nat)), null).__copy__());
        _p = (_p._shl((_p == null ? null : _p.__copy__()), ((165 : GoUInt))) == null ? null : _p._shl((_p == null ? null : _p.__copy__()), ((165 : GoUInt))).__copy__());
        var _got:GoString = ((_p._utoa(((10 : GoInt))) : GoString));
        var _want:GoString = ((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((165 : GoInt)));
        if (_got != _want) {
            _t.errorf(((("shl(%v, %v)\n\tgot  %s\n\twant %s" : GoString))), Go.toInterface(_p), Go.toInterface(((165 : GoInt))), Go.toInterface(_got), Go.toInterface(_want));
        };
    }
function testIssue42838(_t:stdgo.testing.Testing.T_):Void {
        {};
        var __tmp__ = ((new T_nat() : T_nat))._scan(stdgo.strings.Strings.newReader(((("159309191113245227702888039776771180559110455519261878607388585338616290151305816094308987472018268594098344692611135542392730712890625" : GoString)))), ((0 : GoInt)), false), _z:T_nat = __tmp__._0, _0:GoInt = __tmp__._1, _1:GoInt = __tmp__._2, _2:stdgo.Error = __tmp__._3;
        _z = (_z._shl((_z == null ? null : _z.__copy__()), ((192 : GoUInt))) == null ? null : _z._shl((_z == null ? null : _z.__copy__()), ((192 : GoUInt))).__copy__());
        var _got:GoString = ((_z._utoa(((10 : GoInt))) : GoString));
        var _want:GoString = ((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((192 : GoInt)));
        if (_got != _want) {
            _t.errorf(((("shl(%v, %v)\n\tgot  %s\n\twant %s" : GoString))), Go.toInterface(_z), Go.toInterface(((192 : GoInt))), Go.toInterface(_got), Go.toInterface(_want));
        };
    }
function benchmarkAddVW(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _y:Word = _rndW();
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((4 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _addVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkAddVWext(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _y:Word = (("4294967295" : GoUInt));
            var _x:Slice<Word> = _makeWordVec(_y, _n);
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((4 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _addVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkSubVW(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _y:Word = _rndW();
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((4 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _subVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkSubVWext(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _makeWordVec(((0 : GoUInt)), _n);
            var _y:Word = ((((1 : GoUInt)) : Word));
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((4 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _subVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function _testFunVWW(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funVWW, _a:T_argVWW):Void {
        var _z:T_nat = new Slice<Word>(...[for (i in 0 ... (((_a._z != null ? _a._z.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        var _c:Word = _f(_z, _a._x, _a._y, _a._r);
        for (_i => _zi in _z) {
            if (_zi != (_a._z != null ? _a._z[_i] : new Word())) {
                _t.errorf(((("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface((_a._z != null ? _a._z[_i] : new Word())));
                break;
            };
        };
        if (_c != _a._c) {
            _t.errorf(((("%s%+v\n\tgot c = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_c), Go.toInterface(_a._c));
        };
    }
function _testFunWVW(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funWVW, _a:T_argWVW):Void {
        var _z:T_nat = new Slice<Word>(...[for (i in 0 ... (((_a._z != null ? _a._z.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        var _r:Word = _f(_z, _a._xn, _a._x, _a._y);
        for (_i => _zi in _z) {
            if (_zi != (_a._z != null ? _a._z[_i] : new Word())) {
                _t.errorf(((("%s%+v\n\tgot z[%d] = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_i), Go.toInterface(_zi), Go.toInterface((_a._z != null ? _a._z[_i] : new Word())));
                break;
            };
        };
        if (_r != _a._r) {
            _t.errorf(((("%s%+v\n\tgot r = %#x; want %#x" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_r), Go.toInterface(_a._r));
        };
    }
function testFunVWW(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _prodVWW) {
            var _arg:T_argVWW = (_a == null ? null : _a.__copy__());
            _testFunVWW(_t, ((("mulAddVWW_g" : GoString))), _mulAddVWW_g, (_arg == null ? null : _arg.__copy__()));
            _testFunVWW(_t, ((("mulAddVWW" : GoString))), _mulAddVWW, (_arg == null ? null : _arg.__copy__()));
            if ((_a._y != ((0 : GoUInt))) && (_a._r < _a._y)) {
                var _arg:T_argWVW = ((new T_argWVW((_a._x == null ? null : _a._x.__copy__()), _a._c, (_a._z == null ? null : _a._z.__copy__()), _a._y, _a._r) : T_argWVW));
                _testFunWVW(_t, ((("divWVW" : GoString))), _divWVW, (_arg == null ? null : _arg.__copy__()));
            };
        };
    }
function testMulWW(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _mulWWTests) {
            var __tmp__ = _mulWW_g(_test._x, _test._y), _q:Word = __tmp__._0, _r:Word = __tmp__._1;
            if ((_q != _test._q) || (_r != _test._r)) {
                _t.errorf(((("#%d got (%x, %x) want (%x, %x)" : GoString))), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_test._q), Go.toInterface(_test._r));
            };
        };
    }
function testMulAddWWW(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _mulAddWWWTests) {
            var __tmp__ = _mulAddWWW_g(_test._x, _test._y, _test._c), _q:Word = __tmp__._0, _r:Word = __tmp__._1;
            if ((_q != _test._q) || (_r != _test._r)) {
                _t.errorf(((("#%d got (%x, %x) want (%x, %x)" : GoString))), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_test._q), Go.toInterface(_test._r));
            };
        };
    }
function testDivWW(_t:stdgo.testing.Testing.T_):Void {
        var _i:GoInt = ((0 : GoInt));
        for (_i => _test in _divWWTests) {
            var _rec:Word = _reciprocalWord(_test._y);
            var __tmp__ = _divWW(_test._x1, _test._x0, _test._y, _rec), _q:Word = __tmp__._0, _r:Word = __tmp__._1;
            if ((_q != _test._q) || (_r != _test._r)) {
                _t.errorf(((("#%d got (%x, %x) want (%x, %x)" : GoString))), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_test._q), Go.toInterface(_test._r));
            };
        };
        Go.cfor(_i < ((65536 : GoInt)), _i++, {
            var _x1:Word = _rndW();
            var _x0:Word = _rndW();
            var _y:Word = _rndW();
            if (_x1 >= _y) {
                continue;
            };
            var _rec:Word = _reciprocalWord(_y);
            var __tmp__ = _divWW(_x1, _x0, _y, _rec), _qGot:Word = __tmp__._0, _rGot:Word = __tmp__._1;
            var __tmp__ = stdgo.math.bits.Bits.div(((_x1 : GoUInt)), ((_x0 : GoUInt)), ((_y : GoUInt))), _qWant:GoUInt = __tmp__._0, _rWant:GoUInt = __tmp__._1;
            if ((((_qGot : GoUInt)) != _qWant) || (((_rGot : GoUInt)) != _rWant)) {
                _t.errorf(((("#%d got (%x, %x) want (%x, %x)" : GoString))), Go.toInterface(_i), Go.toInterface(_qGot), Go.toInterface(_rGot), Go.toInterface(_qWant), Go.toInterface(_rWant));
            };
        });
    }
function benchmarkMulAddVWW(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n + ((1 : GoInt)) : GoInt)).toBasic()) new Word()]);
            var _x:Slice<Word> = _rndV(_n);
            var _y:Word = _rndW();
            var _r:Word = _rndW();
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((32 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _mulAddVWW(_z, _x, _y, _r);
                    });
                };
            });
        };
    }
function benchmarkAddMulVVW(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _y:Word = _rndW();
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((32 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _addMulVVW(_z, _x, _y);
                    });
                };
            });
        };
    }
function benchmarkDivWVW(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _y:Word = _rndW();
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((32 : GoInt))) : GoInt64)));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _divWVW(_z, ((0 : GoUInt)), _x, _y);
                    });
                };
            });
        };
    }
function benchmarkNonZeroShifts(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _benchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            var _x:Slice<Word> = _rndV(_n);
            var _s:GoUInt = ((stdgo.math.rand.Rand.int63n(((30 : GoInt64))) : GoUInt)) + ((1 : GoUInt));
            var _z:Slice<Word> = new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]);
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                _b.setBytes((((_n * ((32 : GoInt))) : GoInt64)));
                _b.run(((("shrVU" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
                    {
                        var _i:GoInt = ((0 : GoInt));
                        Go.cfor(_i < _b.n, _i++, {
                            _shrVU(_z, _x, _s);
                        });
                    };
                });
                _b.run(((("shlVU" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
                    {
                        var _i:GoInt = ((0 : GoInt));
                        Go.cfor(_i < _b.n, _i++, {
                            _shlVU(_z, _x, _s);
                        });
                    };
                });
            });
        };
    }
function testMulBits(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_3>(((new T__struct_3(null, null, null) : T__struct_3)), ((new T__struct_3(((new Slice<GoInt>() : Bits)), ((new Slice<GoInt>() : Bits)), null) : T__struct_3)), ((new T__struct_3(((new Slice<GoInt>(((0 : GoInt))) : Bits)), ((new Slice<GoInt>(((0 : GoInt))) : Bits)), ((new Slice<GoInt>(((0 : GoInt))) : Bits))) : T__struct_3)), ((new T__struct_3(((new Slice<GoInt>(((0 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt))) : Bits))) : T__struct_3)), ((new T__struct_3(((new Slice<GoInt>(((1 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt)), ((2 : GoInt)), ((3 : GoInt))) : Bits)), ((new Slice<GoInt>(((2 : GoInt)), ((3 : GoInt)), ((4 : GoInt))) : Bits))) : T__struct_3)), ((new T__struct_3(((new Slice<GoInt>(((-1 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt))) : Bits)), ((new Slice<GoInt>(((0 : GoInt))) : Bits))) : T__struct_3)), ((new T__struct_3(((new Slice<GoInt>(((-10 : GoInt)), ((-1 : GoInt)), ((0 : GoInt)), ((1 : GoInt)), ((10 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt)), ((2 : GoInt)), ((3 : GoInt))) : Bits)), ((new Slice<GoInt>(
((-9 : GoInt)),
((-8 : GoInt)),
((-7 : GoInt)),
((0 : GoInt)),
((1 : GoInt)),
((2 : GoInt)),
((1 : GoInt)),
((2 : GoInt)),
((3 : GoInt)),
((2 : GoInt)),
((3 : GoInt)),
((4 : GoInt)),
((11 : GoInt)),
((12 : GoInt)),
((13 : GoInt))) : Bits))) : T__struct_3))) : Slice<T__struct_3>))) {
            var _got:GoString = stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_test._x._mul((_test._y == null ? null : _test._y.__copy__()))));
            var _want:GoString = stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_test._want));
            if (_got != _want) {
                _t.errorf(((("%v * %v = %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._y), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testNormBits(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_4>(((new T__struct_4(null, null) : T__struct_4)), ((new T__struct_4(((new Slice<GoInt>() : Bits)), ((new Slice<GoInt>() : Bits))) : T__struct_4)), ((new T__struct_4(((new Slice<GoInt>(((0 : GoInt))) : Bits)), ((new Slice<GoInt>(((0 : GoInt))) : Bits))) : T__struct_4)), ((new T__struct_4(((new Slice<GoInt>(((0 : GoInt)), ((0 : GoInt))) : Bits)), ((new Slice<GoInt>(((1 : GoInt))) : Bits))) : T__struct_4)), ((new T__struct_4(((new Slice<GoInt>(((3 : GoInt)), ((1 : GoInt)), ((1 : GoInt))) : Bits)), ((new Slice<GoInt>(((2 : GoInt)), ((3 : GoInt))) : Bits))) : T__struct_4)), ((new T__struct_4(((new Slice<GoInt>(((10 : GoInt)), ((9 : GoInt)), ((8 : GoInt)), ((7 : GoInt)), ((6 : GoInt)), ((6 : GoInt))) : Bits)), ((new Slice<GoInt>(((11 : GoInt))) : Bits))) : T__struct_4))) : Slice<T__struct_4>))) {
            var _got:GoString = stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_test._x._norm()));
            var _want:GoString = stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_test._want));
            if (_got != _want) {
                _t.errorf(((("normBits(%v) = %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testFromBits(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_5>(
((new T__struct_5(null, ((("0" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((0 : GoInt))) : Bits)), ((("0x.8p+1" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((1 : GoInt))) : Bits)), ((("0x.8p+2" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((-1 : GoInt))) : Bits)), ((("0x.8p+0" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((63 : GoInt))) : Bits)), ((("0x.8p+64" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((33 : GoInt)), ((-30 : GoInt))) : Bits)), ((("0x.8000000000000001p+34" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((255 : GoInt)), ((0 : GoInt))) : Bits)), ((("0x.8000000000000000000000000000000000000000000000000000000000000001p+256" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((0 : GoInt)), ((0 : GoInt))) : Bits)), ((("0x.8p+2" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt))) : Bits)), ((("0x.8p+3" : GoString)))) : T__struct_5)),
((new T__struct_5(((new Slice<GoInt>(((0 : GoInt)), ((1 : GoInt)), ((0 : GoInt))) : Bits)), ((("0x.8p+3" : GoString)))) : T__struct_5)),
((new T__struct_5(((((new Slice<GoInt>(((2 : GoInt)), ((1 : GoInt)), ((0 : GoInt))) : Bits)) != null ? ((new Slice<GoInt>(((2 : GoInt)), ((1 : GoInt)), ((0 : GoInt))) : Bits)).__append__(...((new Slice<GoInt>(((3 : GoInt)), ((1 : GoInt))) : Bits)).__toArray__()) : new Slice<Slice<GoInt>>(...((new Slice<GoInt>(((3 : GoInt)), ((1 : GoInt))) : Bits)).__toArray__())) == null ? null : (((new Slice<GoInt>(((2 : GoInt)), ((1 : GoInt)), ((0 : GoInt))) : Bits)) != null ? ((new Slice<GoInt>(((2 : GoInt)), ((1 : GoInt)), ((0 : GoInt))) : Bits)).__append__(...((new Slice<GoInt>(((3 : GoInt)), ((1 : GoInt))) : Bits)).__toArray__()) : new Slice<Slice<GoInt>>(...((new Slice<GoInt>(((3 : GoInt)), ((1 : GoInt))) : Bits)).__toArray__())).__copy__()), ((("0x.88p+5" : GoString)))) : T__struct_5))) : Slice<T__struct_5>))) {
            var _f:Ref<Float_> = _test._bits.float();
            {
                var _got:GoString = _f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)));
                if (_got != _test._want) {
                    _t.errorf(((("setBits(%v) = %s; want %s" : GoString))), Go.toInterface(_test._bits), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testCalibrate(_t:stdgo.testing.Testing.T_):Void {
        if (!_calibrate.value) {
            return;
        };
        _computeKaratsubaThresholds();
        var _minSqr:GoInt = _computeSqrThreshold(((10 : GoInt)), ((30 : GoInt)), ((1 : GoInt)), ((3 : GoInt)), ((("mul(x, x)" : GoString))), ((("basicSqr(x)" : GoString))));
        var _maxSqr:GoInt = _computeSqrThreshold(((200 : GoInt)), ((500 : GoInt)), ((10 : GoInt)), ((3 : GoInt)), ((("basicSqr(x)" : GoString))), ((("karatsubaSqr(x)" : GoString))));
        if (_minSqr != ((0 : GoInt))) {
            stdgo.fmt.Fmt.printf(((("found basicSqrThreshold = %d\n" : GoString))), Go.toInterface(_minSqr));
        } else {
            stdgo.fmt.Fmt.println(((("no basicSqrThreshold found" : GoString))));
        };
        if (_maxSqr != ((0 : GoInt))) {
            stdgo.fmt.Fmt.printf(((("found karatsubaSqrThreshold = %d\n" : GoString))), Go.toInterface(_maxSqr));
        } else {
            stdgo.fmt.Fmt.println(((("no karatsubaSqrThreshold found" : GoString))));
        };
    }
function _karatsubaLoad(_b:stdgo.testing.Testing.B):Void {
        benchmarkMul(_b);
    }
function _measureKaratsuba(_th:GoInt):stdgo.time.Time.Duration {
        {
            final __tmp__0 = _karatsubaThreshold;
            final __tmp__1 = _th;
            _th = __tmp__0;
            _karatsubaThreshold = __tmp__1;
        };
        var _res:stdgo.testing.Testing.BenchmarkResult = (stdgo.testing.Testing.benchmark(_karatsubaLoad) == null ? null : stdgo.testing.Testing.benchmark(_karatsubaLoad).__copy__());
        _karatsubaThreshold = _th;
        return ((_res.nsPerOp() : stdgo.time.Time.Duration));
    }
function _computeKaratsubaThresholds():Void {
        stdgo.fmt.Fmt.printf(((("Multiplication times for varying Karatsuba thresholds\n" : GoString))));
        stdgo.fmt.Fmt.printf(((("(run repeatedly for good results)\n" : GoString))));
        var tb:stdgo.time.Time.Duration = _measureKaratsuba(((1e+09 : GoInt)));
        stdgo.fmt.Fmt.printf(((("Tb = %10s\n" : GoString))), Go.toInterface(tb));
        var _th:GoInt = ((4 : GoInt));
        var _th1:GoInt = ((-1 : GoInt));
        var _th2:GoInt = ((-1 : GoInt));
        var _deltaOld:stdgo.time.Time.Duration = new stdgo.time.Time.Duration();
        {
            var _count:GoInt = ((-1 : GoInt));
            Go.cfor((_count != ((0 : GoInt))) && (_th < ((128 : GoInt))), _count--, {
                var tk:stdgo.time.Time.Duration = _measureKaratsuba(_th);
                var _delta:stdgo.time.Time.Duration = ((tb - tk) * ((100 : GoInt64))) / tb;
                stdgo.fmt.Fmt.printf(((("th = %3d  Tk = %10s  %4d%%" : GoString))), Go.toInterface(_th), Go.toInterface(tk), Go.toInterface(_delta));
                if ((tk < tb) && (_th1 < ((0 : GoInt)))) {
                    _th1 = _th;
                    stdgo.fmt.Fmt.print(((("  break-even point" : GoString))));
                };
                if (((((0 : GoInt64)) < _delta) && (_delta < _deltaOld)) && (_th2 < ((0 : GoInt)))) {
                    _th2 = _th;
                    stdgo.fmt.Fmt.print(((("  diminishing return" : GoString))));
                };
                _deltaOld = _delta;
                stdgo.fmt.Fmt.println();
                if (((_th1 >= ((0 : GoInt))) && (_th2 >= ((0 : GoInt)))) && (_count < ((0 : GoInt)))) {
                    _count = ((10 : GoInt));
                };
                _th++;
            });
        };
    }
function _measureSqr(_words:GoInt, _nruns:GoInt, _mode:GoString):stdgo.time.Time.Duration {
        var _initBasicSqr:GoInt = _basicSqrThreshold, _initKaratsubaSqr:GoInt = _karatsubaSqrThreshold;
        if (_mode == ((("mul(x, x)" : GoString)))) {
            _basicSqrThreshold = _words + ((1 : GoInt));
        } else if (_mode == ((("basicSqr(x)" : GoString)))) {
            {
                final __tmp__0 = _words - ((1 : GoInt));
                final __tmp__1 = _words + ((1 : GoInt));
                _basicSqrThreshold = __tmp__0;
                _karatsubaSqrThreshold = __tmp__1;
            };
        } else if (_mode == ((("karatsubaSqr(x)" : GoString)))) {
            _karatsubaSqrThreshold = _words - ((1 : GoInt));
        };
        var _testval:GoInt64 = ((0 : GoInt64));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _nruns, _i++, {
                var _res:stdgo.testing.Testing.BenchmarkResult = (stdgo.testing.Testing.benchmark(function(_b:stdgo.testing.Testing.B):Void {
                    _benchmarkNatSqr(_b, _words);
                }) == null ? null : stdgo.testing.Testing.benchmark(function(_b:stdgo.testing.Testing.B):Void {
                    _benchmarkNatSqr(_b, _words);
                }).__copy__());
                _testval = _testval + (_res.nsPerOp());
            });
        };
        _testval = _testval / (((_nruns : GoInt64)));
        {
            final __tmp__0 = _initBasicSqr;
            final __tmp__1 = _initKaratsubaSqr;
            _basicSqrThreshold = __tmp__0;
            _karatsubaSqrThreshold = __tmp__1;
        };
        return ((_testval : stdgo.time.Time.Duration));
    }
function _computeSqrThreshold(_from:GoInt, _to:GoInt, _step:GoInt, _nruns:GoInt, _lower:GoString, _upper:GoString):GoInt {
        stdgo.fmt.Fmt.printf(((("Calibrating threshold between %s and %s\n" : GoString))), Go.toInterface(_lower), Go.toInterface(_upper));
        stdgo.fmt.Fmt.printf(((("Looking for a timing difference for x between %d - %d words by %d step\n" : GoString))), Go.toInterface(_from), Go.toInterface(_to), Go.toInterface(_step));
        var _initPos:Bool = false;
        var _threshold:GoInt = ((0 : GoInt));
        {
            var _i:GoInt = _from;
            Go.cfor(_i <= _to, _i = _i + (_step), {
                var _baseline:stdgo.time.Time.Duration = _measureSqr(_i, _nruns, _lower);
                var _testval:stdgo.time.Time.Duration = _measureSqr(_i, _nruns, _upper);
                var _pos:Bool = _baseline > _testval;
                var _delta:stdgo.time.Time.Duration = _baseline - _testval;
                var _percent:stdgo.time.Time.Duration = (_delta * ((100 : GoInt64))) / _baseline;
                stdgo.fmt.Fmt.printf(((("words = %3d deltaT = %10s (%4d%%) is %s better: %v" : GoString))), Go.toInterface(_i), Go.toInterface(_delta), Go.toInterface(_percent), Go.toInterface(_upper), Go.toInterface(_pos));
                if (_i == _from) {
                    _initPos = _pos;
                };
                if ((_threshold == ((0 : GoInt))) && (_pos != _initPos)) {
                    _threshold = _i;
                    stdgo.fmt.Fmt.printf(((("  threshold  found" : GoString))));
                };
                stdgo.fmt.Fmt.println();
            });
        };
        if (_threshold != ((0 : GoInt))) {
            stdgo.fmt.Fmt.printf(((("Found threshold = %d between %d - %d\n" : GoString))), Go.toInterface(_threshold), Go.toInterface(_from), Go.toInterface(_to));
        } else {
            stdgo.fmt.Fmt.printf(((("Found NO threshold between %d - %d\n" : GoString))), Go.toInterface(_from), Go.toInterface(_to));
        };
        return _threshold;
    }
function _shr(_x:T_decimal, _s:GoUInt):Void {
        var _r:GoInt = ((0 : GoInt));
        var _n:Word = new Word();
        while (((_n >> _s) == ((0 : GoUInt))) && (_r < (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            var _ch:Word = (((_x._mant != null ? _x._mant[_r] : ((0 : GoUInt8))) : Word));
            _r++;
            _n = ((_n * ((10 : GoUInt))) + _ch) - ((((("0" : GoString))).code : GoRune));
        };
        if (_n == ((0 : GoUInt))) {
            _x._mant = ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>));
            return;
        };
        while ((_n >> _s) == ((0 : GoUInt))) {
            _r++;
            _n = _n * (((10 : GoUInt)));
        };
        _x._exp = _x._exp + (((1 : GoInt)) - _r);
        var _w:GoInt = ((0 : GoInt));
        var _mask:Word = (((((1 : GoUInt)) : Word)) << _s) - ((1 : GoUInt));
        while (_r < (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) {
            var _ch:Word = (((_x._mant != null ? _x._mant[_r] : ((0 : GoUInt8))) : Word));
            _r++;
            var _d:Word = _n >> _s;
            _n = _n & (_mask);
            if (_x._mant != null) _x._mant[_w] = (((_d + ((((("0" : GoString))).code : GoRune))) : GoByte));
            _w++;
            _n = ((_n * ((10 : GoUInt))) + _ch) - ((((("0" : GoString))).code : GoRune));
        };
        while ((_n > ((0 : GoUInt))) && (_w < (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            var _d:Word = _n >> _s;
            _n = _n & (_mask);
            if (_x._mant != null) _x._mant[_w] = (((_d + ((((("0" : GoString))).code : GoRune))) : GoByte));
            _w++;
            _n = _n * ((10 : GoUInt));
        };
        _x._mant = ((_x._mant.__slice__(0, _w) : Slice<GoUInt8>));
        while (_n > ((0 : GoUInt))) {
            var _d:Word = _n >> _s;
            _n = _n & (_mask);
            _x._mant = (_x._mant != null ? _x._mant.__append__((((_d + ((((("0" : GoString))).code : GoRune))) : GoByte))) : new Slice<GoUInt8>((((_d + ((((("0" : GoString))).code : GoRune))) : GoByte))));
            _n = _n * ((10 : GoUInt));
        };
        _trim(_x);
    }
function _appendZeros(_buf:Slice<GoByte>, _n:GoInt):Slice<GoByte> {
        Go.cfor(_n > ((0 : GoInt)), _n--, {
            _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        });
        return _buf;
    }
function _shouldRoundUp(_x:T_decimal, _n:GoInt):Bool {
        if (((_x._mant != null ? _x._mant[_n] : ((0 : GoUInt8))) == ((((("5" : GoString))).code : GoRune))) && ((_n + ((1 : GoInt))) == (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return (_n > ((0 : GoInt))) && ((((_x._mant != null ? _x._mant[_n - ((1 : GoInt))] : ((0 : GoUInt8))) - ((((("0" : GoString))).code : GoRune))) & ((1 : GoUInt8))) != ((0 : GoUInt8)));
        };
        return (_x._mant != null ? _x._mant[_n] : ((0 : GoUInt8))) >= ((((("5" : GoString))).code : GoRune));
    }
function _trim(_x:T_decimal):Void {
        var _i:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) && ((_x._mant != null ? _x._mant[_i - ((1 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) {
            _i--;
        };
        _x._mant = ((_x._mant.__slice__(0, _i) : Slice<GoUInt8>));
        if (_i == ((0 : GoInt))) {
            _x._exp = ((0 : GoInt));
        };
    }
function testDecimalString(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_6>(((({ _want : ((("0" : GoString))), _x : new T_decimal() } : T__struct_6)) == null ? null : (({ _want : ((("0" : GoString))), _x : new T_decimal() } : T__struct_6)).__copy__()), ((new T__struct_6(((new T_decimal(((null : Slice<GoUInt8>)), ((1000 : GoInt))) : T_decimal)), ((("0" : GoString)))) : T__struct_6)), ((new T__struct_6(((new T_decimal(((((("12345" : GoString))) : Slice<GoByte>)), ((0 : GoInt))) : T_decimal)), ((("0.12345" : GoString)))) : T__struct_6)), ((new T__struct_6(((new T_decimal(((((("12345" : GoString))) : Slice<GoByte>)), ((-3 : GoInt))) : T_decimal)), ((("0.00012345" : GoString)))) : T__struct_6)), ((new T__struct_6(((new T_decimal(((((("12345" : GoString))) : Slice<GoByte>)), ((3 : GoInt))) : T_decimal)), ((("123.45" : GoString)))) : T__struct_6)), ((new T__struct_6(((new T_decimal(((((("12345" : GoString))) : Slice<GoByte>)), ((10 : GoInt))) : T_decimal)), ((("1234500000" : GoString)))) : T__struct_6))) : Slice<T__struct_6>))) {
            {
                var _got:GoString = ((_test._x.toString() : GoString));
                if (_got != _test._want) {
                    _t.errorf(((("%v == %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testDecimalInit(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_7>(
((new T__struct_7(((0 : GoUInt)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_7)),
((new T__struct_7(((0 : GoUInt)), ((-100 : GoInt)), ((("0" : GoString)))) : T__struct_7)),
((new T__struct_7(((0 : GoUInt)), ((100 : GoInt)), ((("0" : GoString)))) : T__struct_7)),
((new T__struct_7(((1 : GoUInt)), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_7)),
((new T__struct_7(((1 : GoUInt)), ((10 : GoInt)), ((("1024" : GoString)))) : T__struct_7)),
((new T__struct_7(((1 : GoUInt)), ((100 : GoInt)), ((("1267650600228229401496703205376" : GoString)))) : T__struct_7)),
((new T__struct_7(((1 : GoUInt)), ((-100 : GoInt)), ((("0.0000000000000000000000000000007888609052210118054117285652827862296732064351090230047702789306640625" : GoString)))) : T__struct_7)),
((new T__struct_7(((12345678 : GoUInt)), ((8 : GoInt)), ((("3160493568" : GoString)))) : T__struct_7)),
((new T__struct_7(((12345678 : GoUInt)), ((-8 : GoInt)), ((("48225.3046875" : GoString)))) : T__struct_7)),
((new T__struct_7(((195312 : GoUInt)), ((9 : GoInt)), ((("99999744" : GoString)))) : T__struct_7)),
((new T__struct_7(((1953125 : GoUInt)), ((9 : GoInt)), ((("1000000000" : GoString)))) : T__struct_7))) : Slice<T__struct_7>))) {
            var _d:T_decimal = new T_decimal();
            _d._init((((new Slice<Word>(_test._x) : T_nat))._norm() == null ? null : ((new Slice<Word>(_test._x) : T_nat))._norm().__copy__()), _test._shift);
            {
                var _got:GoString = ((_d.toString() : GoString));
                if (_got != _test._want) {
                    _t.errorf(((("%d << %d == %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._shift), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testDecimalRounding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_8>(
((new T__struct_8(((0 : GoUInt64)), ((0 : GoInt)), ((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString)))) : T__struct_8)),
((new T__struct_8(((0 : GoUInt64)), ((1 : GoInt)), ((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString)))) : T__struct_8)),
((new T__struct_8(((1 : GoUInt64)), ((0 : GoInt)), ((("0" : GoString))), ((("0" : GoString))), ((("10" : GoString)))) : T__struct_8)),
((new T__struct_8(((5 : GoUInt64)), ((0 : GoInt)), ((("0" : GoString))), ((("0" : GoString))), ((("10" : GoString)))) : T__struct_8)),
((new T__struct_8(((9 : GoUInt64)), ((0 : GoInt)), ((("0" : GoString))), ((("10" : GoString))), ((("10" : GoString)))) : T__struct_8)),
((new T__struct_8(((15 : GoUInt64)), ((1 : GoInt)), ((("10" : GoString))), ((("20" : GoString))), ((("20" : GoString)))) : T__struct_8)),
((new T__struct_8(((45 : GoUInt64)), ((1 : GoInt)), ((("40" : GoString))), ((("40" : GoString))), ((("50" : GoString)))) : T__struct_8)),
((new T__struct_8(((95 : GoUInt64)), ((1 : GoInt)), ((("90" : GoString))), ((("100" : GoString))), ((("100" : GoString)))) : T__struct_8)),
((new T__struct_8(((12344999 : GoUInt64)), ((4 : GoInt)), ((("12340000" : GoString))), ((("12340000" : GoString))), ((("12350000" : GoString)))) : T__struct_8)),
((new T__struct_8(((12345000 : GoUInt64)), ((4 : GoInt)), ((("12340000" : GoString))), ((("12340000" : GoString))), ((("12350000" : GoString)))) : T__struct_8)),
((new T__struct_8(((12345001 : GoUInt64)), ((4 : GoInt)), ((("12340000" : GoString))), ((("12350000" : GoString))), ((("12350000" : GoString)))) : T__struct_8)),
((new T__struct_8(((23454999 : GoUInt64)), ((4 : GoInt)), ((("23450000" : GoString))), ((("23450000" : GoString))), ((("23460000" : GoString)))) : T__struct_8)),
((new T__struct_8(((23455000 : GoUInt64)), ((4 : GoInt)), ((("23450000" : GoString))), ((("23460000" : GoString))), ((("23460000" : GoString)))) : T__struct_8)),
((new T__struct_8(((23455001 : GoUInt64)), ((4 : GoInt)), ((("23450000" : GoString))), ((("23460000" : GoString))), ((("23460000" : GoString)))) : T__struct_8)),
((new T__struct_8(((99994999 : GoUInt64)), ((4 : GoInt)), ((("99990000" : GoString))), ((("99990000" : GoString))), ((("100000000" : GoString)))) : T__struct_8)),
((new T__struct_8(((99995000 : GoUInt64)), ((4 : GoInt)), ((("99990000" : GoString))), ((("100000000" : GoString))), ((("100000000" : GoString)))) : T__struct_8)),
((new T__struct_8(((99999999 : GoUInt64)), ((4 : GoInt)), ((("99990000" : GoString))), ((("100000000" : GoString))), ((("100000000" : GoString)))) : T__struct_8)),
((new T__struct_8(((12994999 : GoUInt64)), ((4 : GoInt)), ((("12990000" : GoString))), ((("12990000" : GoString))), ((("13000000" : GoString)))) : T__struct_8)),
((new T__struct_8(((12995000 : GoUInt64)), ((4 : GoInt)), ((("12990000" : GoString))), ((("13000000" : GoString))), ((("13000000" : GoString)))) : T__struct_8)),
((new T__struct_8(((12999999 : GoUInt64)), ((4 : GoInt)), ((("12990000" : GoString))), ((("13000000" : GoString))), ((("13000000" : GoString)))) : T__struct_8))) : Slice<T__struct_8>))) {
            var _x:T_nat = (((new T_nat() : T_nat))._setUint64(_test._x) == null ? null : ((new T_nat() : T_nat))._setUint64(_test._x).__copy__());
            var _d:T_decimal = new T_decimal();
            _d._init((_x == null ? null : _x.__copy__()), ((0 : GoInt)));
            _d._roundDown(_test._n);
            {
                var _got:GoString = ((_d.toString() : GoString));
                if (_got != _test._down) {
                    _t.errorf(((("roundDown(%d, %d) = %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._n), Go.toInterface(_got), Go.toInterface(_test._down));
                };
            };
            _d._init((_x == null ? null : _x.__copy__()), ((0 : GoInt)));
            _d._round(_test._n);
            {
                var _got:GoString = ((_d.toString() : GoString));
                if (_got != _test._even) {
                    _t.errorf(((("round(%d, %d) = %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._n), Go.toInterface(_got), Go.toInterface(_test._even));
                };
            };
            _d._init((_x == null ? null : _x.__copy__()), ((0 : GoInt)));
            _d._roundUp(_test._n);
            {
                var _got:GoString = ((_d.toString() : GoString));
                if (_got != _test._up) {
                    _t.errorf(((("roundUp(%d, %d) = %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._n), Go.toInterface(_got), Go.toInterface(_test._up));
                };
            };
        };
    }
function benchmarkDecimalConversion(_b:stdgo.testing.Testing.B):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                {
                    var _shift:GoInt = ((-100 : GoInt));
                    Go.cfor(_shift <= ((100 : GoInt)), _shift++, {
                        var _d:T_decimal = new T_decimal();
                        _d._init((_natOne == null ? null : _natOne.__copy__()), _shift);
                        _sink = ((_d.toString() : GoString));
                    });
                };
            });
        };
    }
function benchmarkFloatString(_b:stdgo.testing.Testing.B):Void {
        var _x:Ref<Float_> = new Float_();
        for (_0 => _prec in ((new Slice<GoUInt>(((100 : GoUInt)), ((1000 : GoUInt)), ((10000 : GoUInt)), ((100000 : GoUInt))) : Slice<GoUInt>))) {
            _x.setPrec(_prec).setRat(newRat(((1 : GoInt64)), ((3 : GoInt64))));
            _b.run(stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_prec)), function(_b:stdgo.testing.Testing.B):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _sink = ((_x.toString() : GoString));
                    });
                };
            });
        };
    }
function newFloat(_x:GoFloat64):Float_ {
        if (stdgo.math.Math.isNaN(_x)) {
            throw Go.toInterface(((new ErrNaN(((("NewFloat(NaN)" : GoString)))) : ErrNaN)));
        };
        return new Float_().setFloat64(_x);
    }
function _makeAcc(_above:Bool):Accuracy {
        if (_above) {
            return ((1 : GoInt8));
        };
        return ((-1 : GoInt8));
    }
function _fnorm(_m:T_nat):GoInt64 {
        if (false && (((_m != null ? _m.length : ((0 : GoInt))) == ((0 : GoInt))) || ((_m != null ? _m[(_m != null ? _m.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) == ((0 : GoUInt))))) {
            throw Go.toInterface(((("msw of mantissa is 0" : GoString))));
        };
        var _s:GoUInt = _nlz((_m != null ? _m[(_m != null ? _m.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()));
        if (_s > ((0 : GoUInt))) {
            var _c:Word = _shlVU(_m, _m, _s);
            if (false && (_c != ((0 : GoUInt)))) {
                throw Go.toInterface(((("nlz or shlVU incorrect" : GoString))));
            };
        };
        return ((_s : GoInt64));
    }
function _msb32(_x:T_nat):GoUInt32 {
        var _i:GoInt = (_x != null ? _x.length : ((0 : GoInt))) - ((1 : GoInt));
        if (_i < ((0 : GoInt))) {
            return ((0 : GoUInt32));
        };
        if (false && (((_x != null ? _x[_i] : new Word()) & (("2147483648" : GoUInt))) == ((0 : GoUInt)))) {
            throw Go.toInterface(((("x not normalized" : GoString))));
        };
        if (((32 : GoInt)) == ((32 : GoInt))) {
            return (((_x != null ? _x[_i] : new Word()) : GoUInt32));
        } else if (((32 : GoInt)) == ((64 : GoInt))) {
            return ((((_x != null ? _x[_i] : new Word()) >> ((32 : GoUnTypedInt))) : GoUInt32));
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
function _msb64(_x:T_nat):GoUInt64 {
        var _i:GoInt = (_x != null ? _x.length : ((0 : GoInt))) - ((1 : GoInt));
        if (_i < ((0 : GoInt))) {
            return ((0 : GoUInt64));
        };
        if (false && (((_x != null ? _x[_i] : new Word()) & (("2147483648" : GoUInt))) == ((0 : GoUInt)))) {
            throw Go.toInterface(((("x not normalized" : GoString))));
        };
        if (((32 : GoInt)) == ((32 : GoInt))) {
            var _v:GoUInt64 = (((_x != null ? _x[_i] : new Word()) : GoUInt64)) << ((32 : GoUnTypedInt));
            if (_i > ((0 : GoInt))) {
                _v = _v | ((((_x != null ? _x[_i - ((1 : GoInt))] : new Word()) : GoUInt64)));
            };
            return _v;
        } else if (((32 : GoInt)) == ((64 : GoInt))) {
            return (((_x != null ? _x[_i] : new Word()) : GoUInt64));
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
function _validateBinaryOperands(_x:Float_, _y:Float_):Void {
        if (true) {
            throw Go.toInterface(((("validateBinaryOperands called but debugFloat is not set" : GoString))));
        };
        if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("empty mantissa for x" : GoString))));
        };
        if ((_y._mant != null ? _y._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("empty mantissa for y" : GoString))));
        };
    }
function _umax32(_x:GoUInt32, _y:GoUInt32):GoUInt32 {
        if (_x > _y) {
            return _x;
        };
        return _y;
    }
function testFloatZeroValue(_t:stdgo.testing.Testing.T_):Void {
        var _x:Float_ = new Float_();
        {
            var _s:GoString = _x.text(((((("f" : GoString))).code : GoRune)), ((1 : GoInt)));
            if (_s != ((("0.0" : GoString)))) {
                _t.errorf(((("zero value = %s; want 0.0" : GoString))), Go.toInterface(_s));
            };
        };
        {
            var _prec:GoUInt = _x.prec();
            if (_prec != ((0 : GoUInt))) {
                _t.errorf(((("prec = %d; want 0" : GoString))), Go.toInterface(_prec));
            };
        };
        var _make:GoInt -> Ref<Float_> = function(_x:GoInt):Float_ {
            var _f:Float_ = new Float_();
            if (_x != ((0 : GoInt))) {
                _f.setInt64(((_x : GoInt64)));
            };
            return _f;
        };
        for (_0 => _test in ((new Slice<T__struct_9>(
((new T__struct_9(((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((((("+" : GoString))).code : GoRune)), (Float__static_extension).add) : T__struct_9)),
((new T__struct_9(((0 : GoInt)), ((1 : GoInt)), ((2 : GoInt)), ((3 : GoInt)), ((((("+" : GoString))).code : GoRune)), (Float__static_extension).add) : T__struct_9)),
((new T__struct_9(((1 : GoInt)), ((2 : GoInt)), ((0 : GoInt)), ((2 : GoInt)), ((((("+" : GoString))).code : GoRune)), (Float__static_extension).add) : T__struct_9)),
((new T__struct_9(((2 : GoInt)), ((0 : GoInt)), ((1 : GoInt)), ((1 : GoInt)), ((((("+" : GoString))).code : GoRune)), (Float__static_extension).add) : T__struct_9)),
((new T__struct_9(((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((((("-" : GoString))).code : GoRune)), (Float__static_extension).sub) : T__struct_9)),
((new T__struct_9(((0 : GoInt)), ((1 : GoInt)), ((2 : GoInt)), ((-1 : GoInt)), ((((("-" : GoString))).code : GoRune)), (Float__static_extension).sub) : T__struct_9)),
((new T__struct_9(((1 : GoInt)), ((2 : GoInt)), ((0 : GoInt)), ((2 : GoInt)), ((((("-" : GoString))).code : GoRune)), (Float__static_extension).sub) : T__struct_9)),
((new T__struct_9(((2 : GoInt)), ((0 : GoInt)), ((1 : GoInt)), ((-1 : GoInt)), ((((("-" : GoString))).code : GoRune)), (Float__static_extension).sub) : T__struct_9)),
((new T__struct_9(((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((((("*" : GoString))).code : GoRune)), (Float__static_extension).mul) : T__struct_9)),
((new T__struct_9(((0 : GoInt)), ((1 : GoInt)), ((2 : GoInt)), ((2 : GoInt)), ((((("*" : GoString))).code : GoRune)), (Float__static_extension).mul) : T__struct_9)),
((new T__struct_9(((1 : GoInt)), ((2 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((((("*" : GoString))).code : GoRune)), (Float__static_extension).mul) : T__struct_9)),
((new T__struct_9(((2 : GoInt)), ((0 : GoInt)), ((1 : GoInt)), ((0 : GoInt)), ((((("*" : GoString))).code : GoRune)), (Float__static_extension).mul) : T__struct_9)),
((new T__struct_9(((0 : GoInt)), ((2 : GoInt)), ((1 : GoInt)), ((2 : GoInt)), ((((("/" : GoString))).code : GoRune)), (Float__static_extension).quo) : T__struct_9)),
((new T__struct_9(((1 : GoInt)), ((2 : GoInt)), ((0 : GoInt)), ((0 : GoInt)), ((((("/" : GoString))).code : GoRune)), (Float__static_extension).quo) : T__struct_9)),
((new T__struct_9(((2 : GoInt)), ((0 : GoInt)), ((1 : GoInt)), ((0 : GoInt)), ((((("/" : GoString))).code : GoRune)), (Float__static_extension).quo) : T__struct_9))) : Slice<T__struct_9>))) {
            var _z:Ref<Float_> = _make(_test._z);
            _test._op(_z, _make(_test._x), _make(_test._y));
            var _got:GoInt = ((0 : GoInt));
            if (!_z.isInf()) {
                _got = ((_z._int64() : GoInt));
            };
            if (_got != _test._want) {
                _t.errorf(((("%d %c %d = %d; want %d" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._opname), Go.toInterface(_test._y), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function _makeFloat(_s:GoString):Float_ {
        var __tmp__ = parseFloat(_s, ((0 : GoInt)), ((1000 : GoUInt)), ((0 : GoUInt8))), _x:Ref<Float_> = __tmp__._0, _0:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if (_err != null) {
            throw Go.toInterface(_err);
        };
        return _x;
    }
function testFloatSetPrec(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_10>(
((new T__struct_10(((("0" : GoString))), ((0 : GoUInt)), ((("0" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-0" : GoString))), ((0 : GoUInt)), ((("-0" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-Inf" : GoString))), ((0 : GoUInt)), ((("-Inf" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("+Inf" : GoString))), ((0 : GoUInt)), ((("+Inf" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("123" : GoString))), ((0 : GoUInt)), ((("0" : GoString))), ((-1 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-123" : GoString))), ((0 : GoUInt)), ((("-0" : GoString))), ((1 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("0" : GoString))), (("4294967295" : GoUInt)), ((("0" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-0" : GoString))), (("4294967295" : GoUInt)), ((("-0" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-Inf" : GoString))), (("4294967295" : GoUInt)), ((("-Inf" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("+Inf" : GoString))), (("4294967295" : GoUInt)), ((("+Inf" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("1.5" : GoString))), ((1 : GoUInt)), ((("2" : GoString))), ((1 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-1.5" : GoString))), ((1 : GoUInt)), ((("-2" : GoString))), ((-1 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("123" : GoString))), ((1e+06 : GoUInt)), ((("123" : GoString))), ((0 : GoInt8))) : T__struct_10)),
((new T__struct_10(((("-123" : GoString))), ((1e+06 : GoUInt)), ((("-123" : GoString))), ((0 : GoInt8))) : T__struct_10))) : Slice<T__struct_10>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x).setPrec(_test._prec);
            var _prec:GoUInt = _test._prec;
            if (_prec > (("4294967295" : GoUInt))) {
                _prec = (("4294967295" : GoUInt));
            };
            {
                var _got:GoUInt = _x.prec();
                if (_got != _prec) {
                    _t.errorf(((("%s.SetPrec(%d).Prec() == %d; want %d" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._prec), Go.toInterface(_got), Go.toInterface(_prec));
                };
            };
            {
                var _got:GoString = ((_x.toString() : GoString)), _acc:Accuracy = _x.acc();
                if ((_got != _test._want) || (_acc != _test._acc)) {
                    _t.errorf(((("%s.SetPrec(%d) = %s (%s); want %s (%s)" : GoString))), Go.toInterface(_test._x), Go.toInterface(_test._prec), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_test._want), Go.toInterface(_test._acc));
                };
            };
        };
    }
function testFloatMinPrec(_t:stdgo.testing.Testing.T_):Void {
        {};
        for (_0 => _test in ((new Slice<T__struct_11>(
((new T__struct_11(((("0" : GoString))), ((0 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("-0" : GoString))), ((0 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("+Inf" : GoString))), ((0 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("-Inf" : GoString))), ((0 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("1" : GoString))), ((1 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("2" : GoString))), ((1 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("3" : GoString))), ((2 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("0x8001" : GoString))), ((16 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("0x8001p-1000" : GoString))), ((16 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("0x8001p+1000" : GoString))), ((16 : GoUInt))) : T__struct_11)),
((new T__struct_11(((("0.1" : GoString))), ((100 : GoUInt))) : T__struct_11))) : Slice<T__struct_11>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x).setPrec(((100 : GoUInt)));
            {
                var _got:GoUInt = _x.minPrec();
                if (_got != _test._want) {
                    _t.errorf(((("%s.MinPrec() = %d; want %d" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testFloatSign(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_12>(((new T__struct_12(((("-Inf" : GoString))), ((-1 : GoInt))) : T__struct_12)), ((new T__struct_12(((("-1" : GoString))), ((-1 : GoInt))) : T__struct_12)), ((new T__struct_12(((("-0" : GoString))), ((0 : GoInt))) : T__struct_12)), ((new T__struct_12(((("+0" : GoString))), ((0 : GoInt))) : T__struct_12)), ((new T__struct_12(((("+1" : GoString))), ((1 : GoInt))) : T__struct_12)), ((new T__struct_12(((("+Inf" : GoString))), ((1 : GoInt))) : T__struct_12))) : Slice<T__struct_12>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            var _s:GoInt = _x.sign();
            if (_s != _test._s) {
                _t.errorf(((("%s.Sign() = %d; want %d" : GoString))), Go.toInterface(_test._x), Go.toInterface(_s), Go.toInterface(_test._s));
            };
        };
    }
function _alike(_x:Float_, _y:Float_):Bool {
        return (_x.cmp(_y) == ((0 : GoInt))) && (_x.signbit() == _y.signbit());
    }
function _alike32(_x:GoFloat32, _y:GoFloat32):Bool {
        return (_x == _y) && (stdgo.math.Math.signbit(((_x : GoFloat64))) == stdgo.math.Math.signbit(((_y : GoFloat64))));
    }
function _alike64(_x:GoFloat64, _y:GoFloat64):Bool {
        return (_x == _y) && (stdgo.math.Math.signbit(_x) == stdgo.math.Math.signbit(_y));
    }
function testFloatMantExp(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_13>(((new T__struct_13(((("0" : GoString))), ((("0" : GoString))), ((0 : GoInt))) : T__struct_13)), ((new T__struct_13(((("+0" : GoString))), ((("0" : GoString))), ((0 : GoInt))) : T__struct_13)), ((new T__struct_13(((("-0" : GoString))), ((("-0" : GoString))), ((0 : GoInt))) : T__struct_13)), ((new T__struct_13(((("Inf" : GoString))), ((("+Inf" : GoString))), ((0 : GoInt))) : T__struct_13)), ((new T__struct_13(((("+Inf" : GoString))), ((("+Inf" : GoString))), ((0 : GoInt))) : T__struct_13)), ((new T__struct_13(((("-Inf" : GoString))), ((("-Inf" : GoString))), ((0 : GoInt))) : T__struct_13)), ((new T__struct_13(((("1.5" : GoString))), ((("0.75" : GoString))), ((1 : GoInt))) : T__struct_13)), ((new T__struct_13(((("1.024e3" : GoString))), ((("0.5" : GoString))), ((11 : GoInt))) : T__struct_13)), ((new T__struct_13(((("-0.125" : GoString))), ((("-0.5" : GoString))), ((-2 : GoInt))) : T__struct_13))) : Slice<T__struct_13>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            var _mant:Ref<Float_> = _makeFloat(_test._mant);
            var _m:Ref<Float_> = new Float_();
            var _e:GoInt = _x.mantExp(_m);
            if (!_alike(_m, _mant) || (_e != _test._exp)) {
                _t.errorf(((("%s.MantExp() = %s, %d; want %s, %d" : GoString))), Go.toInterface(_test._x), Go.toInterface(_m.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_e), Go.toInterface(_test._mant), Go.toInterface(_test._exp));
            };
        };
    }
function testFloatMantExpAliasing(_t:stdgo.testing.Testing.T_):Void {
        var _x:Ref<Float_> = _makeFloat(((("0.5p10" : GoString))));
        {
            var _e:GoInt = _x.mantExp(_x);
            if (_e != ((10 : GoInt))) {
                _t.fatalf(((("Float.MantExp aliasing error: got %d; want 10" : GoString))), Go.toInterface(_e));
            };
        };
        {
            var _want:Ref<Float_> = _makeFloat(((("0.5" : GoString))));
            if (!_alike(_x, _want)) {
                _t.fatalf(((("Float.MantExp aliasing error: got %s; want %s" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_want.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))));
            };
        };
    }
function testFloatSetMantExp(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_14>(
((new T__struct_14(((("0" : GoString))), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_14)),
((new T__struct_14(((("+0" : GoString))), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_14)),
((new T__struct_14(((("-0" : GoString))), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_14)),
((new T__struct_14(((("Inf" : GoString))), ((1234 : GoInt)), ((("+Inf" : GoString)))) : T__struct_14)),
((new T__struct_14(((("+Inf" : GoString))), ((-1234 : GoInt)), ((("+Inf" : GoString)))) : T__struct_14)),
((new T__struct_14(((("-Inf" : GoString))), ((-1234 : GoInt)), ((("-Inf" : GoString)))) : T__struct_14)),
((new T__struct_14(((("0" : GoString))), ((-2147483648 : GoInt)), ((("0" : GoString)))) : T__struct_14)),
((new T__struct_14(((("0.25" : GoString))), ((-2147483648 : GoInt)), ((("+0" : GoString)))) : T__struct_14)),
((new T__struct_14(((("-0.25" : GoString))), ((-2147483648 : GoInt)), ((("-0" : GoString)))) : T__struct_14)),
((new T__struct_14(((("1" : GoString))), ((2147483647 : GoInt)), ((("+Inf" : GoString)))) : T__struct_14)),
((new T__struct_14(((("2" : GoString))), ((2147483646 : GoInt)), ((("+Inf" : GoString)))) : T__struct_14)),
((new T__struct_14(((("0.75" : GoString))), ((1 : GoInt)), ((("1.5" : GoString)))) : T__struct_14)),
((new T__struct_14(((("0.5" : GoString))), ((11 : GoInt)), ((("1024" : GoString)))) : T__struct_14)),
((new T__struct_14(((("-0.5" : GoString))), ((-2 : GoInt)), ((("-0.125" : GoString)))) : T__struct_14)),
((new T__struct_14(((("32" : GoString))), ((5 : GoInt)), ((("1024" : GoString)))) : T__struct_14)),
((new T__struct_14(((("1024" : GoString))), ((-10 : GoInt)), ((("1" : GoString)))) : T__struct_14))) : Slice<T__struct_14>))) {
            var _frac:Ref<Float_> = _makeFloat(_test._frac);
            var _want:Ref<Float_> = _makeFloat(_test._z);
            var _z:Float_ = new Float_();
            _z.setMantExp(_frac, _test._exp);
            if (!_alike(_z, _want)) {
                _t.errorf(((("SetMantExp(%s, %d) = %s; want %s" : GoString))), Go.toInterface(_test._frac), Go.toInterface(_test._exp), Go.toInterface(_z.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_test._z));
            };
            var _mant:Ref<Float_> = new Float_();
            if (_z.setMantExp(_mant, _want.mantExp(_mant)).cmp(_want) != ((0 : GoInt))) {
                _t.errorf(((("Inverse property not satisfied: got %s; want %s" : GoString))), Go.toInterface(_z.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_test._z));
            };
        };
    }
function testFloatPredicates(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_15>(((({ _x : ((("-Inf" : GoString))), _sign : ((-1 : GoInt)), _signbit : true, _inf : true } : T__struct_15)) == null ? null : (({ _x : ((("-Inf" : GoString))), _sign : ((-1 : GoInt)), _signbit : true, _inf : true } : T__struct_15)).__copy__()), ((({ _x : ((("-1" : GoString))), _sign : ((-1 : GoInt)), _signbit : true, _inf : false } : T__struct_15)) == null ? null : (({ _x : ((("-1" : GoString))), _sign : ((-1 : GoInt)), _signbit : true, _inf : false } : T__struct_15)).__copy__()), ((({ _x : ((("-0" : GoString))), _signbit : true, _sign : 0, _inf : false } : T__struct_15)) == null ? null : (({ _x : ((("-0" : GoString))), _signbit : true, _sign : 0, _inf : false } : T__struct_15)).__copy__()), ((({ _x : ((("0" : GoString))), _sign : 0, _signbit : false, _inf : false } : T__struct_15)) == null ? null : (({ _x : ((("0" : GoString))), _sign : 0, _signbit : false, _inf : false } : T__struct_15)).__copy__()), ((({ _x : ((("1" : GoString))), _sign : ((1 : GoInt)), _signbit : false, _inf : false } : T__struct_15)) == null ? null : (({ _x : ((("1" : GoString))), _sign : ((1 : GoInt)), _signbit : false, _inf : false } : T__struct_15)).__copy__()), ((({ _x : ((("+Inf" : GoString))), _sign : ((1 : GoInt)), _inf : true, _signbit : false } : T__struct_15)) == null ? null : (({ _x : ((("+Inf" : GoString))), _sign : ((1 : GoInt)), _inf : true, _signbit : false } : T__struct_15)).__copy__())) : Slice<T__struct_15>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            {
                var _got:Bool = _x.signbit();
                if (_got != _test._signbit) {
                    _t.errorf(((("(%s).Signbit() = %v; want %v" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._signbit));
                };
            };
            {
                var _got:GoInt = _x.sign();
                if (_got != _test._sign) {
                    _t.errorf(((("(%s).Sign() = %d; want %d" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._sign));
                };
            };
            {
                var _got:Bool = _x.isInf();
                if (_got != _test._inf) {
                    _t.errorf(((("(%s).IsInf() = %v; want %v" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._inf));
                };
            };
        };
    }
function testFloatIsInt(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<GoString>(
((("0 int" : GoString))),
((("-0 int" : GoString))),
((("1 int" : GoString))),
((("-1 int" : GoString))),
((("0.5" : GoString))),
((("1.23" : GoString))),
((("1.23e1" : GoString))),
((("1.23e2 int" : GoString))),
((("0.000000001e+8" : GoString))),
((("0.000000001e+9 int" : GoString))),
((("1.2345e200 int" : GoString))),
((("Inf" : GoString))),
((("+Inf" : GoString))),
((("-Inf" : GoString)))) : Slice<GoString>))) {
            var _s:GoString = stdgo.strings.Strings.trimSuffix(_test, (((" int" : GoString))));
            var _want:Bool = _s != _test;
            {
                var _got:Bool = _makeFloat(_s).isInt();
                if (_got != _want) {
                    _t.errorf(((("%s.IsInt() == %t" : GoString))), Go.toInterface(_s), Go.toInterface(_got));
                };
            };
        };
    }
function _fromBinary(_s:GoString):GoInt64 {
        var __tmp__ = stdgo.strconv.Strconv.parseInt(_s, ((2 : GoInt)), ((64 : GoInt))), _x:GoInt64 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            throw Go.toInterface(_err);
        };
        return _x;
    }
function _toBinary(_x:GoInt64):GoString {
        return stdgo.strconv.Strconv.formatInt(_x, ((2 : GoInt)));
    }
function _testFloatRound(_t:stdgo.testing.Testing.T_, _x:GoInt64, _r:GoInt64, _prec:GoUInt, _mode:RoundingMode):Void {
        var _ok:Bool = false;
        if (_mode == ((0 : GoUInt8)) || _mode == ((1 : GoUInt8))) {
            _ok = true;
        } else if (_mode == ((2 : GoUInt8))) {
            if (_x < ((0 : GoInt64))) {
                _ok = _r >= _x;
            } else {
                _ok = _r <= _x;
            };
        } else if (_mode == ((3 : GoUInt8))) {
            if (_x < ((0 : GoInt64))) {
                _ok = _r <= _x;
            } else {
                _ok = _r >= _x;
            };
        } else if (_mode == ((4 : GoUInt8))) {
            _ok = _r <= _x;
        } else if (_mode == ((5 : GoUInt8))) {
            _ok = _r >= _x;
        } else {
            throw Go.toInterface(((("unreachable" : GoString))));
        };
        if (!_ok) {
            _t.fatalf(((("incorrect test data for prec = %d, %s: x = %s, r = %s" : GoString))), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_toBinary(_x)), Go.toInterface(_toBinary(_r)));
        };
        var _a:Accuracy = ((0 : GoInt8));
        if (_r < _x) {
            _a = ((-1 : GoInt8));
        } else if (_r > _x) {
            _a = ((1 : GoInt8));
        };
        var _f:Ref<Float_> = new Float_().setMode(_mode).setInt64(_x).setPrec(_prec);
        var _r1:GoInt64 = _f._int64();
        var _p1:GoUInt = _f.prec();
        var _a1:Accuracy = _f.acc();
        if (((_r1 != _r) || (_p1 != _prec)) || (_a1 != _a)) {
            _t.errorf(((("round %s (%d bits, %s) incorrect: got %s (%d bits, %s); want %s (%d bits, %s)" : GoString))), Go.toInterface(_toBinary(_x)), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_toBinary(_r1)), Go.toInterface(_p1), Go.toInterface(_a1), Go.toInterface(_toBinary(_r)), Go.toInterface(_prec), Go.toInterface(_a));
            return;
        };
        var _g:Ref<Float_> = new Float_().setMode(_mode).setPrec(_prec).setInt64(_x);
        if (!_alike(_g, _f)) {
            _t.errorf(((("round %s (%d bits, %s) not symmetric: got %s and %s; want %s" : GoString))), Go.toInterface(_toBinary(_x)), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_toBinary(_g._int64())), Go.toInterface(_toBinary(_r1)), Go.toInterface(_toBinary(_r)));
            return;
        };
        var _h:Ref<Float_> = new Float_().setMode(_mode).setPrec(_prec).set(_f);
        if (!_alike(_h, _f)) {
            _t.errorf(((("round %s (%d bits, %s) not idempotent: got %s and %s; want %s" : GoString))), Go.toInterface(_toBinary(_x)), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_toBinary(_h._int64())), Go.toInterface(_toBinary(_r1)), Go.toInterface(_toBinary(_r)));
            return;
        };
    }
function testFloatRound(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_16>(
((new T__struct_16(((5 : GoUInt)), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1001" : GoString))), ((("1001" : GoString))), ((("1001" : GoString))), ((("1001" : GoString))), ((("1001" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1011" : GoString))), ((("1011" : GoString))), ((("1011" : GoString))), ((("1011" : GoString))), ((("1011" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1101" : GoString))), ((("1101" : GoString))), ((("1101" : GoString))), ((("1101" : GoString))), ((("1101" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString)))) : T__struct_16)),
((new T__struct_16(((5 : GoUInt)), ((("1111" : GoString))), ((("1111" : GoString))), ((("1111" : GoString))), ((("1111" : GoString))), ((("1111" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1001" : GoString))), ((("1001" : GoString))), ((("1001" : GoString))), ((("1001" : GoString))), ((("1001" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1011" : GoString))), ((("1011" : GoString))), ((("1011" : GoString))), ((("1011" : GoString))), ((("1011" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1101" : GoString))), ((("1101" : GoString))), ((("1101" : GoString))), ((("1101" : GoString))), ((("1101" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString)))) : T__struct_16)),
((new T__struct_16(((4 : GoUInt)), ((("1111" : GoString))), ((("1111" : GoString))), ((("1111" : GoString))), ((("1111" : GoString))), ((("1111" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1001" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1010" : GoString))), ((("1010" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString))), ((("1010" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1011" : GoString))), ((("1010" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1101" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1110" : GoString))), ((("1110" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString))), ((("1110" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1111" : GoString))), ((("1110" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1000001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1010000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1001001" : GoString))), ((("1000000" : GoString))), ((("1010000" : GoString))), ((("1010000" : GoString))), ((("1010000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1010001" : GoString))), ((("1010000" : GoString))), ((("1010000" : GoString))), ((("1010000" : GoString))), ((("1100000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1011001" : GoString))), ((("1010000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1100001" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1110000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1101001" : GoString))), ((("1100000" : GoString))), ((("1110000" : GoString))), ((("1110000" : GoString))), ((("1110000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1110001" : GoString))), ((("1110000" : GoString))), ((("1110000" : GoString))), ((("1110000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((3 : GoUInt)), ((("1111001" : GoString))), ((("1110000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1001" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1010" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1011" : GoString))), ((("1000" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1101" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("1100" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1110" : GoString))), ((("1100" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1111" : GoString))), ((("1100" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1000001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1100000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1001001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1100000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1010001" : GoString))), ((("1000000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1011001" : GoString))), ((("1000000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1100001" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1101001" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("1100000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1110001" : GoString))), ((("1100000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((2 : GoUInt)), ((("1111001" : GoString))), ((("1100000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1001" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1010" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1011" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("1000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1100" : GoString))), ((("1000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1101" : GoString))), ((("1000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1110" : GoString))), ((("1000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1111" : GoString))), ((("1000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString))), ((("10000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1000001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1001001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1010001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1011001" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1100001" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1101001" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1110001" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16)),
((new T__struct_16(((1 : GoUInt)), ((("1111001" : GoString))), ((("1000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString))), ((("10000000" : GoString)))) : T__struct_16))) : Slice<T__struct_16>))) {
            var _x:GoInt64 = _fromBinary(_test._x);
            var _z:GoInt64 = _fromBinary(_test._zero);
            var _e:GoInt64 = _fromBinary(_test._neven);
            var _n:GoInt64 = _fromBinary(_test._naway);
            var _a:GoInt64 = _fromBinary(_test._away);
            var _prec:GoUInt = _test._prec;
            _testFloatRound(_t, _x, _z, _prec, ((2 : GoUInt8)));
            _testFloatRound(_t, _x, _e, _prec, ((0 : GoUInt8)));
            _testFloatRound(_t, _x, _n, _prec, ((1 : GoUInt8)));
            _testFloatRound(_t, _x, _a, _prec, ((3 : GoUInt8)));
            _testFloatRound(_t, _x, _z, _prec, ((4 : GoUInt8)));
            _testFloatRound(_t, _x, _a, _prec, ((5 : GoUInt8)));
            _testFloatRound(_t, -_x, -_a, _prec, ((4 : GoUInt8)));
            _testFloatRound(_t, -_x, -_z, _prec, ((5 : GoUInt8)));
        };
    }
function testFloatRound24(_t:stdgo.testing.Testing.T_):Void {
        {};
        {
            var _d:GoInt = ((0 : GoInt));
            Go.cfor(_d <= ((16 : GoInt)), _d++, {
                var _x:GoFloat64 = (((((67108848 : GoInt)) + _d) : GoFloat64));
                var _f:Ref<Float_> = new Float_().setPrec(((24 : GoUInt))).setFloat64(_x);
                var __tmp__ = _f.float32(), _got:GoFloat32 = __tmp__._0, _0:Accuracy = __tmp__._1;
                var _want:GoFloat32 = ((_x : GoFloat32));
                if (_got != _want) {
                    _t.errorf(((("Round(%g, 24) = %g; want %g" : GoString))), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSetUint64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _want in ((new Slice<GoUInt64>(((0 : GoUInt64)), ((1 : GoUInt64)), ((2 : GoUInt64)), ((10 : GoUInt64)), ((100 : GoUInt64)), (("4294967295" : GoUInt64)), (("4294967296" : GoUInt64)), (("18446744073709551615" : GoUInt64))) : Slice<GoUInt64>))) {
            var _f:Float_ = new Float_();
            _f.setUint64(_want);
            {
                var _got:GoUInt64 = _f._uint64();
                if (_got != _want) {
                    _t.errorf(((("got %#x (%s); want %#x" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
                };
            };
        };
        {};
        {
            var _prec:GoUInt = ((((1 : GoUInt)) : GoUInt));
            Go.cfor(_prec <= ((64 : GoUInt)), _prec++, {
                var _f:Ref<Float_> = new Float_().setPrec(_prec).setMode(((2 : GoUInt8))).setUint64((("9756277979052589857" : GoUInt64)));
                var _got:GoUInt64 = _f._uint64();
                var _want:GoUInt64 = (("9756277979052589857" : GoUInt64)) & (((((1 : GoUInt64)) << (((64 : GoUInt)) - _prec)) - ((1 : GoUInt64))) ^ ((-1 : GoUnTypedInt)));
                if (_got != _want) {
                    _t.errorf(((("got %#x (%s); want %#x" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSetInt64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _want in ((new Slice<GoInt64>(((0 : GoInt64)), ((1 : GoInt64)), ((2 : GoInt64)), ((10 : GoInt64)), ((100 : GoInt64)), (("4294967295" : GoInt64)), (("4294967296" : GoInt64)), (("9223372036854775807" : GoInt64))) : Slice<GoInt64>))) {
            for (_i => _ in ((new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) 0]))) : GoArray<GoInt>))) {
                if ((_i & ((1 : GoInt))) != ((0 : GoInt))) {
                    _want = -_want;
                };
                var _f:Float_ = new Float_();
                _f.setInt64(_want);
                {
                    var _got:GoInt64 = _f._int64();
                    if (_got != _want) {
                        _t.errorf(((("got %#x (%s); want %#x" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
                    };
                };
            };
        };
        {};
        {
            var _prec:GoUInt = ((((1 : GoUInt)) : GoUInt));
            Go.cfor(_prec <= ((63 : GoUInt)), _prec++, {
                var _f:Ref<Float_> = new Float_().setPrec(_prec).setMode(((2 : GoUInt8))).setInt64((("8526495040805286416" : GoInt64)));
                var _got:GoInt64 = _f._int64();
                var _want:GoInt64 = (("8526495040805286416" : GoInt64)) & (((((1 : GoInt64)) << (((63 : GoUInt)) - _prec)) - ((1 : GoInt64))) ^ ((-1 : GoUnTypedInt)));
                if (_got != _want) {
                    _t.errorf(((("got %#x (%s); want %#x" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSetFloat64(_t:stdgo.testing.Testing.T_):Void {
        var __recover_exception__:AnyInterface = null;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            for (_0 => _want in ((new Slice<GoFloat64>(
((0 : GoFloat64)),
((1 : GoFloat64)),
((2 : GoFloat64)),
((12345 : GoFloat64)),
((1e+10 : GoFloat64)),
((1e+100 : GoFloat64)),
((3.14159265e+10 : GoFloat64)),
((2.718281828e-123 : GoFloat64)),
((0.3333333333333333 : GoFloat64)),
((3.4028234663852886e+38 : GoFloat64)),
((1.7976931348623157e+308 : GoFloat64)),
((1.401298464324817e-45 : GoFloat64)),
((5e-324 : GoFloat64)),
stdgo.math.Math.inf(((-1 : GoInt))),
stdgo.math.Math.inf(((0 : GoInt))),
-stdgo.math.Math.inf(((1 : GoInt)))) : Slice<GoFloat64>))) {
                for (_i => _ in ((new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) 0]))) : GoArray<GoInt>))) {
                    if ((_i & ((1 : GoInt))) != ((0 : GoInt))) {
                        _want = -_want;
                    };
                    var _f:Float_ = new Float_();
                    _f.setFloat64(_want);
                    {
                        var __tmp__ = _f.float64(), _got:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                        if ((_got != _want) || (_acc != ((0 : GoInt8)))) {
                            _t.errorf(((("got %g (%s, %s); want %g (Exact)" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_acc), Go.toInterface(_want));
                        };
                    };
                };
            };
            {};
            {
                var _prec:GoUInt = ((((1 : GoUInt)) : GoUInt));
                Go.cfor(_prec <= ((52 : GoUInt)), _prec++, {
                    var _f:Ref<Float_> = new Float_().setPrec(_prec).setMode(((2 : GoUInt8))).setFloat64((((("2381903803200024" : GoUInt64)) : GoFloat64)));
                    var __tmp__ = _f.float64(), _got:GoFloat64 = __tmp__._0, _1:Accuracy = __tmp__._1;
                    var _want:GoFloat64 = ((((("2381903803200024" : GoUInt64)) & (((((1 : GoUInt64)) << (((52 : GoUInt)) - _prec)) - ((1 : GoUInt64))) ^ ((-1 : GoUnTypedInt)))) : GoFloat64));
                    if (_got != _want) {
                        _t.errorf(((("got %g (%s); want %g" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
                    };
                });
            };
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    {
                        var __tmp__ = try {
                            { value : ((({
                                final r = __recover_exception__;
                                __recover_exception__ = null;
                                r;
                            }).value : ErrNaN)), ok : true };
                        } catch(_) {
                            { value : new ErrNaN(), ok : false };
                        }, _p = __tmp__.value, _ok = __tmp__.ok;
                        if (!_ok) {
                            _t.errorf(((("got %v; want ErrNaN panic" : GoString))), Go.toInterface(_p));
                        };
                    };
                };
                a();
            });
            var _f:Float_ = new Float_();
            _f.setFloat64(stdgo.math.Math.naN());
            _t.errorf(((("got %s; want ErrNaN panic" : GoString))), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))));
            for (defer in __deferstack__) {
                defer();
            };
        } catch(__exception__) {
            if (!(__exception__.native is AnyInterfaceData)) throw __exception__;
            __recover_exception__ = __exception__.native;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (__recover_exception__ != null) throw __recover_exception__;
                return;
            };
        };
    }
function testFloatSetInt(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _want in ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("-1" : GoString))), ((("1234567890" : GoString))), ((("123456789012345678901234567890" : GoString))), ((("123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" : GoString)))) : Slice<GoString>))) {
            var _x:Int_ = new Int_();
            var __tmp__ = _x.setString(_want, ((0 : GoInt))), _1:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("invalid integer %s" : GoString))), Go.toInterface(_want));
                continue;
            };
            var _n:GoInt = _x.bitLen();
            var _f:Float_ = new Float_();
            _f.setInt(_x);
            if (_n < ((64 : GoInt))) {
                _n = ((64 : GoInt));
            };
            {
                var _prec:GoUInt = _f.prec();
                if (_prec != ((_n : GoUInt))) {
                    _t.errorf(((("got prec = %d; want %d" : GoString))), Go.toInterface(_prec), Go.toInterface(_n));
                };
            };
            var _got:GoString = _f.text(((((("g" : GoString))).code : GoRune)), ((100 : GoInt)));
            if (_got != _want) {
                _t.errorf(((("got %s (%s); want %s" : GoString))), Go.toInterface(_got), Go.toInterface(_f.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
            };
        };
    }
function testFloatSetRat(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _want in ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("-1" : GoString))), ((("1234567890" : GoString))), ((("123456789012345678901234567890" : GoString))), ((("123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" : GoString))), ((("1.2" : GoString))), ((("3.14159265" : GoString)))) : Slice<GoString>))) {
            var _x:Rat = new Rat();
            var __tmp__ = _x.setString(_want), _1:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("invalid fraction %s" : GoString))), Go.toInterface(_want));
                continue;
            };
            var _n:GoInt = _max(_x.num().bitLen(), _x.denom().bitLen());
            var _f1:Float_ = new Float_(), _f2:Float_ = new Float_();
            _f2.setPrec(((1000 : GoUInt)));
            _f1.setRat(_x);
            _f2.setRat(_x);
            if (_n < ((64 : GoInt))) {
                _n = ((64 : GoInt));
            };
            {
                var _prec:GoUInt = _f1.prec();
                if (_prec != ((_n : GoUInt))) {
                    _t.errorf(((("got prec = %d; want %d" : GoString))), Go.toInterface(_prec), Go.toInterface(_n));
                };
            };
            var _got:GoString = _f2.text(((((("g" : GoString))).code : GoRune)), ((100 : GoInt)));
            if (_got != _want) {
                _t.errorf(((("got %s (%s); want %s" : GoString))), Go.toInterface(_got), Go.toInterface(_f2.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_want));
            };
        };
    }
function testFloatSetInf(_t:stdgo.testing.Testing.T_):Void {
        var _f:Float_ = new Float_();
        for (_0 => _test in ((new Slice<T__struct_17>(((new T__struct_17(false, ((0 : GoUInt)), ((("+Inf" : GoString)))) : T__struct_17)), ((new T__struct_17(true, ((0 : GoUInt)), ((("-Inf" : GoString)))) : T__struct_17)), ((new T__struct_17(false, ((10 : GoUInt)), ((("+Inf" : GoString)))) : T__struct_17)), ((new T__struct_17(true, ((30 : GoUInt)), ((("-Inf" : GoString)))) : T__struct_17))) : Slice<T__struct_17>))) {
            var _x:Ref<Float_> = _f.setPrec(_test._prec).setInf(_test._signbit);
            {
                var _got:GoString = ((_x.toString() : GoString));
                if ((_got != _test._want) || (_x.prec() != _test._prec)) {
                    _t.errorf(((("SetInf(%v) = %s (prec = %d); want %s (prec = %d)" : GoString))), Go.toInterface(_test._signbit), Go.toInterface(_got), Go.toInterface(_x.prec()), Go.toInterface(_test._want), Go.toInterface(_test._prec));
                };
            };
        };
    }
function testFloatUint64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_18>(
((new T__struct_18(((("-Inf" : GoString))), ((0 : GoUInt64)), ((1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("-1" : GoString))), ((0 : GoUInt64)), ((1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("-1e-1000" : GoString))), ((0 : GoUInt64)), ((1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("-0" : GoString))), ((0 : GoUInt64)), ((0 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("0" : GoString))), ((0 : GoUInt64)), ((0 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("1e-1000" : GoString))), ((0 : GoUInt64)), ((-1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("1" : GoString))), ((1 : GoUInt64)), ((0 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("1.000000000000000000001" : GoString))), ((1 : GoUInt64)), ((-1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("12345.0" : GoString))), ((12345 : GoUInt64)), ((0 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("12345.000000000000000000001" : GoString))), ((12345 : GoUInt64)), ((-1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("18446744073709551615" : GoString))), (("18446744073709551615" : GoUInt64)), ((0 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("18446744073709551615.000000000000000000001" : GoString))), (("18446744073709551615" : GoUInt64)), ((-1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("18446744073709551616" : GoString))), (("18446744073709551615" : GoUInt64)), ((-1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("1e10000" : GoString))), (("18446744073709551615" : GoUInt64)), ((-1 : GoInt8))) : T__struct_18)),
((new T__struct_18(((("+Inf" : GoString))), (("18446744073709551615" : GoUInt64)), ((-1 : GoInt8))) : T__struct_18))) : Slice<T__struct_18>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            var __tmp__ = _x.uint64(), _out:GoUInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
            if ((_out != _test._out) || (_acc != _test._acc)) {
                _t.errorf(((("%s: got %d (%s); want %d (%s)" : GoString))), Go.toInterface(_test._x), Go.toInterface(_out), Go.toInterface(_acc), Go.toInterface(_test._out), Go.toInterface(_test._acc));
            };
        };
    }
function testFloatInt64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_19>(
((new T__struct_19(((("-Inf" : GoString))), (("-9223372036854775808" : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-1e10000" : GoString))), (("-9223372036854775808" : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-9223372036854775809" : GoString))), (("-9223372036854775808" : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-9223372036854775808.000000000000000000001" : GoString))), (("-9223372036854775808" : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-9223372036854775808" : GoString))), (("-9223372036854775808" : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-9223372036854775807.000000000000000000001" : GoString))), (("-9223372036854775807" : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-9223372036854775807" : GoString))), (("-9223372036854775807" : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-12345.000000000000000000001" : GoString))), ((-12345 : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-12345.0" : GoString))), ((-12345 : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-1.000000000000000000001" : GoString))), ((-1 : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-1.5" : GoString))), ((-1 : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-1" : GoString))), ((-1 : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("-1e-1000" : GoString))), ((0 : GoInt64)), ((1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("0" : GoString))), ((0 : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("1e-1000" : GoString))), ((0 : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("1" : GoString))), ((1 : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("1.000000000000000000001" : GoString))), ((1 : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("1.5" : GoString))), ((1 : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("12345.0" : GoString))), ((12345 : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("12345.000000000000000000001" : GoString))), ((12345 : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("9223372036854775807" : GoString))), (("9223372036854775807" : GoInt64)), ((0 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("9223372036854775807.000000000000000000001" : GoString))), (("9223372036854775807" : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("9223372036854775808" : GoString))), (("9223372036854775807" : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("1e10000" : GoString))), (("9223372036854775807" : GoInt64)), ((-1 : GoInt8))) : T__struct_19)),
((new T__struct_19(((("+Inf" : GoString))), (("9223372036854775807" : GoInt64)), ((-1 : GoInt8))) : T__struct_19))) : Slice<T__struct_19>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            var __tmp__ = _x.int64(), _out:GoInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
            if ((_out != _test._out) || (_acc != _test._acc)) {
                _t.errorf(((("%s: got %d (%s); want %d (%s)" : GoString))), Go.toInterface(_test._x), Go.toInterface(_out), Go.toInterface(_acc), Go.toInterface(_test._out), Go.toInterface(_test._acc));
            };
        };
    }
function testFloatFloat32(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_20>(
((new T__struct_20(((("0" : GoString))), ((0 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1e-1000" : GoString))), ((0 : GoFloat32)), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.000002p-127" : GoString))), ((0 : GoFloat32)), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.0000010p-126" : GoString))), ((0 : GoFloat32)), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1.401298464e-45" : GoString))), ((1.401298464324817e-45 : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.ffffff8p-149" : GoString))), ((1.401298464324817e-45 : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.0000018p-126" : GoString))), ((1.401298464324817e-45 : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.0000020p-126" : GoString))), ((1.401298464324817e-45 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.8p-148" : GoString))), ((1.401298464324817e-45 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1p-149" : GoString))), ((1.401298464324817e-45 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.fffffep-126" : GoString))), stdgo.math.Math.float32frombits(((8388607 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.0000001p-126" : GoString))), stdgo.math.Math.float32frombits(((0 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.0000008p-126" : GoString))), stdgo.math.Math.float32frombits(((0 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.0000010p-126" : GoString))), stdgo.math.Math.float32frombits(((0 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.0000011p-126" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.0000018p-126" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.0000000p-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.0000020p-126" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.fffffe0p-126" : GoString))), stdgo.math.Math.float32frombits(((8388607 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.0000000p-126" : GoString))), stdgo.math.Math.float32frombits(((8388608 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.8p-149" : GoString))), stdgo.math.Math.float32frombits(((0 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.9p-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.ap-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.bp-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x0.cp-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.0p-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.7p-149" : GoString))), stdgo.math.Math.float32frombits(((1 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.8p-149" : GoString))), stdgo.math.Math.float32frombits(((2 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.9p-149" : GoString))), stdgo.math.Math.float32frombits(((2 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x2.0p-149" : GoString))), stdgo.math.Math.float32frombits(((2 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x2.8p-149" : GoString))), stdgo.math.Math.float32frombits(((2 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x2.9p-149" : GoString))), stdgo.math.Math.float32frombits(((3 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x3.0p-149" : GoString))), stdgo.math.Math.float32frombits(((3 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x3.7p-149" : GoString))), stdgo.math.Math.float32frombits(((3 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x3.8p-149" : GoString))), stdgo.math.Math.float32frombits(((4 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x4.0p-149" : GoString))), stdgo.math.Math.float32frombits(((4 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x4.8p-149" : GoString))), stdgo.math.Math.float32frombits(((4 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x4.9p-149" : GoString))), stdgo.math.Math.float32frombits(((5 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x7.7p-149" : GoString))), stdgo.math.Math.float32frombits(((7 : GoUInt32))), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x7.8p-149" : GoString))), stdgo.math.Math.float32frombits(((8 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x7.9p-149" : GoString))), stdgo.math.Math.float32frombits(((8 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x.ffffffp-126" : GoString))), stdgo.math.Math.float32frombits(((8388608 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1p-126" : GoString))), stdgo.math.Math.float32frombits(((8388608 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.fffffep-126" : GoString))), stdgo.math.Math.float32frombits(((16777215 : GoUInt32))), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.ffffffp-126" : GoString))), stdgo.math.Math.float32frombits(((16777216 : GoUInt32))), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1" : GoString))), ((1 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1.000000000000000000001" : GoString))), ((1 : GoFloat32)), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("12345.0" : GoString))), ((12345 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("12345.000000000000000000001" : GoString))), ((12345 : GoFloat32)), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.fffffe0p127" : GoString))), ((3.4028234663852886e+38 : GoFloat32)), ((0 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.fffffe8p127" : GoString))), ((3.4028234663852886e+38 : GoFloat32)), ((-1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.ffffff0p127" : GoString))), ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1p128" : GoString))), ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("1e10000" : GoString))), ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("0x1.ffffff0p2147483646" : GoString))), ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), ((1 : GoInt8))) : T__struct_20)),
((new T__struct_20(((("Inf" : GoString))), ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), ((0 : GoInt8))) : T__struct_20))) : Slice<T__struct_20>))) {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < ((2 : GoInt)), _i++, {
                    var _tx:GoString = _test._x, _tout:GoFloat32 = _test._out, _tacc:Accuracy = _test._acc;
                    if (_i != ((0 : GoInt))) {
                        _tx = ((("-" : GoString))) + _tx;
                        _tout = -_tout;
                        _tacc = -_tacc;
                    };
                    {
                        var __tmp__ = stdgo.strconv.Strconv.parseFloat(_tx, ((32 : GoInt))), _f:GoFloat64 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                        if ((_err == null) && !_alike32(((_f : GoFloat32)), _tout)) {
                            _t.errorf(((("%s: got %g; want %g (incorrect test data)" : GoString))), Go.toInterface(_tx), Go.toInterface(_f), Go.toInterface(_tout));
                        };
                    };
                    var _x:Ref<Float_> = _makeFloat(_tx);
                    var __tmp__ = _x.float32(), _out:GoFloat32 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                    if (!_alike32(_out, _tout) || (_acc != _tacc)) {
                        _t.errorf(((("%s: got %g (%#08x, %s); want %g (%#08x, %s)" : GoString))), Go.toInterface(_tx), Go.toInterface(_out), Go.toInterface(stdgo.math.Math.float32bits(_out)), Go.toInterface(_acc), Go.toInterface(_test._out), Go.toInterface(stdgo.math.Math.float32bits(_test._out)), Go.toInterface(_tacc));
                    };
                    var _x2:Float_ = new Float_();
                    var __tmp__ = _x2.setFloat64(((_out : GoFloat64))).float32(), _out2:GoFloat32 = __tmp__._0, _acc2:Accuracy = __tmp__._1;
                    if (!_alike32(_out2, _out) || (_acc2 != ((0 : GoInt8)))) {
                        _t.errorf(((("idempotency test: got %g (%s); want %g (Exact)" : GoString))), Go.toInterface(_out2), Go.toInterface(_acc2), Go.toInterface(_out));
                    };
                });
            };
        };
    }
function testFloatFloat64(_t:stdgo.testing.Testing.T_):Void {
        {};
        for (_0 => _test in ((new Slice<T__struct_21>(
((new T__struct_21(((("0" : GoString))), ((0 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("1e-1000" : GoString))), ((0 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.0000000000001p-1023" : GoString))), ((0 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.00000000000008p-1022" : GoString))), ((0 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.0000000000000cp-1022" : GoString))), ((5e-324 : GoFloat64)), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.00000000000010p-1022" : GoString))), ((5e-324 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x.8p-1073" : GoString))), ((5e-324 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("1p-1074" : GoString))), ((5e-324 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x.fffffffffffffp-1022" : GoString))), stdgo.math.Math.float64frombits((("4503599627370495" : GoUInt64))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.00000000000001p-1022" : GoString))), stdgo.math.Math.float64frombits(((0 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.00000000000004p-1022" : GoString))), stdgo.math.Math.float64frombits(((0 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.00000000000008p-1022" : GoString))), stdgo.math.Math.float64frombits(((0 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.00000000000009p-1022" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.0000000000000ap-1022" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.8p-1074" : GoString))), stdgo.math.Math.float64frombits(((0 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.9p-1074" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.ap-1074" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.bp-1074" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x0.cp-1074" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.0p-1074" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.7p-1074" : GoString))), stdgo.math.Math.float64frombits(((1 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.8p-1074" : GoString))), stdgo.math.Math.float64frombits(((2 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.9p-1074" : GoString))), stdgo.math.Math.float64frombits(((2 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x2.0p-1074" : GoString))), stdgo.math.Math.float64frombits(((2 : GoUInt64))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x2.8p-1074" : GoString))), stdgo.math.Math.float64frombits(((2 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x2.9p-1074" : GoString))), stdgo.math.Math.float64frombits(((3 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x3.0p-1074" : GoString))), stdgo.math.Math.float64frombits(((3 : GoUInt64))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x3.7p-1074" : GoString))), stdgo.math.Math.float64frombits(((3 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x3.8p-1074" : GoString))), stdgo.math.Math.float64frombits(((4 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x4.0p-1074" : GoString))), stdgo.math.Math.float64frombits(((4 : GoUInt64))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x4.8p-1074" : GoString))), stdgo.math.Math.float64frombits(((4 : GoUInt64))), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x4.9p-1074" : GoString))), stdgo.math.Math.float64frombits(((5 : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x.fffffffffffff8p-1022" : GoString))), stdgo.math.Math.float64frombits((("4503599627370496" : GoUInt64))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("1p-1022" : GoString))), stdgo.math.Math.float64frombits((("4503599627370496" : GoUInt64))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("1" : GoString))), ((1 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("1.000000000000000000001" : GoString))), ((1 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("12345.0" : GoString))), ((12345 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("12345.000000000000000000001" : GoString))), ((12345 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.fffffffffffff0p1023" : GoString))), ((1.7976931348623157e+308 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.fffffffffffff4p1023" : GoString))), ((1.7976931348623157e+308 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.fffffffffffff8p1023" : GoString))), stdgo.math.Math.inf(((1 : GoInt))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1p1024" : GoString))), stdgo.math.Math.inf(((1 : GoInt))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("1e10000" : GoString))), stdgo.math.Math.inf(((1 : GoInt))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x1.fffffffffffff8p2147483646" : GoString))), stdgo.math.Math.inf(((1 : GoInt))), ((1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("Inf" : GoString))), stdgo.math.Math.inf(((1 : GoInt))), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("0x.fffffffffffffp-1022" : GoString))), ((2.225073858507201e-308 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("4503599627370495p-1074" : GoString))), ((2.225073858507201e-308 : GoFloat64)), ((0 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("2.2250738585072011e-308" : GoString))), ((2.225073858507201e-308 : GoFloat64)), ((-1 : GoInt8))) : T__struct_21)),
((new T__struct_21(((("2.2250738585072012e-308" : GoString))), ((2.2250738585072014e-308 : GoFloat64)), ((1 : GoInt8))) : T__struct_21))) : Slice<T__struct_21>))) {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < ((2 : GoInt)), _i++, {
                    var _tx:GoString = _test._x, _tout:GoFloat64 = _test._out, _tacc:Accuracy = _test._acc;
                    if (_i != ((0 : GoInt))) {
                        _tx = ((("-" : GoString))) + _tx;
                        _tout = -_tout;
                        _tacc = -_tacc;
                    };
                    {
                        var __tmp__ = stdgo.strconv.Strconv.parseFloat(_tx, ((64 : GoInt))), _f:GoFloat64 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                        if ((_err == null) && !_alike64(_f, _tout)) {
                            _t.errorf(((("%s: got %g; want %g (incorrect test data)" : GoString))), Go.toInterface(_tx), Go.toInterface(_f), Go.toInterface(_tout));
                        };
                    };
                    var _x:Ref<Float_> = _makeFloat(_tx);
                    var __tmp__ = _x.float64(), _out:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                    if (!_alike64(_out, _tout) || (_acc != _tacc)) {
                        _t.errorf(((("%s: got %g (%#016x, %s); want %g (%#016x, %s)" : GoString))), Go.toInterface(_tx), Go.toInterface(_out), Go.toInterface(stdgo.math.Math.float64bits(_out)), Go.toInterface(_acc), Go.toInterface(_test._out), Go.toInterface(stdgo.math.Math.float64bits(_test._out)), Go.toInterface(_tacc));
                    };
                    var _x2:Float_ = new Float_();
                    var __tmp__ = _x2.setFloat64(_out).float64(), _out2:GoFloat64 = __tmp__._0, _acc2:Accuracy = __tmp__._1;
                    if (!_alike64(_out2, _out) || (_acc2 != ((0 : GoInt8)))) {
                        _t.errorf(((("idempotency test: got %g (%s); want %g (Exact)" : GoString))), Go.toInterface(_out2), Go.toInterface(_acc2), Go.toInterface(_out));
                    };
                });
            };
        };
    }
function testFloatInt(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_22>(
((new T__struct_22(((("0" : GoString))), ((("0" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("+0" : GoString))), ((("0" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-0" : GoString))), ((("0" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("Inf" : GoString))), ((("nil" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("+Inf" : GoString))), ((("nil" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-Inf" : GoString))), ((("nil" : GoString))), ((1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1" : GoString))), ((("1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-1" : GoString))), ((("-1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1.23" : GoString))), ((("1" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-1.23" : GoString))), ((("-1" : GoString))), ((1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("123e-2" : GoString))), ((("1" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("123e-3" : GoString))), ((("0" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("123e-4" : GoString))), ((("0" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1e-1000" : GoString))), ((("0" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-1e-1000" : GoString))), ((("0" : GoString))), ((1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1e+10" : GoString))), ((("10000000000" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1e+100" : GoString))), ((("10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" : GoString))), ((0 : GoInt8))) : T__struct_22))) : Slice<T__struct_22>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            var __tmp__ = _x.int(null), _res:Ref<Int_> = __tmp__._0, _acc:Accuracy = __tmp__._1;
            var _got:GoString = ((("nil" : GoString)));
            if (_res != null) {
                _got = ((_res.toString() : GoString));
            };
            if ((_got != _test._want) || (_acc != _test._acc)) {
                _t.errorf(((("%s: got %s (%s); want %s (%s)" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_test._want), Go.toInterface(_test._acc));
            };
        };
        for (_1 => _f in ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("-1" : GoString))), ((("1234" : GoString)))) : Slice<GoString>))) {
            var _x:Ref<Float_> = _makeFloat(_f);
            var _i:Ref<Int_> = new Int_();
            {
                var __tmp__ = _x.int(_i), _res:Ref<Int_> = __tmp__._0, _2:Accuracy = __tmp__._1;
                if (_res != _i) {
                    _t.errorf(((("(%s).Int is not using supplied *Int" : GoString))), Go.toInterface(_f));
                };
            };
        };
    }
function testFloatRat(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_22>(
((new T__struct_22(((("0" : GoString))), ((("0/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("+0" : GoString))), ((("0/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-0" : GoString))), ((("0/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("Inf" : GoString))), ((("nil" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("+Inf" : GoString))), ((("nil" : GoString))), ((-1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-Inf" : GoString))), ((("nil" : GoString))), ((1 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1" : GoString))), ((("1/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-1" : GoString))), ((("-1/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1.25" : GoString))), ((("5/4" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-1.25" : GoString))), ((("-5/4" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1e10" : GoString))), ((("10000000000/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("1p10" : GoString))), ((("1024/1" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("-1p-10" : GoString))), ((("-1/1024" : GoString))), ((0 : GoInt8))) : T__struct_22)),
((new T__struct_22(((("3.14159265" : GoString))), ((("7244019449799623199/2305843009213693952" : GoString))), ((0 : GoInt8))) : T__struct_22))) : Slice<T__struct_22>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x).setPrec(((64 : GoUInt)));
            var __tmp__ = _x.rat(null), _res:Ref<Rat> = __tmp__._0, _acc:Accuracy = __tmp__._1;
            var _got:GoString = ((("nil" : GoString)));
            if (_res != null) {
                _got = ((_res.toString() : GoString));
            };
            if (_got != _test._want) {
                _t.errorf(((("%s: got %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_test._want));
                continue;
            };
            if (_acc != _test._acc) {
                _t.errorf(((("%s: got %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_acc), Go.toInterface(_test._acc));
                continue;
            };
            if (_res != null) {
                var _got:Ref<Float_> = new Float_().setPrec(((64 : GoUInt))).setRat(_res);
                if (_got.cmp(_x) != ((0 : GoInt))) {
                    _t.errorf(((("%s: got %s; want %s" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_x));
                };
            };
        };
        for (_1 => _f in ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("-1" : GoString))), ((("1234" : GoString)))) : Slice<GoString>))) {
            var _x:Ref<Float_> = _makeFloat(_f);
            var _r:Ref<Rat> = new Rat();
            {
                var __tmp__ = _x.rat(_r), _res:Ref<Rat> = __tmp__._0, _2:Accuracy = __tmp__._1;
                if (_res != _r) {
                    _t.errorf(((("(%s).Rat is not using supplied *Rat" : GoString))), Go.toInterface(_f));
                };
            };
        };
    }
function testFloatAbs(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("1234" : GoString))), ((("1.23e-2" : GoString))), ((("1e-1000" : GoString))), ((("1e1000" : GoString))), ((("Inf" : GoString)))) : Slice<GoString>))) {
            var _p:Ref<Float_> = _makeFloat(_test);
            var _a:Ref<Float_> = new Float_().abs(_p);
            if (!_alike(_a, _p)) {
                _t.errorf(((("%s: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_a.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_test));
            };
            var _n:Ref<Float_> = _makeFloat(((("-" : GoString))) + _test);
            _a.abs(_n);
            if (!_alike(_a, _p)) {
                _t.errorf(((("-%s: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_a.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_test));
            };
        };
    }
function testFloatNeg(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<GoString>(((("0" : GoString))), ((("1" : GoString))), ((("1234" : GoString))), ((("1.23e-2" : GoString))), ((("1e-1000" : GoString))), ((("1e1000" : GoString))), ((("Inf" : GoString)))) : Slice<GoString>))) {
            var _p1:Ref<Float_> = _makeFloat(_test);
            var _n1:Ref<Float_> = _makeFloat(((("-" : GoString))) + _test);
            var _n2:Ref<Float_> = new Float_().neg(_p1);
            var _p2:Ref<Float_> = new Float_().neg(_n2);
            if (!_alike(_n2, _n1)) {
                _t.errorf(((("%s: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_n2.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_n1.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))));
            };
            if (!_alike(_p2, _p1)) {
                _t.errorf(((("%s: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_p2.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))), Go.toInterface(_p1.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)))));
            };
        };
    }
function testFloatInc(_t:stdgo.testing.Testing.T_):Void {
        {};
        for (_0 => _prec in _precList) {
            if ((((1 : GoInt)) << _prec) < ((10 : GoInt))) {
                continue;
            };
            var _x:Float_ = new Float_(), _one:Float_ = new Float_();
            _x.setPrec(_prec);
            _one.setInt64(((1 : GoInt64)));
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < ((10 : GoInt)), _i++, {
                    _x.add(_x, _one);
                });
            };
            if (_x.cmp(new Float_().setInt64(((10 : GoInt64)))) != ((0 : GoInt))) {
                _t.errorf(((("prec = %d: got %s; want %d" : GoString))), Go.toInterface(_prec), Go.toInterface(_x), Go.toInterface(((10 : GoInt))));
            };
        };
    }
function testFloatAdd(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _xbits in _bitsList) {
            for (_1 => _ybits in _bitsList) {
                var _x:Ref<Float_> = _xbits.float();
                var _y:Ref<Float_> = _ybits.float();
                var _zbits:Bits = (_xbits._add((_ybits == null ? null : _ybits.__copy__())) == null ? null : _xbits._add((_ybits == null ? null : _ybits.__copy__())).__copy__());
                var _z:Ref<Float_> = _zbits.float();
                for (_i => _mode in ((new GoArray<RoundingMode>(((2 : GoUInt8)), ((0 : GoUInt8)), ((3 : GoUInt8))) : GoArray<RoundingMode>))) {
                    for (_2 => _prec in _precList) {
                        var _got:Ref<Float_> = new Float_().setPrec(_prec).setMode(_mode);
                        _got.add(_x, _y);
                        var _want:Ref<Float_> = _zbits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(((("i = %d, prec = %d, %s:\n\t     %s %v\n\t+    %s %v\n\t=    %s\n\twant %s" : GoString))), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_x), Go.toInterface(_xbits), Go.toInterface(_y), Go.toInterface(_ybits), Go.toInterface(_got), Go.toInterface(_want));
                        };
                        _got.sub(_z, _x);
                        _want = _ybits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(((("i = %d, prec = %d, %s:\n\t     %s %v\n\t-    %s %v\n\t=    %s\n\twant %s" : GoString))), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_z), Go.toInterface(_zbits), Go.toInterface(_x), Go.toInterface(_xbits), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    };
                };
            };
        };
    }
function testFloatAddRoundZero(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _mode in ((new GoArray<RoundingMode>(((0 : GoUInt8)), ((1 : GoUInt8)), ((2 : GoUInt8)), ((3 : GoUInt8)), ((5 : GoUInt8)), ((4 : GoUInt8))) : GoArray<RoundingMode>))) {
            var _x:Ref<Float_> = newFloat(((5 : GoFloat64)));
            var _y:Ref<Float_> = new Float_().neg(_x);
            var _want:Ref<Float_> = newFloat(((0 : GoFloat64)));
            if (_mode == ((4 : GoUInt8))) {
                _want.neg(_want);
            };
            var _got:Ref<Float_> = new Float_().setMode(_mode);
            _got.add(_x, _y);
            if ((_got.cmp(_want) != ((0 : GoInt))) || (_got._neg != (_mode == ((4 : GoUInt8))))) {
                _t.errorf(((("%s:\n\t     %v\n\t+    %v\n\t=    %v\n\twant %v" : GoString))), Go.toInterface(_mode), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_got), Go.toInterface(_want));
            };
            _got.sub(_x, _x);
            if ((_got.cmp(_want) != ((0 : GoInt))) || (_got._neg != (_mode == ((4 : GoUInt8))))) {
                _t.errorf(((("%v:\n\t     %v\n\t-    %v\n\t=    %v\n\twant %v" : GoString))), Go.toInterface(_mode), Go.toInterface(_x), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testFloatAdd32(_t:stdgo.testing.Testing.T_):Void {
        {};
        {
            var _d:GoInt = ((0 : GoInt));
            Go.cfor(_d <= ((16 : GoInt)), _d++, {
                for (_i => _ in ((new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) 0]))) : GoArray<GoInt>))) {
                    var _x0:GoFloat64 = ((((6.7108848e+07 : GoFloat64)) : GoFloat64)), _y0:GoFloat64 = ((_d : GoFloat64));
                    if ((_i & ((1 : GoInt))) != ((0 : GoInt))) {
                        {
                            final __tmp__0 = _y0;
                            final __tmp__1 = _x0;
                            _x0 = __tmp__0;
                            _y0 = __tmp__1;
                        };
                    };
                    var _x:Ref<Float_> = newFloat(_x0);
                    var _y:Ref<Float_> = newFloat(_y0);
                    var _z:Ref<Float_> = new Float_().setPrec(((24 : GoUInt)));
                    _z.add(_x, _y);
                    var __tmp__ = _z.float32(), _got:GoFloat32 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                    var _want:GoFloat32 = ((_y0 : GoFloat32)) + ((_x0 : GoFloat32));
                    if ((_got != _want) || (_acc != ((0 : GoInt8)))) {
                        _t.errorf(((("d = %d: %g + %g = %g (%s); want %g (Exact)" : GoString))), Go.toInterface(_d), Go.toInterface(_x0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_want));
                    };
                    _z.sub(_z, _y);
                    {
                        var __tmp__ = _z.float32();
                        _got = __tmp__._0;
                        _acc = __tmp__._1;
                    };
                    _want = ((_want : GoFloat32)) - ((_y0 : GoFloat32));
                    if ((_got != _want) || (_acc != ((0 : GoInt8)))) {
                        _t.errorf(((("d = %d: %g - %g = %g (%s); want %g (Exact)" : GoString))), Go.toInterface(_d), Go.toInterface(_x0 + _y0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_want));
                    };
                };
            });
        };
    }
function testFloatAdd64(_t:stdgo.testing.Testing.T_):Void {
        {};
        {
            var _d:GoInt = ((0 : GoInt));
            Go.cfor(_d <= ((16 : GoInt)), _d++, {
                for (_i => _ in ((new GoArray<GoInt>(...([].concat([for (i in 0 ... 2) 0]))) : GoArray<GoInt>))) {
                    var _x0:GoFloat64 = ((((3.602879701896395e+16 : GoFloat64)) : GoFloat64)), _y0:GoFloat64 = ((_d : GoFloat64));
                    if ((_i & ((1 : GoInt))) != ((0 : GoInt))) {
                        {
                            final __tmp__0 = _y0;
                            final __tmp__1 = _x0;
                            _x0 = __tmp__0;
                            _y0 = __tmp__1;
                        };
                    };
                    var _x:Ref<Float_> = newFloat(_x0);
                    var _y:Ref<Float_> = newFloat(_y0);
                    var _z:Ref<Float_> = new Float_().setPrec(((53 : GoUInt)));
                    _z.add(_x, _y);
                    var __tmp__ = _z.float64(), _got:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                    var _want:GoFloat64 = _x0 + _y0;
                    if ((_got != _want) || (_acc != ((0 : GoInt8)))) {
                        _t.errorf(((("d = %d: %g + %g = %g (%s); want %g (Exact)" : GoString))), Go.toInterface(_d), Go.toInterface(_x0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_want));
                    };
                    _z.sub(_z, _y);
                    {
                        var __tmp__ = _z.float64();
                        _got = __tmp__._0;
                        _acc = __tmp__._1;
                    };
                    _want = _want - (_y0);
                    if ((_got != _want) || (_acc != ((0 : GoInt8)))) {
                        _t.errorf(((("d = %d: %g - %g = %g (%s); want %g (Exact)" : GoString))), Go.toInterface(_d), Go.toInterface(_x0 + _y0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_want));
                    };
                };
            });
        };
    }
function testIssue20490(_t:stdgo.testing.Testing.T_):Void {
        var _tests:Slice<T__struct_23> = ((new Slice<T__struct_23>(((new T__struct_23(((4 : GoFloat64)), ((1 : GoFloat64))) : T__struct_23)), ((new T__struct_23(((-4 : GoFloat64)), ((1 : GoFloat64))) : T__struct_23)), ((new T__struct_23(((4 : GoFloat64)), ((-1 : GoFloat64))) : T__struct_23)), ((new T__struct_23(((-4 : GoFloat64)), ((-1 : GoFloat64))) : T__struct_23))) : Slice<T__struct_23>));
        for (_0 => _test in _tests) {
            var _a:Ref<Float_> = newFloat(_test._a), _b:Ref<Float_> = newFloat(_test._b);
            var _diff:Ref<Float_> = new Float_().sub(_a, _b);
            _b.sub(_a, _b);
            if (_b.cmp(_diff) != ((0 : GoInt))) {
                _t.errorf(((("got %g - %g = %g; want %g\n" : GoString))), Go.toInterface(_a), Go.toInterface(newFloat(_test._b)), Go.toInterface(_b), Go.toInterface(_diff));
            };
            _b = newFloat(_test._b);
            var _sum:Ref<Float_> = new Float_().add(_a, _b);
            _b.add(_a, _b);
            if (_b.cmp(_sum) != ((0 : GoInt))) {
                _t.errorf(((("got %g + %g = %g; want %g\n" : GoString))), Go.toInterface(_a), Go.toInterface(newFloat(_test._b)), Go.toInterface(_b), Go.toInterface(_sum));
            };
        };
    }
function testFloatMul(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _xbits in _bitsList) {
            for (_1 => _ybits in _bitsList) {
                var _x:Ref<Float_> = _xbits.float();
                var _y:Ref<Float_> = _ybits.float();
                var _zbits:Bits = (_xbits._mul((_ybits == null ? null : _ybits.__copy__())) == null ? null : _xbits._mul((_ybits == null ? null : _ybits.__copy__())).__copy__());
                var _z:Ref<Float_> = _zbits.float();
                for (_i => _mode in ((new GoArray<RoundingMode>(((2 : GoUInt8)), ((0 : GoUInt8)), ((3 : GoUInt8))) : GoArray<RoundingMode>))) {
                    for (_2 => _prec in _precList) {
                        var _got:Ref<Float_> = new Float_().setPrec(_prec).setMode(_mode);
                        _got.mul(_x, _y);
                        var _want:Ref<Float_> = _zbits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(((("i = %d, prec = %d, %s:\n\t     %v %v\n\t*    %v %v\n\t=    %v\n\twant %v" : GoString))), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_x), Go.toInterface(_xbits), Go.toInterface(_y), Go.toInterface(_ybits), Go.toInterface(_got), Go.toInterface(_want));
                        };
                        if (_x.sign() == ((0 : GoInt))) {
                            continue;
                        };
                        _got.quo(_z, _x);
                        _want = _ybits._round(_prec, _mode);
                        if (_got.cmp(_want) != ((0 : GoInt))) {
                            _t.errorf(((("i = %d, prec = %d, %s:\n\t     %v %v\n\t/    %v %v\n\t=    %v\n\twant %v" : GoString))), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_z), Go.toInterface(_zbits), Go.toInterface(_x), Go.toInterface(_xbits), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    };
                };
            };
        };
    }
function testFloatMul64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_24>(((new T__struct_24(((0 : GoFloat64)), ((0 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((0 : GoFloat64)), ((1 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((1 : GoFloat64)), ((1 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((1 : GoFloat64)), ((1.5 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((1.234 : GoFloat64)), ((0.5678 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((2.718281828 : GoFloat64)), ((3.14159265358979 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((2.718281828e+10 : GoFloat64)), ((3.14159265358979e-32 : GoFloat64))) : T__struct_24)), ((new T__struct_24(((0.3333333333333333 : GoFloat64)), ((1e+200 : GoFloat64))) : T__struct_24))) : Slice<T__struct_24>))) {
            for (_i => _ in ((new GoArray<GoInt>(...([].concat([for (i in 0 ... 8) 0]))) : GoArray<GoInt>))) {
                var _x0:GoFloat64 = _test._x, _y0:GoFloat64 = _test._y;
                if ((_i & ((1 : GoInt))) != ((0 : GoInt))) {
                    _x0 = -_x0;
                };
                if ((_i & ((2 : GoInt))) != ((0 : GoInt))) {
                    _y0 = -_y0;
                };
                if ((_i & ((4 : GoInt))) != ((0 : GoInt))) {
                    {
                        final __tmp__0 = _y0;
                        final __tmp__1 = _x0;
                        _x0 = __tmp__0;
                        _y0 = __tmp__1;
                    };
                };
                var _x:Ref<Float_> = newFloat(_x0);
                var _y:Ref<Float_> = newFloat(_y0);
                var _z:Ref<Float_> = new Float_().setPrec(((53 : GoUInt)));
                _z.mul(_x, _y);
                var __tmp__ = _z.float64(), _got:GoFloat64 = __tmp__._0, _1:Accuracy = __tmp__._1;
                var _want:GoFloat64 = _x0 * _y0;
                if (_got != _want) {
                    _t.errorf(((("%g * %g = %g; want %g" : GoString))), Go.toInterface(_x0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_want));
                };
                if (_y0 == ((0 : GoFloat64))) {
                    continue;
                };
                _z.quo(_z, _y);
                {
                    var __tmp__ = _z.float64();
                    _got = __tmp__._0;
                };
                _want = _want / (_y0);
                if (_got != _want) {
                    _t.errorf(((("%g / %g = %g; want %g" : GoString))), Go.toInterface(_x0 * _y0), Go.toInterface(_y0), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
function testIssue6866(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _prec in _precList) {
            var _two:Ref<Float_> = new Float_().setPrec(_prec).setInt64(((2 : GoInt64)));
            var _one:Ref<Float_> = new Float_().setPrec(_prec).setInt64(((1 : GoInt64)));
            var _three:Ref<Float_> = new Float_().setPrec(_prec).setInt64(((3 : GoInt64)));
            var _msix:Ref<Float_> = new Float_().setPrec(_prec).setInt64(((-6 : GoInt64)));
            var _psix:Ref<Float_> = new Float_().setPrec(_prec).setInt64(((6 : GoInt64)));
            var _p:Ref<Float_> = new Float_().setPrec(_prec);
            var _z1:Ref<Float_> = new Float_().setPrec(_prec);
            var _z2:Ref<Float_> = new Float_().setPrec(_prec);
            _p.quo(_one, _three);
            _p.mul(_p, _msix);
            _z1.add(_two, _p);
            _p.quo(_one, _three);
            _p.mul(_p, _psix);
            _z2.sub(_two, _p);
            if (_z1.cmp(_z2) != ((0 : GoInt))) {
                _t.fatalf(((("prec %d: got z1 = %v != z2 = %v; want z1 == z2\n" : GoString))), Go.toInterface(_prec), Go.toInterface(_z1), Go.toInterface(_z2));
            };
            if (_z1.sign() != ((0 : GoInt))) {
                _t.errorf(((("prec %d: got z1 = %v; want 0" : GoString))), Go.toInterface(_prec), Go.toInterface(_z1));
            };
            if (_z2.sign() != ((0 : GoInt))) {
                _t.errorf(((("prec %d: got z2 = %v; want 0" : GoString))), Go.toInterface(_prec), Go.toInterface(_z2));
            };
        };
    }
function testFloatQuo(_t:stdgo.testing.Testing.T_):Void {
        var _preci:GoInt = ((200 : GoInt));
        var _precf:GoInt = ((20 : GoInt));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((8 : GoInt)), _i++, {
                var _bits:Bits = ((new Slice<GoInt>(_preci - ((1 : GoInt))) : Bits));
                if ((_i & ((3 : GoInt))) != ((0 : GoInt))) {
                    _bits = ((_bits != null ? _bits.__append__(((0 : GoInt))) : new Slice<Slice<GoInt>>(((0 : GoInt)))) == null ? null : (_bits != null ? _bits.__append__(((0 : GoInt))) : new Slice<Slice<GoInt>>(((0 : GoInt)))).__copy__());
                };
                if ((_i & ((2 : GoInt))) != ((0 : GoInt))) {
                    _bits = ((_bits != null ? _bits.__append__(((-1 : GoInt))) : new Slice<Slice<GoInt>>(((-1 : GoInt)))) == null ? null : (_bits != null ? _bits.__append__(((-1 : GoInt))) : new Slice<Slice<GoInt>>(((-1 : GoInt)))).__copy__());
                };
                if ((_i & ((1 : GoInt))) != ((0 : GoInt))) {
                    _bits = ((_bits != null ? _bits.__append__(-_precf) : new Slice<Slice<GoInt>>(-_precf)) == null ? null : (_bits != null ? _bits.__append__(-_precf) : new Slice<Slice<GoInt>>(-_precf)).__copy__());
                };
                var _z:Ref<Float_> = _bits.float();
                var _y:Ref<Float_> = newFloat(((3.141592653589793e+123 : GoFloat64)));
                var _x:Ref<Float_> = new Float_().setPrec(_z.prec() + _y.prec()).setMode(((2 : GoUInt8)));
                _x.mul(_z, _y);
                {
                    var _got:Accuracy = _x.acc();
                    if (_got != ((0 : GoInt8))) {
                        _t.errorf(((("got acc = %s; want exact" : GoString))), Go.toInterface(_got));
                    };
                };
                for (_0 => _mode in ((new GoArray<RoundingMode>(((2 : GoUInt8)), ((0 : GoUInt8)), ((3 : GoUInt8))) : GoArray<RoundingMode>))) {
                    {
                        var _d:GoInt = ((-5 : GoInt));
                        Go.cfor(_d < ((5 : GoInt)), _d++, {
                            var _prec:GoUInt = (((_preci + _d) : GoUInt));
                            var _got:Ref<Float_> = new Float_().setPrec(_prec).setMode(_mode).quo(_x, _y);
                            var _want:Ref<Float_> = _bits._round(_prec, _mode);
                            if (_got.cmp(_want) != ((0 : GoInt))) {
                                _t.errorf(((("i = %d, prec = %d, %s:\n\t     %s\n\t/    %s\n\t=    %s\n\twant %s" : GoString))), Go.toInterface(_i), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_got), Go.toInterface(_want));
                            };
                        });
                    };
                };
            });
        };
    }
function testFloatQuoSmoke(_t:stdgo.testing.Testing.T_):Void {
        var _n:GoInt = ((10 : GoInt));
        if (_long.value) {
            _n = ((1000 : GoInt));
        };
        {};
        {};
        {
            var _x:GoInt = -_n;
            Go.cfor(_x <= _n, _x++, {
                {
                    var _y:GoInt = -_n;
                    Go.cfor(_y < _n, _y++, {
                        if (_y == ((0 : GoInt))) {
                            continue;
                        };
                        var _a:GoFloat64 = ((_x : GoFloat64));
                        var _b:GoFloat64 = ((_y : GoFloat64));
                        var _c:GoFloat64 = _a / _b;
                        {
                            var _ad:GoInt = ((-3 : GoInt));
                            Go.cfor(_ad <= ((3 : GoInt)), _ad++, {
                                {
                                    var _bd:GoInt = ((-3 : GoInt));
                                    Go.cfor(_bd <= ((3 : GoInt)), _bd++, {
                                        var a:Ref<Float_> = new Float_().setPrec((((((13 : GoInt)) + _ad) : GoUInt))).setFloat64(_a);
                                        var b:Ref<Float_> = new Float_().setPrec((((((13 : GoInt)) + _bd) : GoUInt))).setFloat64(_b);
                                        var c:Ref<Float_> = new Float_().setPrec(((53 : GoUInt))).quo(a, b);
                                        var __tmp__ = c.float64(), _cc:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                                        if (_cc != _c) {
                                            _t.errorf(((("%g/%g = %s; want %.5g\n" : GoString))), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(c.text(((((("g" : GoString))).code : GoRune)), ((5 : GoInt)))), Go.toInterface(_c));
                                            continue;
                                        };
                                        if (_acc != ((0 : GoInt8))) {
                                            _t.errorf(((("%g/%g got %s result; want exact result" : GoString))), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_acc));
                                        };
                                    });
                                };
                            });
                        };
                    });
                };
            });
        };
    }
function testFloatArithmeticSpecialValues(_t:stdgo.testing.Testing.T_):Void {
        var _zero:GoFloat64 = ((0 : GoFloat64));
        var _args:Slice<GoFloat64> = ((new Slice<GoFloat64>(stdgo.math.Math.inf(((-1 : GoInt))), ((-2.71828 : GoFloat64)), ((-1 : GoFloat64)), -_zero, _zero, ((1 : GoFloat64)), ((2.71828 : GoFloat64)), stdgo.math.Math.inf(((1 : GoInt)))) : Slice<GoFloat64>));
        var _xx:Ref<Float_> = new Float_();
        var _yy:Ref<Float_> = new Float_();
        var _got:Ref<Float_> = new Float_();
        var _want:Ref<Float_> = new Float_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((4 : GoInt)), _i++, {
                for (_0 => _x in _args) {
                    _xx.setFloat64(_x);
                    {
                        var __tmp__ = _xx.float64(), _got:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                        if ((_got != _x) || (_acc != ((0 : GoInt8)))) {
                            _t.errorf(((("Float(%g) == %g (%s)" : GoString))), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_acc));
                        };
                    };
                    for (_1 => _y in _args) {
                        _yy.setFloat64(_y);
                        var _op:GoString = (("" : GoString)), _z:GoFloat64 = ((0 : GoFloat64)), _f:(_z:Float_, _x:Float_, _y:Float_) -> Float_ = null;
                        if (_i == ((0 : GoInt))) {
                            _op = ((("+" : GoString)));
                            _z = _x + _y;
                            _f = (Float__static_extension).add;
                        } else if (_i == ((1 : GoInt))) {
                            _op = ((("-" : GoString)));
                            _z = _x - _y;
                            _f = (Float__static_extension).sub;
                        } else if (_i == ((2 : GoInt))) {
                            _op = ((("*" : GoString)));
                            _z = _x * _y;
                            _f = (Float__static_extension).mul;
                        } else if (_i == ((3 : GoInt))) {
                            _op = ((("/" : GoString)));
                            _z = _x / _y;
                            _f = (Float__static_extension).quo;
                        } else {
                            throw Go.toInterface(((("unreachable" : GoString))));
                        };
                        var _errnan:Bool = false;
                        {
                            var a = function():Void {
                                __deferstack__.unshift(() -> {
                                    var a = function():Void {
                                        {
                                            var _p:AnyInterface = Go.toInterface(({
                                                final r = __recover_exception__;
                                                __recover_exception__ = null;
                                                r;
                                            }));
                                            if (_p != null) {
                                                ((_p.value : ErrNaN));
                                                _errnan = true;
                                            };
                                        };
                                    };
                                    a();
                                });
                                _f(_got, _xx, _yy);
                            };
                            a();
                        };
                        if (stdgo.math.Math.isNaN(_z)) {
                            if (!_errnan) {
                                _t.errorf(((("%5g %s %5g = %5s; want ErrNaN panic" : GoString))), Go.toInterface(_x), Go.toInterface(_op), Go.toInterface(_y), Go.toInterface(_got));
                            };
                            continue;
                        };
                        if (_errnan) {
                            _t.errorf(((("%5g %s %5g panicked with ErrNan; want %5s" : GoString))), Go.toInterface(_x), Go.toInterface(_op), Go.toInterface(_y), Go.toInterface(_want));
                            continue;
                        };
                        _want.setFloat64(_z);
                        if (!_alike(_got, _want)) {
                            _t.errorf(((("%5g %s %5g = %5s; want %5s" : GoString))), Go.toInterface(_x), Go.toInterface(_op), Go.toInterface(_y), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    };
                };
            });
        };
    }
function testFloatArithmeticOverflow(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_25>(
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0" : GoString))), ((("0" : GoString))), ((("0" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.8p+0" : GoString))), ((("0x.8p+0" : GoString))), ((("0x.8p+1" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p+2147483647" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.8p2147483500" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p+2147483647" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.8p2147483647" : GoString))), ((("0x.8p2147483647" : GoString))), ((("+Inf" : GoString))), ((1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("-0x.8p2147483647" : GoString))), ((("-0x.8p2147483647" : GoString))), ((("-Inf" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("-" : GoString))).code : GoRune)), ((("-0x.8p2147483647" : GoString))), ((("0x.8p2147483647" : GoString))), ((("-Inf" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((2 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.fp2147483647" : GoString))), ((("0x.8p2147483643" : GoString))), ((("0x.fp+2147483647" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.fp2147483647" : GoString))), ((("0x.8p2147483643" : GoString))), ((("+Inf" : GoString))), ((1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((3 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.fp2147483647" : GoString))), ((("0x.8p2147483643" : GoString))), ((("+Inf" : GoString))), ((1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((3 : GoUInt8)), ((((("-" : GoString))).code : GoRune)), ((("-0x.fp2147483647" : GoString))), ((("0x.8p2147483644" : GoString))), ((("-Inf" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("-" : GoString))).code : GoRune)), ((("-0x.fp2147483647" : GoString))), ((("0x.8p2147483643" : GoString))), ((("-Inf" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((2 : GoUInt8)), ((((("-" : GoString))).code : GoRune)), ((("-0x.fp2147483647" : GoString))), ((("0x.8p2147483643" : GoString))), ((("-0x.fp+2147483647" : GoString))), ((1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0" : GoString))), ((("0x.8p-2147483648" : GoString))), ((("0x.8p-2147483648" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("+" : GoString))).code : GoRune)), ((("0x.8p-2147483648" : GoString))), ((("0x.8p-2147483648" : GoString))), ((("0x.8p-2147483647" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("*" : GoString))).code : GoRune)), ((("1" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p+2147483647" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("*" : GoString))).code : GoRune)), ((("2" : GoString))), ((("0x.8p2147483647" : GoString))), ((("+Inf" : GoString))), ((1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("*" : GoString))).code : GoRune)), ((("-2" : GoString))), ((("0x.8p2147483647" : GoString))), ((("-Inf" : GoString))), ((-1 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("/" : GoString))).code : GoRune)), ((("0.5" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p-2147483646" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("/" : GoString))).code : GoRune)), ((("0x.8p+0" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p-2147483646" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("/" : GoString))).code : GoRune)), ((("0x.8p-1" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p-2147483647" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("/" : GoString))).code : GoRune)), ((("0x.8p-2" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0x.8p-2147483648" : GoString))), ((0 : GoInt8))) : T__struct_25)),
((new T__struct_25(((4 : GoUInt)), ((0 : GoUInt8)), ((((("/" : GoString))).code : GoRune)), ((("0x.8p-3" : GoString))), ((("0x.8p2147483647" : GoString))), ((("0" : GoString))), ((-1 : GoInt8))) : T__struct_25))) : Slice<T__struct_25>))) {
            var _x:Ref<Float_> = _makeFloat(_test._x);
            var _y:Ref<Float_> = _makeFloat(_test._y);
            var _z:Ref<Float_> = new Float_().setPrec(_test._prec).setMode(_test._mode);
            if (_test._op == ((((("+" : GoString))).code : GoRune))) {
                _z.add(_x, _y);
            } else if (_test._op == ((((("-" : GoString))).code : GoRune))) {
                _z.sub(_x, _y);
            } else if (_test._op == ((((("*" : GoString))).code : GoRune))) {
                _z.mul(_x, _y);
            } else if (_test._op == ((((("/" : GoString))).code : GoRune))) {
                _z.quo(_x, _y);
            } else {
                throw Go.toInterface(((("unreachable" : GoString))));
            };
            {
                var _got:GoString = _z.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)));
                if ((_got != _test._want) || (_z.acc() != _test._acc)) {
                    _t.errorf(((("prec = %d (%s): %s %c %s = %s (%s); want %s (%s)" : GoString))), Go.toInterface(_test._prec), Go.toInterface(_test._mode), Go.toInterface(_x.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_test._op), Go.toInterface(_y.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt)))), Go.toInterface(_got), Go.toInterface(_z.acc()), Go.toInterface(_test._want), Go.toInterface(_test._acc));
                };
            };
        };
    }
function testFloatArithmeticRounding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_26>(
((new T__struct_26(((2 : GoUInt8)), ((3 : GoUInt)), ((-8 : GoInt64)), ((-1 : GoInt64)), ((-8 : GoInt64)), ((((("+" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((3 : GoUInt8)), ((3 : GoUInt)), ((-8 : GoInt64)), ((-1 : GoInt64)), ((-10 : GoInt64)), ((((("+" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((4 : GoUInt8)), ((3 : GoUInt)), ((-8 : GoInt64)), ((-1 : GoInt64)), ((-10 : GoInt64)), ((((("+" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((2 : GoUInt8)), ((3 : GoUInt)), ((-8 : GoInt64)), ((1 : GoInt64)), ((-8 : GoInt64)), ((((("-" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((3 : GoUInt8)), ((3 : GoUInt)), ((-8 : GoInt64)), ((1 : GoInt64)), ((-10 : GoInt64)), ((((("-" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((4 : GoUInt8)), ((3 : GoUInt)), ((-8 : GoInt64)), ((1 : GoInt64)), ((-10 : GoInt64)), ((((("-" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((2 : GoUInt8)), ((3 : GoUInt)), ((-9 : GoInt64)), ((1 : GoInt64)), ((-8 : GoInt64)), ((((("*" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((3 : GoUInt8)), ((3 : GoUInt)), ((-9 : GoInt64)), ((1 : GoInt64)), ((-10 : GoInt64)), ((((("*" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((4 : GoUInt8)), ((3 : GoUInt)), ((-9 : GoInt64)), ((1 : GoInt64)), ((-10 : GoInt64)), ((((("*" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((2 : GoUInt8)), ((3 : GoUInt)), ((-9 : GoInt64)), ((1 : GoInt64)), ((-8 : GoInt64)), ((((("/" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((3 : GoUInt8)), ((3 : GoUInt)), ((-9 : GoInt64)), ((1 : GoInt64)), ((-10 : GoInt64)), ((((("/" : GoString))).code : GoRune))) : T__struct_26)),
((new T__struct_26(((4 : GoUInt8)), ((3 : GoUInt)), ((-9 : GoInt64)), ((1 : GoInt64)), ((-10 : GoInt64)), ((((("/" : GoString))).code : GoRune))) : T__struct_26))) : Slice<T__struct_26>))) {
            var _x:Float_ = new Float_(), _y:Float_ = new Float_(), _z:Float_ = new Float_();
            _x.setInt64(_test._x);
            _y.setInt64(_test._y);
            _z.setPrec(_test._prec).setMode(_test._mode);
            if (_test._op == ((((("+" : GoString))).code : GoRune))) {
                _z.add(_x, _y);
            } else if (_test._op == ((((("-" : GoString))).code : GoRune))) {
                _z.sub(_x, _y);
            } else if (_test._op == ((((("*" : GoString))).code : GoRune))) {
                _z.mul(_x, _y);
            } else if (_test._op == ((((("/" : GoString))).code : GoRune))) {
                _z.quo(_x, _y);
            } else {
                throw Go.toInterface(((("unreachable" : GoString))));
            };
            {
                var __tmp__ = _z.int64(), _got:GoInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                if ((_got != _test._want) || (_acc != ((0 : GoInt8)))) {
                    _t.errorf(((("%s, %d bits: %d %c %d = %d (%s); want %d (Exact)" : GoString))), Go.toInterface(_test._mode), Go.toInterface(_test._prec), Go.toInterface(_test._x), Go.toInterface(_test._op), Go.toInterface(_test._y), Go.toInterface(_got), Go.toInterface(_acc), Go.toInterface(_test._want));
                };
            };
        };
    }
function testFloatCmpSpecialValues(_t:stdgo.testing.Testing.T_):Void {
        var _zero:GoFloat64 = ((0 : GoFloat64));
        var _args:Slice<GoFloat64> = ((new Slice<GoFloat64>(stdgo.math.Math.inf(((-1 : GoInt))), ((-2.71828 : GoFloat64)), ((-1 : GoFloat64)), -_zero, _zero, ((1 : GoFloat64)), ((2.71828 : GoFloat64)), stdgo.math.Math.inf(((1 : GoInt)))) : Slice<GoFloat64>));
        var _xx:Ref<Float_> = new Float_();
        var _yy:Ref<Float_> = new Float_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((4 : GoInt)), _i++, {
                for (_0 => _x in _args) {
                    _xx.setFloat64(_x);
                    {
                        var __tmp__ = _xx.float64(), _got:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                        if ((_got != _x) || (_acc != ((0 : GoInt8)))) {
                            _t.errorf(((("Float(%g) == %g (%s)" : GoString))), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_acc));
                        };
                    };
                    for (_1 => _y in _args) {
                        _yy.setFloat64(_y);
                        var _got:GoInt = _xx.cmp(_yy);
                        var _want:GoInt = ((0 : GoInt));
                        if (_x < _y) {
                            _want = ((-1 : GoInt));
                        } else if (_x > _y) {
                            _want = ((1 : GoInt));
                        };
                        if (_got != _want) {
                            _t.errorf(((("(%g).Cmp(%g) = %v; want %v" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    };
                };
            });
        };
    }
function benchmarkFloatAdd(_b:stdgo.testing.Testing.B):Void {
        var _x:Ref<Float_> = new Float_();
        var _y:Ref<Float_> = new Float_();
        var _z:Ref<Float_> = new Float_();
        for (_0 => _prec in ((new Slice<GoUInt>(((10 : GoUInt)), ((100 : GoUInt)), ((1000 : GoUInt)), ((10000 : GoUInt)), ((100000 : GoUInt))) : Slice<GoUInt>))) {
            _x.setPrec(_prec).setRat(newRat(((1 : GoInt64)), ((3 : GoInt64))));
            _y.setPrec(_prec).setRat(newRat(((1 : GoInt64)), ((6 : GoInt64))));
            _z.setPrec(_prec);
            _b.run(stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_prec)), function(_b:stdgo.testing.Testing.B):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _z.add(_x, _y);
                    });
                };
            });
        };
    }
function benchmarkFloatSub(_b:stdgo.testing.Testing.B):Void {
        var _x:Ref<Float_> = new Float_();
        var _y:Ref<Float_> = new Float_();
        var _z:Ref<Float_> = new Float_();
        for (_0 => _prec in ((new Slice<GoUInt>(((10 : GoUInt)), ((100 : GoUInt)), ((1000 : GoUInt)), ((10000 : GoUInt)), ((100000 : GoUInt))) : Slice<GoUInt>))) {
            _x.setPrec(_prec).setRat(newRat(((1 : GoInt64)), ((3 : GoInt64))));
            _y.setPrec(_prec).setRat(newRat(((1 : GoInt64)), ((6 : GoInt64))));
            _z.setPrec(_prec);
            _b.run(stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_prec)), function(_b:stdgo.testing.Testing.B):Void {
                _b.reportAllocs();
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _z.sub(_x, _y);
                    });
                };
            });
        };
    }
function parseFloat(_s:GoString, _base:GoInt, _prec:GoUInt, _mode:RoundingMode):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        return new Float_().setPrec(_prec).setMode(_mode).parse(_s, _base);
    }
function testFloatSetFloat64String(_t:stdgo.testing.Testing.T_):Void {
        var _inf:GoFloat64 = stdgo.math.Math.inf(((0 : GoInt)));
        var _nan:GoFloat64 = stdgo.math.Math.naN();
        for (_0 => _test in ((new Slice<T__struct_27>(
((new T__struct_27(((("0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("+0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-1" : GoString))), ((-1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+1" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1.234" : GoString))), ((1.234 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-1.234" : GoString))), ((-1.234 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+1.234" : GoString))), ((1.234 : GoFloat64))) : T__struct_27)),
((new T__struct_27((((".1" : GoString))), ((0.1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1." : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+1." : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0e100" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0e+100" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("+0e-100" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0E100" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0E+100" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("+0E-100" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1.e10" : GoString))), ((1e+10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1e+10" : GoString))), ((1e+10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+1e-10" : GoString))), ((1e-10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1E10" : GoString))), ((1e+10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1.E+10" : GoString))), ((1e+10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+1E-10" : GoString))), ((1e-10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("Inf" : GoString))), _inf) : T__struct_27)),
((new T__struct_27(((("+Inf" : GoString))), _inf) : T__struct_27)),
((new T__struct_27(((("-Inf" : GoString))), -_inf) : T__struct_27)),
((new T__struct_27(((("inf" : GoString))), _inf) : T__struct_27)),
((new T__struct_27(((("+inf" : GoString))), _inf) : T__struct_27)),
((new T__struct_27(((("-inf" : GoString))), -_inf) : T__struct_27)),
((new T__struct_27(((("" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("-" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("0x" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("0e" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("1.2ef" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("2..3" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("123.." : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("infinity" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("foobar" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("_" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("0_" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("1__0" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("123_." : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("123._" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("123._4" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("1_2.3_4_" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("_.123" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("_123.456" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("10._0" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("10.0e_0" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("10.0e0_" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("0P-0__0" : GoString))), _nan) : T__struct_27)),
((new T__struct_27(((("3.14159265" : GoString))), ((3.14159265 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-687436.79457e-245" : GoString))), ((-6.8743679457e-240 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-687436.79457E245" : GoString))), ((-6.8743679457e+250 : GoFloat64))) : T__struct_27)),
((new T__struct_27((((".0000000000000000000000000000000000000001" : GoString))), ((1e-40 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+10000000000000000000000000000000000000000e-0" : GoString))), ((1e+40 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0p0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0p0" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("1p10" : GoString))), ((1024 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1p+10" : GoString))), ((1024 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("+1p-10" : GoString))), ((0.0009765625 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1024p-12" : GoString))), ((0.25 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-1p10" : GoString))), ((-1024 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1.5p1" : GoString))), ((3 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0b0" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0b0e+10" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0b0e-10" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0b1010" : GoString))), ((10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0B1010E2" : GoString))), ((1000 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b.1" : GoString))), ((0.5 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b.001" : GoString))), ((0.125 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b.001e3" : GoString))), ((125 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b0p+10" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0b0p-10" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0b.1010p4" : GoString))), ((10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b1p-1" : GoString))), ((0.5 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b001p-3" : GoString))), ((0.125 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b.001p3" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b0.01p2" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b0.01P+2" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0o0" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0o0e+10" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0o0e-10" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0o12" : GoString))), ((10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0O12E2" : GoString))), ((1000 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o.4" : GoString))), ((0.5 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o.01" : GoString))), ((0.015625 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o.01e3" : GoString))), ((15.625 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o0p+10" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0o0p-10" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0o.12p6" : GoString))), ((10 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o4p-3" : GoString))), ((0.5 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o0014p-6" : GoString))), ((0.1875 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o.001p9" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0o0.01p7" : GoString))), ((2 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0O0.01P+2" : GoString))), ((0.0625 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0x0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0x0" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0x0p+10" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0x0p-10" : GoString))), -_zero_) : T__struct_27)),
((new T__struct_27(((("0xff" : GoString))), ((255 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0X.8p1" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0X0.00008p16" : GoString))), ((-0.5 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("-0X0.00008P+16" : GoString))), ((-0.5 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0x0.0000000000001p-1022" : GoString))), ((5e-324 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0x1.fffffffffffffp1023" : GoString))), ((1.7976931348623157e+308 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0_0" : GoString))), ((0 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1_000." : GoString))), ((1000 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1_2_3.4_5_6" : GoString))), ((123.456 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1.0e0_0" : GoString))), ((1 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("1p+1_0" : GoString))), ((1024 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b_1000" : GoString))), ((8 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0b_1011_1101" : GoString))), ((189 : GoFloat64))) : T__struct_27)),
((new T__struct_27(((("0x_f0_0d_1eP+0_8" : GoString))), (("4027391488" : GoFloat64))) : T__struct_27))) : Slice<T__struct_27>))) {
            var _x:Float_ = new Float_();
            _x.setPrec(((53 : GoUInt)));
            var __tmp__ = _x.setString(_test._s), _1:Ref<Float_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (stdgo.math.Math.isNaN(_test._x)) {
                if (_ok) {
                    _t.errorf(((("%s: want parse error" : GoString))), Go.toInterface(_test._s));
                };
                continue;
            };
            if (!_ok) {
                _t.errorf(((("%s: got parse error" : GoString))), Go.toInterface(_test._s));
                continue;
            };
            var __tmp__ = _x.float64(), _f:GoFloat64 = __tmp__._0, _2:Accuracy = __tmp__._1;
            var _want:Ref<Float_> = new Float_().setFloat64(_test._x);
            if ((_x.cmp(_want) != ((0 : GoInt))) || (_x.signbit() != _want.signbit())) {
                _t.errorf(((("%s: got %v (%v); want %v" : GoString))), Go.toInterface(_test._s), Go.toInterface(_x), Go.toInterface(_f), Go.toInterface(_test._x));
            };
        };
    }
function _fdiv(_a:GoFloat64, _b:GoFloat64):GoFloat64 {
        return _a / _b;
    }
function testFloat64Text(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_28>(
((new T__struct_28(((0 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(stdgo.math.Math.copysign(((0 : GoFloat64)), ((-1 : GoFloat64))), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-1" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.001 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1e-03" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.459 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((0 : GoInt)), ((("5e-01" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.459 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((2.459 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2.5e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((3.459 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.46e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((4.459 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.459e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((5.459 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5.4590e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.001 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.459 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.459 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_28)),
((new T__struct_28(((2.459 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2.5" : GoString)))) : T__struct_28)),
((new T__struct_28(((3.459 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.46" : GoString)))) : T__struct_28)),
((new T__struct_28(((4.459 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.459" : GoString)))) : T__struct_28)),
((new T__struct_28(((5.459 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5.4590" : GoString)))) : T__struct_28)),
((new T__struct_28(((0 : GoFloat64)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(stdgo.math.Math.copysign(((0 : GoFloat64)), ((-1 : GoFloat64))), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("4503599627370496p-52" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-4503599627370496p-52" : GoString)))) : T__struct_28)),
((new T__struct_28((("4503599627370496" : GoFloat64)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("4503599627370496p+0" : GoString)))) : T__struct_28)),
((new T__struct_28(((0 : GoFloat64)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(stdgo.math.Math.copysign(((0 : GoFloat64)), ((-1 : GoFloat64))), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_28)),
((new T__struct_28(((1024 : GoFloat64)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.8p+11" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1024 : GoFloat64)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0x.8p+11" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.00000e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.00000" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1" : GoString)))) : T__struct_28)),
((new T__struct_28(((20 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("20" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.2345678e+06 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1.2345678e+06" : GoString)))) : T__struct_28)),
((new T__struct_28(((200000 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("200000" : GoString)))) : T__struct_28)),
((new T__struct_28(((2000000 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("2e+06" : GoString)))) : T__struct_28)),
((new T__struct_28(((400 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("4e+02" : GoString)))) : T__struct_28)),
((new T__struct_28(((40 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("40" : GoString)))) : T__struct_28)),
((new T__struct_28(((4 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("4" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.4 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("0.4" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.04 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("0.04" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.004 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("0.004" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.0004 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("0.0004" : GoString)))) : T__struct_28)),
((new T__struct_28(((4e-05 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("4e-05" : GoString)))) : T__struct_28)),
((new T__struct_28(((4e-06 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("4e-06" : GoString)))) : T__struct_28)),
((new T__struct_28(((0 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0.00000e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((0 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0.00000" : GoString)))) : T__struct_28)),
((new T__struct_28(((0 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(((0 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((5 : GoInt)), ((("-1.00000e+00" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((5 : GoInt)), ((("-1.00000" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((5 : GoInt)), ((("-1" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-1" : GoString)))) : T__struct_28)),
((new T__struct_28(((12 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.20000e+01" : GoString)))) : T__struct_28)),
((new T__struct_28(((12 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((5 : GoInt)), ((("12.00000" : GoString)))) : T__struct_28)),
((new T__struct_28(((12 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((5 : GoInt)), ((("12" : GoString)))) : T__struct_28)),
((new T__struct_28(((12 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("12" : GoString)))) : T__struct_28)),
((new T__struct_28(((123456700 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.23457e+08" : GoString)))) : T__struct_28)),
((new T__struct_28(((123456700 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((5 : GoInt)), ((("123456700.00000" : GoString)))) : T__struct_28)),
((new T__struct_28(((123456700 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.2346e+08" : GoString)))) : T__struct_28)),
((new T__struct_28(((123456700 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1.234567e+08" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.2345e+06 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.23450e+06" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.2345e+06 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1234500.00000" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.2345e+06 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((5 : GoInt)), ((("1.2345e+06" : GoString)))) : T__struct_28)),
((new T__struct_28(((1e+23 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((17 : GoInt)), ((("9.99999999999999916e+22" : GoString)))) : T__struct_28)),
((new T__struct_28(((1e+23 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((17 : GoInt)), ((("99999999999999991611392.00000000000000000" : GoString)))) : T__struct_28)),
((new T__struct_28(((1e+23 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((17 : GoInt)), ((("9.9999999999999992e+22" : GoString)))) : T__struct_28)),
((new T__struct_28(((1e+23 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1e+23" : GoString)))) : T__struct_28)),
((new T__struct_28(((1e+23 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("100000000000000000000000" : GoString)))) : T__struct_28)),
((new T__struct_28(((1e+23 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1e+23" : GoString)))) : T__struct_28)),
((new T__struct_28(((9.999999999999997e+22 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((17 : GoInt)), ((("9.99999999999999748e+22" : GoString)))) : T__struct_28)),
((new T__struct_28(((9.999999999999997e+22 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((17 : GoInt)), ((("99999999999999974834176.00000000000000000" : GoString)))) : T__struct_28)),
((new T__struct_28(((9.999999999999997e+22 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((17 : GoInt)), ((("9.9999999999999975e+22" : GoString)))) : T__struct_28)),
((new T__struct_28(((9.999999999999997e+22 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("9.999999999999997e+22" : GoString)))) : T__struct_28)),
((new T__struct_28(((9.999999999999997e+22 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("99999999999999970000000" : GoString)))) : T__struct_28)),
((new T__struct_28(((9.999999999999997e+22 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("9.999999999999997e+22" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.0000000000000001e+23 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((17 : GoInt)), ((("1.00000000000000008e+23" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.0000000000000001e+23 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((17 : GoInt)), ((("100000000000000008388608.00000000000000000" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.0000000000000001e+23 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((17 : GoInt)), ((("1.0000000000000001e+23" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.0000000000000001e+23 : GoFloat64)), ((((("e" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1.0000000000000001e+23" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.0000000000000001e+23 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("100000000000000010000000" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.0000000000000001e+23 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("1.0000000000000001e+23" : GoString)))) : T__struct_28)),
((new T__struct_28(((5e-324 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("5e-324" : GoString)))) : T__struct_28)),
((new T__struct_28(((-5e-324 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-5e-324" : GoString)))) : T__struct_28)),
((new T__struct_28(_fdiv(((5e-304 : GoFloat64)), ((1e+20 : GoFloat64))), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("5e-324" : GoString)))) : T__struct_28)),
((new T__struct_28(_fdiv(((-5e-304 : GoFloat64)), ((1e+20 : GoFloat64))), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-5e-324" : GoString)))) : T__struct_28)),
((new T__struct_28(((32 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("32" : GoString)))) : T__struct_28)),
((new T__struct_28(((32 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((0 : GoInt)), ((("3e+01" : GoString)))) : T__struct_28)),
((new T__struct_28(((100 : GoFloat64)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.9p+06" : GoString)))) : T__struct_28)),
((new T__struct_28(stdgo.math.Math.inf(((0 : GoInt))), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("+Inf" : GoString)))) : T__struct_28)),
((new T__struct_28(stdgo.math.Math.inf(((-1 : GoInt))), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-Inf" : GoString)))) : T__struct_28)),
((new T__struct_28(-stdgo.math.Math.inf(((0 : GoInt))), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-Inf" : GoString)))) : T__struct_28)),
((new T__struct_28(((-1 : GoFloat64)), ((((("b" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-4503599627370496p-52" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.9 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0.9" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.09 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0.1" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.0999 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0.1" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.05 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0.1" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.05 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.5 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0.5" : GoString)))) : T__struct_28)),
((new T__struct_28(((0.5 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_28)),
((new T__struct_28(((1.5 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("2" : GoString)))) : T__struct_28)),
((new T__struct_28(((2.2250738585072014e-308 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("2.2250738585072014e-308" : GoString)))) : T__struct_28)),
((new T__struct_28(((2.225073858507201e-308 : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("2.225073858507201e-308" : GoString)))) : T__struct_28)),
((new T__struct_28((("383260575764816448" : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("383260575764816448" : GoString)))) : T__struct_28)),
((new T__struct_28((("383260575764816448" : GoFloat64)), ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("3.8326057576481645e+17" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((-10 : GoInt)), ((("1" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((-11 : GoInt)), ((("1" : GoString)))) : T__struct_28)),
((new T__struct_28(((1 : GoFloat64)), ((((("f" : GoString))).code : GoRune)), ((-12 : GoInt)), ((("1" : GoString)))) : T__struct_28))) : Slice<T__struct_28>))) {
            var _f:Ref<Float_> = new Float_().setPrec(_actualPrec(_test._x)).setFloat64(_test._x);
            var _got:GoString = _f.text(_test._format, _test._prec);
            if (_got != _test._want) {
                _t.errorf(((("%v: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_test._want));
                continue;
            };
            if ((_test._format == ((((("b" : GoString))).code : GoRune))) && (_test._x == ((0 : GoFloat64)))) {
                continue;
            };
            if (_test._format == ((((("p" : GoString))).code : GoRune))) {
                continue;
            };
            var _want:GoString = stdgo.strconv.Strconv.formatFloat(_test._x, _test._format, _test._prec, ((64 : GoInt)));
            if (_got != _want) {
                _t.errorf(((("%v: got %s; want %s (strconv)" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function _actualPrec(_x:GoFloat64):GoUInt {
        {
            var _mant:GoUInt64 = stdgo.math.Math.float64bits(_x);
            if ((_x != ((0 : GoFloat64))) && ((_mant & (("9218868437227405312" : GoUInt64))) == ((0 : GoUInt64)))) {
                return ((64 : GoUInt)) - ((stdgo.math.bits.Bits.leadingZeros64(_mant & (("4503599627370495" : GoUInt64))) : GoUInt));
            };
        };
        return ((53 : GoUInt));
    }
function testFloatText(_t:stdgo.testing.Testing.T_):Void {
        {};
        for (_0 => _test in ((new Slice<T__struct_29>(
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-0" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-1" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-1" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1e+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("2.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2.5e+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.46e+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.459e+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("5.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5.4590e+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("E" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1E+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("2.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("E" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2.5E+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("E" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.46E+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("E" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.459E+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("5.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("E" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5.4590E+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_29)),
((new T__struct_29(((("2.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2.5" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.46" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.459" : GoString)))) : T__struct_29)),
((new T__struct_29(((("5.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5.4590" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1" : GoString)))) : T__struct_29)),
((new T__struct_29(((("2.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.5" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.46" : GoString)))) : T__struct_29)),
((new T__struct_29(((("5.459" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5.459" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1e+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("2459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2e+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.5e+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.46e+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("5459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5459" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("G" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1E+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("2459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("G" : GoString))).code : GoRune)), ((1 : GoInt)), ((("2E+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("G" : GoString))).code : GoRune)), ((2 : GoInt)), ((("3.5E+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("G" : GoString))).code : GoRune)), ((3 : GoInt)), ((("4.46E+03" : GoString)))) : T__struct_29)),
((new T__struct_29(((("5459" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("G" : GoString))).code : GoRune)), ((4 : GoInt)), ((("5459" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((40 : GoInt)), ((("3.0000000000000000000000000000000000000000e+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((40 : GoInt)), ((("3.0000000000000000000000000000000000000000" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3" : GoString))), ((255 : GoUInt8)), ((10 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((40 : GoInt)), ((("3" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3e40" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("e" : GoString))).code : GoRune)), ((40 : GoInt)), ((("3.0000000000000000000000000000000000000000e+40" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3e40" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("f" : GoString))).code : GoRune)), ((4 : GoInt)), ((("30000000000000000000000000000000000000000.0000" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3e40" : GoString))), ((255 : GoUInt8)), ((100 : GoUInt)), ((((("g" : GoString))).code : GoRune)), ((40 : GoInt)), ((("3e+40" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e1000000" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.88b3a28a05eade3ap+3321929" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e646456992" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.e883a0c5c8c7c42ap+2147483644" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e646456993" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("+Inf" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e1000000000" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("+Inf" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e-1000000" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.efb4542cc8ca418ap-3321928" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e-646456993" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.e17c8956983d9d59p-2147483647" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e-646456994" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1e-1000000000" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1p2147483646" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.8p+2147483647" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0x.8p2147483647" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.8p+2147483647" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0x.8p-2147483647" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.8p-2147483647" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1p-2147483649" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.8p-2147483648" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-0" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1.0" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("4503599627370496p-52" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-1.0" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-4503599627370496p-52" : GoString)))) : T__struct_29)),
((new T__struct_29(((("4503599627370496" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("4503599627370496p+0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString)))) : T__struct_29)),
((new T__struct_29(((("03" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3." : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.0" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.00" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.000" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("b" : GoString))).code : GoRune)), ((0 : GoInt)), ((("1720123961992553633708115671476565205597423741876210842803191629540192157066363606052513914832594264915968p-348" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.cp+2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("03" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.cp+2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3." : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.cp+2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.0" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.cp+2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.00" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.cp+2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.000" : GoString))), ((255 : GoUInt8)), ((350 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.cp+2" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1024.0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x.8p+11" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-1024.0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0x.8p+11" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x0p+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x0p+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0x0.0p+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x0.00000p+00" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.25" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x1p+02" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-3.25" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0x1p+02" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.25" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((1 : GoInt)), ((("0x1.ap+01" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-3.25" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((1 : GoInt)), ((("-0x1.ap+01" : GoString)))) : T__struct_29)),
((new T__struct_29(((("3.25" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.ap+01" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-3.25" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("-0x1.ap+01" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1024.0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x1p+10" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-1024.0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("-0x1p+10" : GoString)))) : T__struct_29)),
((new T__struct_29(((("1024.0" : GoString))), ((255 : GoUInt8)), ((64 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.00000p+10" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.0" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.fffp+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.5" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((3 : GoInt)), ((("0x1.000p+13" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x1p+13" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.fff888p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff9p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((0 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((1 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((2 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((3 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((4 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((5 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((3 : GoInt)), ((("0x1.000p+13" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((0 : GoInt)), ((("0x1p+13" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1.fff888p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((6 : GoInt)), ((("0x1.fff888p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((5 : GoInt)), ((("0x1.fff88p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.533203125" : GoString))), ((255 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff9p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((0 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((1 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff9p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((2 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((2 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((2 : GoInt)), ((("0x1.ffp+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((3 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff9p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((4 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-8191.53125" : GoString))), ((4 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("-0x1.fff9p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("8191.53125" : GoString))), ((5 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("0x1.fff9p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("-8191.53125" : GoString))), ((5 : GoUInt8)), ((53 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((4 : GoInt)), ((("-0x1.fff8p+12" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0x.8p-2147483648" : GoString))), ((0 : GoUInt8)), ((4 : GoUInt)), ((((("p" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x.8p-2147483648" : GoString)))) : T__struct_29)),
((new T__struct_29(((("0x.8p-2147483648" : GoString))), ((0 : GoUInt8)), ((4 : GoUInt)), ((((("x" : GoString))).code : GoRune)), ((-1 : GoInt)), ((("0x1p-2147483649" : GoString)))) : T__struct_29))) : Slice<T__struct_29>))) {
            var __tmp__ = parseFloat(_test._x, ((0 : GoInt)), _test._prec, ((0 : GoUInt8))), _f:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err != null) {
                _t.errorf(((("%v: %s" : GoString))), Go.toInterface(_test), Go.toInterface(_err));
                continue;
            };
            if (_test._round != ((255 : GoUInt8))) {
                _f.setMode(_test._round);
            };
            var _got:GoString = _f.text(_test._format, _test._digits);
            if (_got != _test._want) {
                _t.errorf(((("%v: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_test._want));
            };
            if ((((_test._prec == ((53 : GoUInt))) && (_test._format != ((((("p" : GoString))).code : GoRune)))) && (_f.sign() != ((0 : GoInt)))) && ((_test._round == ((0 : GoUInt8))) || (_test._round == ((255 : GoUInt8))))) {
                var __tmp__ = _f.float64(), _f64:GoFloat64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
                if (_acc != ((0 : GoInt8))) {
                    _t.errorf(((("%v: expected exact conversion to float64" : GoString))), Go.toInterface(_test));
                    continue;
                };
                var _got:GoString = stdgo.strconv.Strconv.formatFloat(_f64, _test._format, _test._digits, ((64 : GoInt)));
                if (_got != _test._want) {
                    _t.errorf(((("%v: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testFloatFormat(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_30>(
((new T__struct_30(((("%+.3e" : GoString))), Go.toInterface(((0 : GoFloat64))), ((("+0.000e+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3e" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("+1.000e+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1.000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3F" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1.000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3F" : GoString))), Go.toInterface(((((-1 : GoFloat32)) : GoFloat32))), ((("-1.000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+07.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("+001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+07.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+10.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("     +1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+10.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("     -1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% .3E" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1.000E+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% .3e" : GoString))), Go.toInterface(((1 : GoFloat64))), (((" 1.000e+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3g" : GoString))), Go.toInterface(((0 : GoFloat64))), ((("+0" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3g" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("+1" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.3g" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% .3g" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% .3g" : GoString))), Go.toInterface(((1 : GoFloat64))), (((" 1" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%b" : GoString))), Go.toInterface(((((1 : GoFloat32)) : GoFloat32))), ((("8388608p-23" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%b" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("4503599627370496p-52" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%e" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("1.000000e+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%e" : GoString))), Go.toInterface(((1.2345678e+06 : GoFloat64))), ((("1.234568e+06" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%e" : GoString))), Go.toInterface(((1.2345678e-05 : GoFloat64))), ((("1.234568e-05" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%e" : GoString))), Go.toInterface(((-7 : GoFloat64))), ((("-7.000000e+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%e" : GoString))), Go.toInterface(((-1e-09 : GoFloat64))), ((("-1.000000e-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%f" : GoString))), Go.toInterface(((1.2345678e+06 : GoFloat64))), ((("1234567.800000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%f" : GoString))), Go.toInterface(((1.2345678e-05 : GoFloat64))), ((("0.000012" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%f" : GoString))), Go.toInterface(((-7 : GoFloat64))), ((("-7.000000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%f" : GoString))), Go.toInterface(((-1e-09 : GoFloat64))), ((("-0.000000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((1.2345678e+06 : GoFloat64))), ((("1.2345678e+06" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((((1.2345678e+06 : GoFloat32)) : GoFloat32))), ((("1.2345678e+06" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((1.2345678e-05 : GoFloat64))), ((("1.2345678e-05" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((-7 : GoFloat64))), ((("-7" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((-1e-09 : GoFloat64))), ((("-1e-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((((-1e-09 : GoFloat32)) : GoFloat32))), ((("-1e-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%E" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("1.000000E+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%E" : GoString))), Go.toInterface(((1.2345678e+06 : GoFloat64))), ((("1.234568E+06" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%E" : GoString))), Go.toInterface(((1.2345678e-05 : GoFloat64))), ((("1.234568E-05" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%E" : GoString))), Go.toInterface(((-7 : GoFloat64))), ((("-7.000000E+00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%E" : GoString))), Go.toInterface(((-1e-09 : GoFloat64))), ((("-1.000000E-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%G" : GoString))), Go.toInterface(((1.2345678e+06 : GoFloat64))), ((("1.2345678E+06" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%G" : GoString))), Go.toInterface(((((1.2345678e+06 : GoFloat32)) : GoFloat32))), ((("1.2345678E+06" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%G" : GoString))), Go.toInterface(((1.2345678e-05 : GoFloat64))), ((("1.2345678E-05" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%G" : GoString))), Go.toInterface(((-7 : GoFloat64))), ((("-7" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%G" : GoString))), Go.toInterface(((-1e-09 : GoFloat64))), ((("-1E-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%G" : GoString))), Go.toInterface(((((-1e-09 : GoFloat32)) : GoFloat32))), ((("-1E-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20.6e" : GoString))), Go.toInterface(((1234.5 : GoFloat64))), ((("        1.234500e+03" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20.6e" : GoString))), Go.toInterface(((0.0012345 : GoFloat64))), ((("        1.234500e-03" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20e" : GoString))), Go.toInterface(((1234.5 : GoFloat64))), ((("        1.234500e+03" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20e" : GoString))), Go.toInterface(((0.0012345 : GoFloat64))), ((("        1.234500e-03" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20.8e" : GoString))), Go.toInterface(((1234.5 : GoFloat64))), ((("      1.23450000e+03" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20f" : GoString))), Go.toInterface(((1234.56789 : GoFloat64))), ((("         1234.567890" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20f" : GoString))), Go.toInterface(((0.00123456789 : GoFloat64))), ((("            0.001235" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20f" : GoString))), Go.toInterface(((1.2345678901234568e+10 : GoFloat64))), ((("  12345678901.234568" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%-20f" : GoString))), Go.toInterface(((1234.56789 : GoFloat64))), ((("1234.567890         " : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20.8f" : GoString))), Go.toInterface(((1234.56789 : GoFloat64))), ((("       1234.56789000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20.8f" : GoString))), Go.toInterface(((0.00123456789 : GoFloat64))), ((("          0.00123457" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((1234.56789 : GoFloat64))), ((("1234.56789" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((0.00123456789 : GoFloat64))), ((("0.00123456789" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%g" : GoString))), Go.toInterface(((1.23456789e+20 : GoFloat64))), ((("1.23456789e+20" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20e" : GoString))), Go.toInterface(stdgo.math.Math.inf(((1 : GoInt)))), ((("                +Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%-20f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((-1 : GoInt)))), ((("-Inf                " : GoString)))) : T__struct_30)),
((new T__struct_30(((("%.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% .2f" : GoString))), Go.toInterface(((1 : GoFloat64))), (((" 1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% .2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("+1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%7.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("   1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%7.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("  -1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 7.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("   1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 7.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("  -1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+7.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("  +1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+7.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("  -1.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%07.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("0001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%07.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 07.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), (((" 001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 07.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+07.2f" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("+001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+07.2f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("-001.00" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%020f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((-1 : GoInt)))), ((("                -Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%020f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((1 : GoInt)))), ((("                +Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 020f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((-1 : GoInt)))), ((("                -Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 020f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((1 : GoInt)))), ((("                 Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+020f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((-1 : GoInt)))), ((("                -Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%+020f" : GoString))), Go.toInterface(stdgo.math.Math.inf(((1 : GoInt)))), ((("                +Inf" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%20f" : GoString))), Go.toInterface(((-1 : GoFloat64))), ((("           -1.000000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%v" : GoString))), Go.toInterface(((0 : GoFloat64))), ((("0" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%v" : GoString))), Go.toInterface(((-7 : GoFloat64))), ((("-7" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%v" : GoString))), Go.toInterface(((-1e-09 : GoFloat64))), ((("-1e-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%v" : GoString))), Go.toInterface(((((-1e-09 : GoFloat32)) : GoFloat32))), ((("-1e-09" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%010v" : GoString))), Go.toInterface(((0 : GoFloat64))), ((("0000000000" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%.20f" : GoString))), Go.toInterface(((("1e-20" : GoString)))), ((("0.00000000000000000001" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%.20f" : GoString))), Go.toInterface(((("-1e-20" : GoString)))), ((("-0.00000000000000000001" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%30.20f" : GoString))), Go.toInterface(((("-1e-20" : GoString)))), ((("       -0.00000000000000000001" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%030.20f" : GoString))), Go.toInterface(((("-1e-20" : GoString)))), ((("-00000000.00000000000000000001" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%030.20f" : GoString))), Go.toInterface(((("+1e-20" : GoString)))), ((("000000000.00000000000000000001" : GoString)))) : T__struct_30)),
((new T__struct_30(((("% 030.20f" : GoString))), Go.toInterface(((("+1e-20" : GoString)))), (((" 00000000.00000000000000000001" : GoString)))) : T__struct_30)),
((new T__struct_30(((("%s" : GoString))), Go.toInterface(((1 : GoFloat64))), ((("%!s(*big.Float=1)" : GoString)))) : T__struct_30))) : Slice<T__struct_30>))) {
            var _value:Ref<Float_> = new Float_();
            if (Go.assertable(((_test._value : GoFloat32)))) {
                var _v:GoFloat32 = _test._value == null ? null : _test._value.__underlying__() == null ? null : _test._value == null ? null : _test._value.__underlying__().value;
                _value.setPrec(((24 : GoUInt))).setFloat64(((_v : GoFloat64)));
            } else if (Go.assertable(((_test._value : GoFloat64)))) {
                var _v:GoFloat64 = _test._value == null ? null : _test._value.__underlying__() == null ? null : _test._value == null ? null : _test._value.__underlying__().value;
                _value.setPrec(((53 : GoUInt))).setFloat64(_v);
            } else if (Go.assertable(((_test._value : GoString)))) {
                var _v:GoString = _test._value == null ? null : _test._value.__underlying__() == null ? null : _test._value == null ? null : _test._value.__underlying__().value;
                _value.setPrec(((512 : GoUInt))).parse(_v, ((0 : GoInt)));
            } else {
                var _v:AnyInterface = _test._value == null ? null : _test._value.__underlying__();
                _t.fatalf(((("unsupported test value: %v (%T)" : GoString))), Go.toInterface(_v), Go.toInterface(_v));
            };
            {
                var _got:GoString = stdgo.fmt.Fmt.sprintf(_test._format, Go.toInterface(_value));
                if (_got != _test._want) {
                    _t.errorf(((("%v: got %q; want %q" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function benchmarkParseFloatSmallExp(_b:stdgo.testing.Testing.B):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                for (_0 => _s in ((new Slice<GoString>(
((("1e0" : GoString))),
((("1e-1" : GoString))),
((("1e-2" : GoString))),
((("1e-3" : GoString))),
((("1e-4" : GoString))),
((("1e-5" : GoString))),
((("1e-10" : GoString))),
((("1e-20" : GoString))),
((("1e-50" : GoString))),
((("1e1" : GoString))),
((("1e2" : GoString))),
((("1e3" : GoString))),
((("1e4" : GoString))),
((("1e5" : GoString))),
((("1e10" : GoString))),
((("1e20" : GoString))),
((("1e50" : GoString)))) : Slice<GoString>))) {
                    var _x:Float_ = new Float_();
                    var __tmp__ = _x.parse(_s, ((0 : GoInt))), _1:Ref<Float_> = __tmp__._0, _2:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
                    if (_err != null) {
                        _b.fatalf(((("%s: %v" : GoString))), Go.toInterface(_s), Go.toInterface(_err));
                    };
                };
            });
        };
    }
function benchmarkParseFloatLargeExp(_b:stdgo.testing.Testing.B):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                for (_0 => _s in ((new Slice<GoString>(
((("1e0" : GoString))),
((("1e-10" : GoString))),
((("1e-20" : GoString))),
((("1e-30" : GoString))),
((("1e-40" : GoString))),
((("1e-50" : GoString))),
((("1e-100" : GoString))),
((("1e-500" : GoString))),
((("1e-1000" : GoString))),
((("1e-5000" : GoString))),
((("1e-10000" : GoString))),
((("1e10" : GoString))),
((("1e20" : GoString))),
((("1e30" : GoString))),
((("1e40" : GoString))),
((("1e50" : GoString))),
((("1e100" : GoString))),
((("1e500" : GoString))),
((("1e1000" : GoString))),
((("1e5000" : GoString))),
((("1e10000" : GoString)))) : Slice<GoString>))) {
                    var _x:Float_ = new Float_();
                    var __tmp__ = _x.parse(_s, ((0 : GoInt))), _1:Ref<Float_> = __tmp__._0, _2:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
                    if (_err != null) {
                        _b.fatalf(((("%s: %v" : GoString))), Go.toInterface(_s), Go.toInterface(_err));
                    };
                };
            });
        };
    }
function testFloatScan(_t:stdgo.testing.Testing.T_):Void {
        var _floatScanTests:Slice<T__struct_31> = {
            var s:Slice<T__struct_31> = new Slice<T__struct_31>(...([for (i in 0 ... 13) new T__struct_31()]));
            s[0] = ((new T__struct_31(((("10.0" : GoString))), ((("%f" : GoString))), ((("10" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[1] = ((new T__struct_31(((("23.98+2.0" : GoString))), ((("%v" : GoString))), ((("23.98" : GoString))), ((4 : GoInt)), false) : T__struct_31));
            s[2] = ((new T__struct_31(((("-1+1" : GoString))), ((("%v" : GoString))), ((("-1" : GoString))), ((2 : GoInt)), false) : T__struct_31));
            s[3] = ((new T__struct_31((((" 00000" : GoString))), ((("%v" : GoString))), ((("0" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[4] = ((new T__struct_31(((("-123456p-78" : GoString))), ((("%b" : GoString))), ((("-4.084816388e-19" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[5] = ((new T__struct_31(((("+123" : GoString))), ((("%b" : GoString))), ((("123" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[6] = ((new T__struct_31(((("-1.234e+56" : GoString))), ((("%e" : GoString))), ((("-1.234e+56" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[7] = ((new T__struct_31(((("-1.234E-56" : GoString))), ((("%E" : GoString))), ((("-1.234e-56" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[8] = ((new T__struct_31(((("-1.234e+567" : GoString))), ((("%g" : GoString))), ((("-1.234e+567" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[9] = ((new T__struct_31(((("+1234567891011.234" : GoString))), ((("%G" : GoString))), ((("1.234567891e+12" : GoString))), ((0 : GoInt)), false) : T__struct_31));
            s[10] = ((new T__struct_31(((("Inf" : GoString))), ((("%v" : GoString))), ((("" : GoString))), ((3 : GoInt)), true) : T__struct_31));
            s[11] = ((new T__struct_31(((("-Inf" : GoString))), ((("%v" : GoString))), ((("" : GoString))), ((3 : GoInt)), true) : T__struct_31));
            s[12] = ((new T__struct_31(((("-Inf" : GoString))), ((("%v" : GoString))), ((("" : GoString))), ((3 : GoInt)), true) : T__struct_31));
            s;
        };
        var _buf:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        for (_i => _test in _floatScanTests) {
            var _x:Ref<Float_> = new Float_();
            _buf.reset();
            _buf.writeString(_test._input);
            var __tmp__ = stdgo.fmt.Fmt.fscanf(_buf, _test._format, Go.toInterface(_x)), _0:GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_test._wantErr) {
                if (_err == null) {
                    _t.errorf(((("#%d want non-nil err" : GoString))), Go.toInterface(_i));
                };
                continue;
            };
            if (_err != null) {
                _t.errorf(((("#%d error: %s" : GoString))), Go.toInterface(_i), Go.toInterface(_err));
            };
            if (((_x.toString() : GoString)) != _test._output) {
                _t.errorf(((("#%d got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(((_x.toString() : GoString))), Go.toInterface(_test._output));
            };
            if (_buf.len() != _test._remaining) {
                _t.errorf(((("#%d got %d bytes remaining; want %d" : GoString))), Go.toInterface(_i), Go.toInterface(_buf.len()), Go.toInterface(_test._remaining));
            };
        };
    }
function testFloatGobEncoding(_t:stdgo.testing.Testing.T_):Void {
        var _medium:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        var _enc:Ref<stdgo.encoding.gob.Gob.Encoder> = stdgo.encoding.gob.Gob.newEncoder(_medium);
        var _dec:Ref<stdgo.encoding.gob.Gob.Decoder> = stdgo.encoding.gob.Gob.newDecoder(_medium);
        for (_0 => _test in _floatVals) {
            for (_1 => _sign in ((new Slice<GoString>(((("" : GoString))), ((("+" : GoString))), ((("-" : GoString)))) : Slice<GoString>))) {
                for (_2 => _prec in ((new Slice<GoUInt>(((0 : GoUInt)), ((1 : GoUInt)), ((2 : GoUInt)), ((10 : GoUInt)), ((53 : GoUInt)), ((64 : GoUInt)), ((100 : GoUInt)), ((1000 : GoUInt))) : Slice<GoUInt>))) {
                    for (_3 => _mode in ((new Slice<RoundingMode>(((0 : GoUInt8)), ((1 : GoUInt8)), ((2 : GoUInt8)), ((3 : GoUInt8)), ((4 : GoUInt8)), ((5 : GoUInt8))) : Slice<RoundingMode>))) {
                        _medium.reset();
                        var _x:GoString = _sign + _test;
                        var _tx:Float_ = new Float_();
                        var __tmp__ = _tx.setPrec(_prec).setMode(_mode).parse(_x, ((0 : GoInt))), _4:Ref<Float_> = __tmp__._0, _5:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
                        if (_err != null) {
                            _t.errorf(((("parsing of %s (%dbits, %v) failed (invalid test case): %v" : GoString))), Go.toInterface(_x), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_err));
                            continue;
                        };
                        if (_prec == ((0 : GoUInt))) {
                            _tx.setPrec(((0 : GoUInt)));
                        };
                        {
                            var _err:stdgo.Error = _enc.encode(Go.toInterface(_tx));
                            if (_err != null) {
                                _t.errorf(((("encoding of %v (%dbits, %v) failed: %v" : GoString))), Go.toInterface(_tx), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_err));
                                continue;
                            };
                        };
                        var _rx:Float_ = new Float_();
                        {
                            var _err:stdgo.Error = _dec.decode(Go.toInterface(_rx));
                            if (_err != null) {
                                _t.errorf(((("decoding of %v (%dbits, %v) failed: %v" : GoString))), Go.toInterface(_tx), Go.toInterface(_prec), Go.toInterface(_mode), Go.toInterface(_err));
                                continue;
                            };
                        };
                        if (_rx.cmp(_tx) != ((0 : GoInt))) {
                            _t.errorf(((("transmission of %s failed: got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(((_rx.toString() : GoString))), Go.toInterface(((_tx.toString() : GoString))));
                            continue;
                        };
                        if (_rx.prec() != _prec) {
                            _t.errorf(((("transmission of %s\'s prec failed: got %d want %d" : GoString))), Go.toInterface(_x), Go.toInterface(_rx.prec()), Go.toInterface(_prec));
                        };
                        if (_rx.mode() != _mode) {
                            _t.errorf(((("transmission of %s\'s mode failed: got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_rx.mode()), Go.toInterface(_mode));
                        };
                        if (_rx.acc() != _tx.acc()) {
                            _t.errorf(((("transmission of %s\'s accuracy failed: got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_rx.acc()), Go.toInterface(_tx.acc()));
                        };
                    };
                };
            };
        };
    }
function testFloatCorruptGob(_t:stdgo.testing.Testing.T_):Void {
        var _buf:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        var _tx:Ref<Float_> = newFloat(((1 : GoFloat64))).setPrec(((1000 : GoUInt))).setMode(((5 : GoUInt8)));
        {
            var _err:stdgo.Error = stdgo.encoding.gob.Gob.newEncoder(_buf).encode(Go.toInterface(_tx));
            if (_err != null) {
                _t.fatal(Go.toInterface(_err));
            };
        };
        var _b:Slice<GoUInt8> = _buf.bytes();
        var _rx:Float_ = new Float_();
        {
            var _err:stdgo.Error = stdgo.encoding.gob.Gob.newDecoder(stdgo.bytes.Bytes.newReader(_b)).decode(Go.toInterface(_rx));
            if (_err != null) {
                _t.fatal(Go.toInterface(_err));
            };
        };
        {
            var _err:stdgo.Error = stdgo.encoding.gob.Gob.newDecoder(stdgo.bytes.Bytes.newReader(((_b.__slice__(0, ((10 : GoInt))) : Slice<GoUInt8>)))).decode(Go.toInterface(_rx));
            if (_err != stdgo.io.Io.errUnexpectedEOF) {
                _t.errorf(((("got %v want EOF" : GoString))), Go.toInterface(_err));
            };
        };
        if (_b != null) _b[((1 : GoInt))] = ((0 : GoUInt8));
        {
            var _err:stdgo.Error = stdgo.encoding.gob.Gob.newDecoder(stdgo.bytes.Bytes.newReader(_b)).decode(Go.toInterface(_rx));
            if (_err == null) {
                _t.fatal(Go.toInterface(((("got nil want version error" : GoString)))));
            };
        };
    }
function testFloatJSONEncoding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in _floatVals) {
            for (_1 => _sign in ((new Slice<GoString>(((("" : GoString))), ((("+" : GoString))), ((("-" : GoString)))) : Slice<GoString>))) {
                for (_2 => _prec in ((new Slice<GoUInt>(((0 : GoUInt)), ((1 : GoUInt)), ((2 : GoUInt)), ((10 : GoUInt)), ((53 : GoUInt)), ((64 : GoUInt)), ((100 : GoUInt)), ((1000 : GoUInt))) : Slice<GoUInt>))) {
                    if ((_prec > ((53 : GoUInt))) && stdgo.testing.Testing.short()) {
                        continue;
                    };
                    var _x:GoString = _sign + _test;
                    var _tx:Float_ = new Float_();
                    var __tmp__ = _tx.setPrec(_prec).parse(_x, ((0 : GoInt))), _3:Ref<Float_> = __tmp__._0, _4:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
                    if (_err != null) {
                        _t.errorf(((("parsing of %s (prec = %d) failed (invalid test case): %v" : GoString))), Go.toInterface(_x), Go.toInterface(_prec), Go.toInterface(_err));
                        continue;
                    };
                    var __tmp__ = stdgo.encoding.json.Json.marshal(Go.toInterface(_tx)), _b:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                    if (_err != null) {
                        _t.errorf(((("marshaling of %v (prec = %d) failed: %v" : GoString))), Go.toInterface(_tx), Go.toInterface(_prec), Go.toInterface(_err));
                        continue;
                    };
                    var _rx:Float_ = new Float_();
                    _rx.setPrec(_prec);
                    {
                        var _err:stdgo.Error = stdgo.encoding.json.Json.unmarshal(_b, Go.toInterface(_rx));
                        if (_err != null) {
                            _t.errorf(((("unmarshaling of %v (prec = %d) failed: %v" : GoString))), Go.toInterface(_tx), Go.toInterface(_prec), Go.toInterface(_err));
                            continue;
                        };
                    };
                    if (_rx.cmp(_tx) != ((0 : GoInt))) {
                        _t.errorf(((("JSON encoding of %v (prec = %d) failed: got %v want %v" : GoString))), Go.toInterface(_tx), Go.toInterface(_prec), Go.toInterface(_rx), Go.toInterface(_tx));
                    };
                };
            };
        };
    }
function _roundShortest(_d:T_decimal, _x:Float_):Void {
        if ((_d._mant != null ? _d._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return;
        };
        var _mant:T_nat = (((new T_nat() : T_nat))._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
        var _exp:GoInt = ((_x._exp : GoInt)) - _mant._bitLen();
        var _s:GoInt = _mant._bitLen() - (((_x._prec + ((1 : GoUInt32))) : GoInt));
        if (_s < ((0 : GoInt))) {
            _mant = (_mant._shl((_mant == null ? null : _mant.__copy__()), ((-_s : GoUInt))) == null ? null : _mant._shl((_mant == null ? null : _mant.__copy__()), ((-_s : GoUInt))).__copy__());
        } else if (_s > ((0 : GoInt))) {
            _mant = (_mant._shr((_mant == null ? null : _mant.__copy__()), ((_s : GoUInt))) == null ? null : _mant._shr((_mant == null ? null : _mant.__copy__()), ((_s : GoUInt))).__copy__());
        };
        _exp = _exp + (_s);
        var _lower:T_decimal = new T_decimal();
        var _tmp:T_nat = new T_nat();
        _lower._init((_tmp._sub((_mant == null ? null : _mant.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _tmp._sub((_mant == null ? null : _mant.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__()), _exp);
        var _upper:T_decimal = new T_decimal();
        _upper._init((_tmp._add((_mant == null ? null : _mant.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _tmp._add((_mant == null ? null : _mant.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__()), _exp);
        var _inclusive:Bool = ((_mant != null ? _mant[((0 : GoInt))] : new Word()) & ((2 : GoUInt))) == ((0 : GoUInt));
        for (_i => _m in _d._mant) {
            var _l:GoUInt8 = _lower._at(_i);
            var _u:GoUInt8 = _upper._at(_i);
            var _okdown:Bool = (_l != _m) || (_inclusive && ((_i + ((1 : GoInt))) == (_lower._mant != null ? _lower._mant.length : ((0 : GoInt)))));
            var _okup:Bool = (_m != _u) && ((_inclusive || ((_m + ((1 : GoUInt8))) < _u)) || ((_i + ((1 : GoInt))) < (_upper._mant != null ? _upper._mant.length : ((0 : GoInt)))));
            if (_okdown && _okup) {
                _d._round(_i + ((1 : GoInt)));
                return;
            } else if (_okdown) {
                _d._roundDown(_i + ((1 : GoInt)));
                return;
            } else if (_okup) {
                _d._roundUp(_i + ((1 : GoInt)));
                return;
            };
        };
    }
function _fmtE(_buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt, _d:T_decimal):Slice<GoByte> {
        var _ch:GoUInt8 = ((((((("0" : GoString))).code : GoRune)) : GoByte));
        if ((_d._mant != null ? _d._mant.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _ch = (_d._mant != null ? _d._mant[((0 : GoInt))] : ((0 : GoUInt8)));
        };
        _buf = (_buf != null ? _buf.__append__(_ch) : new Slice<GoUInt8>(_ch));
        if (_prec > ((0 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            var _i:GoInt = ((1 : GoInt));
            var _m:GoInt = _min((_d._mant != null ? _d._mant.length : ((0 : GoInt))), _prec + ((1 : GoInt)));
            if (_i < _m) {
                _buf = (_buf != null ? _buf.__append__(...((_d._mant.__slice__(_i, _m) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_d._mant.__slice__(_i, _m) : Slice<GoUInt8>)).__toArray__()));
                _i = _m;
            };
            Go.cfor(_i <= _prec, _i++, {
                _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
            });
        };
        _buf = (_buf != null ? _buf.__append__(_fmt) : new Slice<GoUInt8>(_fmt));
        var _exp:GoInt64 = ((0 : GoInt64));
        if ((_d._mant != null ? _d._mant.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _exp = ((_d._exp : GoInt64)) - ((1 : GoInt64));
        };
        if (_exp < ((0 : GoInt64))) {
            _ch = ((((("-" : GoString))).code : GoRune));
            _exp = -_exp;
        } else {
            _ch = ((((("+" : GoString))).code : GoRune));
        };
        _buf = (_buf != null ? _buf.__append__(_ch) : new Slice<GoUInt8>(_ch));
        if (_exp < ((10 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _exp, ((10 : GoInt)));
    }
function _fmtF(_buf:Slice<GoByte>, _prec:GoInt, _d:T_decimal):Slice<GoByte> {
        if (_d._exp > ((0 : GoInt))) {
            var _m:GoInt = _min((_d._mant != null ? _d._mant.length : ((0 : GoInt))), _d._exp);
            _buf = (_buf != null ? _buf.__append__(...((_d._mant.__slice__(0, _m) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_d._mant.__slice__(0, _m) : Slice<GoUInt8>)).__toArray__()));
            Go.cfor(_m < _d._exp, _m++, {
                _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
            });
        } else {
            _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (_prec > ((0 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _prec, _i++, {
                    _buf = (_buf != null ? _buf.__append__(_d._at(_d._exp + _i)) : new Slice<GoUInt8>(_d._at(_d._exp + _i)));
                });
            };
        };
        return _buf;
    }
function _min(_x:GoInt, _y:GoInt):GoInt {
        if (_x < _y) {
            return _x;
        };
        return _y;
    }
function _randInt(_r:stdgo.math.rand.Rand.Rand, _size:GoUInt):Int_ {
        var _n:Ref<Int_> = new Int_().lsh(_intOne, _size - ((1 : GoUInt)));
        var _x:Ref<Int_> = new Int_().rand(_r, _n);
        return _x.add(_x, _n);
    }
function _runGCD(_b:stdgo.testing.Testing.B, _aSize:GoUInt, _bSize:GoUInt):Void {
        if (_isRaceBuilder && ((_aSize > ((1000 : GoUInt))) || (_bSize > ((1000 : GoUInt))))) {
            _b.skip(Go.toInterface(((("skipping on race builder" : GoString)))));
        };
        _b.run(((("WithoutXY" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            _runGCDExt(_b, _aSize, _bSize, false);
        });
        _b.run(((("WithXY" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            _runGCDExt(_b, _aSize, _bSize, true);
        });
    }
function _runGCDExt(_b:stdgo.testing.Testing.B, _aSize:GoUInt, _bSize:GoUInt, _calcXY:Bool):Void {
        _b.stopTimer();
        var _r:Ref<stdgo.math.rand.Rand.Rand> = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource(((1234 : GoInt64))));
        var _aa:Ref<Int_> = _randInt(_r, _aSize);
        var _bb:Ref<Int_> = _randInt(_r, _bSize);
        var _x:Int_ = ((null : Ref<Int_>)), _y:Int_ = ((null : Ref<Int_>));
        if (_calcXY) {
            _x = new Int_();
            _y = new Int_();
        };
        _b.startTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                new Int_().gcd(_x, _y, _aa, _bb);
            });
        };
    }
function benchmarkGCD10x10(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10 : GoUInt)), ((10 : GoUInt)));
    }
function benchmarkGCD10x100(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10 : GoUInt)), ((100 : GoUInt)));
    }
function benchmarkGCD10x1000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10 : GoUInt)), ((1000 : GoUInt)));
    }
function benchmarkGCD10x10000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10 : GoUInt)), ((10000 : GoUInt)));
    }
function benchmarkGCD10x100000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10 : GoUInt)), ((100000 : GoUInt)));
    }
function benchmarkGCD100x100(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((100 : GoUInt)), ((100 : GoUInt)));
    }
function benchmarkGCD100x1000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((100 : GoUInt)), ((1000 : GoUInt)));
    }
function benchmarkGCD100x10000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((100 : GoUInt)), ((10000 : GoUInt)));
    }
function benchmarkGCD100x100000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((100 : GoUInt)), ((100000 : GoUInt)));
    }
function benchmarkGCD1000x1000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((1000 : GoUInt)), ((1000 : GoUInt)));
    }
function benchmarkGCD1000x10000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((1000 : GoUInt)), ((10000 : GoUInt)));
    }
function benchmarkGCD1000x100000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((1000 : GoUInt)), ((100000 : GoUInt)));
    }
function benchmarkGCD10000x10000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10000 : GoUInt)), ((10000 : GoUInt)));
    }
function benchmarkGCD10000x100000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((10000 : GoUInt)), ((100000 : GoUInt)));
    }
function benchmarkGCD100000x100000(_b:stdgo.testing.Testing.B):Void {
        _runGCD(_b, ((100000 : GoUInt)), ((100000 : GoUInt)));
    }
function _newMatrix(_n:GoInt, _m:GoInt):T_matrix {
        if (!((((0 : GoInt)) <= _n) && (((0 : GoInt)) <= _m))) {
            throw Go.toInterface(((("illegal matrix" : GoString))));
        };
        var _a:Ref<T_matrix> = new T_matrix();
        _a._n = _n;
        _a._m = _m;
        _a._a = new Slice<Ref<Rat>>(...[for (i in 0 ... ((_n * _m : GoInt)).toBasic()) ((null : Ref<Rat>))]);
        return _a;
    }
function _newUnit(_n:GoInt):T_matrix {
        var _a:Ref<T_matrix> = _newMatrix(_n, _n);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _n, _j++, {
                        var _x:Ref<Rat> = newRat(((0 : GoInt64)), ((1 : GoInt64)));
                        if (_i == _j) {
                            _x.setInt64(((1 : GoInt64)));
                        };
                        _a._set(_i, _j, _x);
                    });
                };
            });
        };
        return _a;
    }
function _newHilbert(_n:GoInt):T_matrix {
        var _a:Ref<T_matrix> = _newMatrix(_n, _n);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _n, _j++, {
                        _a._set(_i, _j, newRat(((1 : GoInt64)), ((((_i + _j) + ((1 : GoInt))) : GoInt64))));
                    });
                };
            });
        };
        return _a;
    }
function _newInverseHilbert(_n:GoInt):T_matrix {
        var _a:Ref<T_matrix> = _newMatrix(_n, _n);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _n, _j++, {
                        var _x1:Ref<Rat> = new Rat().setInt64(((((_i + _j) + ((1 : GoInt))) : GoInt64)));
                        var _x2:Ref<Rat> = new Rat().setInt(new Int_().binomial((((_n + _i) : GoInt64)), ((((_n - _j) - ((1 : GoInt))) : GoInt64))));
                        var _x3:Ref<Rat> = new Rat().setInt(new Int_().binomial((((_n + _j) : GoInt64)), ((((_n - _i) - ((1 : GoInt))) : GoInt64))));
                        var _x4:Ref<Rat> = new Rat().setInt(new Int_().binomial((((_i + _j) : GoInt64)), ((_i : GoInt64))));
                        _x1.mul(_x1, _x2);
                        _x1.mul(_x1, _x3);
                        _x1.mul(_x1, _x4);
                        _x1.mul(_x1, _x4);
                        if (((_i + _j) & ((1 : GoInt))) != ((0 : GoInt))) {
                            _x1.neg(_x1);
                        };
                        _a._set(_i, _j, _x1);
                    });
                };
            });
        };
        return _a;
    }
function _doHilbert(_t:stdgo.testing.Testing.T_, _n:GoInt):Void {
        var _a:Ref<T_matrix> = _newHilbert(_n);
        var _b:Ref<T_matrix> = _newInverseHilbert(_n);
        var i:Ref<T_matrix> = _newUnit(_n);
        var _ab:Ref<T_matrix> = _a._mul(_b);
        if (!_ab._eql(i)) {
            if (_t == null) {
                throw Go.toInterface(((("Hilbert failed" : GoString))));
            };
            _t.errorf(((("a   = %s\n" : GoString))), Go.toInterface(_a));
            _t.errorf(((("b   = %s\n" : GoString))), Go.toInterface(_b));
            _t.errorf(((("a*b = %s\n" : GoString))), Go.toInterface(_ab));
            _t.errorf(((("I   = %s\n" : GoString))), Go.toInterface(i));
        };
    }
function testHilbert(_t:stdgo.testing.Testing.T_):Void {
        _doHilbert(_t, ((10 : GoInt)));
    }
function benchmarkHilbert(_b:stdgo.testing.Testing.B):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _doHilbert(null, ((10 : GoInt)));
            });
        };
    }
function newInt(_x:GoInt64):Int_ {
        return new Int_().setInt64(_x);
    }
function _low32(_x:T_nat):GoUInt32 {
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoUInt32));
        };
        return (((_x != null ? _x[((0 : GoInt))] : new Word()) : GoUInt32));
    }
function _low64(_x:T_nat):GoUInt64 {
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoUInt64));
        };
        var _v:GoUInt64 = (((_x != null ? _x[((0 : GoInt))] : new Word()) : GoUInt64));
        if (true && ((_x != null ? _x.length : ((0 : GoInt))) > ((1 : GoInt)))) {
            return ((((_x != null ? _x[((1 : GoInt))] : new Word()) : GoUInt64)) << ((32 : GoUnTypedInt))) | _v;
        };
        return _v;
    }
function _lehmerSimulate(a:Int_, b:Int_):{ var _0 : Word; var _1 : Word; var _2 : Word; var _3 : Word; var _4 : Bool; } {
        var _u0:Word = new Word(), _u1:Word = new Word(), _v0:Word = new Word(), _v1:Word = new Word(), _even:Bool = false;
        var _a1:Word = new Word(), _a2:Word = new Word(), _u2:Word = new Word(), _v2:Word = new Word();
        var _m:GoInt = (b._abs != null ? b._abs.length : ((0 : GoInt)));
        var _n:GoInt = (a._abs != null ? a._abs.length : ((0 : GoInt)));
        var _h:GoUInt = _nlz((a._abs != null ? a._abs[_n - ((1 : GoInt))] : new Word()));
        _a1 = ((a._abs != null ? a._abs[_n - ((1 : GoInt))] : new Word()) << _h) | ((a._abs != null ? a._abs[_n - ((2 : GoInt))] : new Word()) >> (((32 : GoUInt)) - _h));
        if (_n == _m) {
            _a2 = ((b._abs != null ? b._abs[_n - ((1 : GoInt))] : new Word()) << _h) | ((b._abs != null ? b._abs[_n - ((2 : GoInt))] : new Word()) >> (((32 : GoUInt)) - _h));
        } else if (_n == (_m + ((1 : GoInt)))) {
            _a2 = (b._abs != null ? b._abs[_n - ((2 : GoInt))] : new Word()) >> (((32 : GoUInt)) - _h);
        } else {
            _a2 = ((0 : GoUInt));
        };
        _even = false;
        {
            final __tmp__0 = ((0 : GoUInt));
            final __tmp__1 = ((1 : GoUInt));
            final __tmp__2 = ((0 : GoUInt));
            _u0 = __tmp__0;
            _u1 = __tmp__1;
            _u2 = __tmp__2;
        };
        {
            final __tmp__0 = ((0 : GoUInt));
            final __tmp__1 = ((0 : GoUInt));
            final __tmp__2 = ((1 : GoUInt));
            _v0 = __tmp__0;
            _v1 = __tmp__1;
            _v2 = __tmp__2;
        };
        while ((_a2 >= _v2) && ((_a1 - _a2) >= (_v1 + _v2))) {
            var _q:Word = _a1 / _a2, _r:Word = _a1 % _a2;
            {
                final __tmp__0 = _a2;
                final __tmp__1 = _r;
                _a1 = __tmp__0;
                _a2 = __tmp__1;
            };
            {
                final __tmp__0 = _u1;
                final __tmp__1 = _u2;
                final __tmp__2 = _u1 + (_q * _u2);
                _u0 = __tmp__0;
                _u1 = __tmp__1;
                _u2 = __tmp__2;
            };
            {
                final __tmp__0 = _v1;
                final __tmp__1 = _v2;
                final __tmp__2 = _v1 + (_q * _v2);
                _v0 = __tmp__0;
                _v1 = __tmp__1;
                _v2 = __tmp__2;
            };
            _even = !_even;
        };
        return { _0 : _u0, _1 : _u1, _2 : _v0, _3 : _v1, _4 : _even };
    }
function _lehmerUpdate(a:Int_, b:Int_, _q:Int_, _r:Int_, _s:Int_, _t:Int_, _u0:Word, _u1:Word, _v0:Word, _v1:Word, _even:Bool):Void {
        _t._abs = (_t._abs._setWord(_u0) == null ? null : _t._abs._setWord(_u0).__copy__());
        _s._abs = (_s._abs._setWord(_v0) == null ? null : _s._abs._setWord(_v0).__copy__());
        _t._neg = !_even;
        _s._neg = _even;
        _t.mul(a, _t);
        _s.mul(b, _s);
        _r._abs = (_r._abs._setWord(_u1) == null ? null : _r._abs._setWord(_u1).__copy__());
        _q._abs = (_q._abs._setWord(_v1) == null ? null : _q._abs._setWord(_v1).__copy__());
        _r._neg = _even;
        _q._neg = !_even;
        _r.mul(a, _r);
        _q.mul(b, _q);
        a.add(_t, _s);
        b.add(_r, _q);
    }
function _euclidUpdate(a:Int_, b:Int_, ua:Int_, ub:Int_, _q:Int_, _r:Int_, _s:Int_, _t:Int_, _extended:Bool):Void {
        {
            var __tmp__ = _q.quoRem(a, b, _r);
            _q = __tmp__._0;
            _r = __tmp__._1;
        };
        {
            var __tmp__ = (b == null ? null : b.__copy__());
            a._neg = __tmp__._neg;
            a._abs = __tmp__._abs;
        };
        if (_extended) {
            _t.set(ub);
            _s.mul(ub, _q);
            ub.sub(ua, _s);
            ua.set(_t);
        };
    }
function jacobi(_x:Int_, _y:Int_):GoInt {
        if (((_y._abs != null ? _y._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || (((_y._abs != null ? _y._abs[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((0 : GoUInt)))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("big: invalid 2nd argument to Int.Jacobi: need odd integer but got %s" : GoString))), Go.toInterface(_y)));
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_(), _c:Int_ = new Int_();
        _a.set(_x);
        _b.set(_y);
        var _j:GoInt = ((1 : GoInt));
        if (_b._neg) {
            if (_a._neg) {
                _j = ((-1 : GoInt));
            };
            _b._neg = false;
        };
        while (true) {
            if (_b.cmp(_intOne) == ((0 : GoInt))) {
                return _j;
            };
            if ((_a._abs != null ? _a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                return ((0 : GoInt));
            };
            _a.mod(_a, _b);
            if ((_a._abs != null ? _a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                return ((0 : GoInt));
            };
            var _s:GoUInt = _a._abs._trailingZeroBits();
            if ((_s & ((1 : GoUInt))) != ((0 : GoUInt))) {
                var _bmod8:Word = (_b._abs != null ? _b._abs[((0 : GoInt))] : new Word()) & ((7 : GoUInt));
                if ((_bmod8 == ((3 : GoUInt))) || (_bmod8 == ((5 : GoUInt)))) {
                    _j = -_j;
                };
            };
            _c.rsh(_a, _s);
            if ((((_b._abs != null ? _b._abs[((0 : GoInt))] : new Word()) & ((3 : GoUInt))) == ((3 : GoUInt))) && (((_c._abs != null ? _c._abs[((0 : GoInt))] : new Word()) & ((3 : GoUInt))) == ((3 : GoUInt)))) {
                _j = -_j;
            };
            _a.set(_b);
            _b.set(_c);
        };
    }
function _isNormalized(_x:Int_):Bool {
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return !_x._neg;
        };
        return (_x._abs != null ? _x._abs[(_x._abs != null ? _x._abs.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) != ((0 : GoUInt));
    }
function testSignZ(_t:stdgo.testing.Testing.T_):Void {
        var _zero:Int_ = new Int_();
        for (_0 => _a in _sumZZ) {
            var _s:GoInt = _a._z.sign();
            var _e:GoInt = _a._z.cmp(_zero);
            if (_s != _e) {
                _t.errorf(((("got %d; want %d for z = %v" : GoString))), Go.toInterface(_s), Go.toInterface(_e), Go.toInterface(_a._z));
            };
        };
    }
function testSetZ(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _sumZZ) {
            var _z:Int_ = new Int_();
            _z.set(_a._z);
            if (!_isNormalized(_z)) {
                _t.errorf(((("%v is not normalized" : GoString))), Go.toInterface(_z));
            };
            if ((_z).cmp(_a._z) != ((0 : GoInt))) {
                _t.errorf(((("got z = %v; want %v" : GoString))), Go.toInterface(_z), Go.toInterface(_a._z));
            };
        };
    }
function testAbsZ(_t:stdgo.testing.Testing.T_):Void {
        var _zero:Int_ = new Int_();
        for (_0 => _a in _sumZZ) {
            var _z:Int_ = new Int_();
            _z.abs(_a._z);
            var _e:Int_ = new Int_();
            _e.set(_a._z);
            if (_e.cmp(_zero) < ((0 : GoInt))) {
                _e.sub(_zero, _e);
            };
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(((("got z = %v; want %v" : GoString))), Go.toInterface(_z), Go.toInterface(_e));
            };
        };
    }
function _testFunZZ(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funZZ, _a:T_argZZ):Void {
        var _z:Int_ = new Int_();
        _f(_z, _a._x, _a._y);
        if (!_isNormalized(_z)) {
            _t.errorf(((("%s%v is not normalized" : GoString))), Go.toInterface(_msg), Go.toInterface(_z));
        };
        if ((_z).cmp(_a._z) != ((0 : GoInt))) {
            _t.errorf(((("%s%+v\n\tgot z = %v; want %v" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_z), Go.toInterface(_a._z));
        };
    }
function testSumZZ(_t:stdgo.testing.Testing.T_):Void {
        var addZZ:(Ref<Int_>, Ref<Int_>, Ref<Int_>) -> Ref<Int_> = function(_z:Int_, _x:Int_, _y:Int_):Int_ {
            return _z.add(_x, _y);
        };
        var subZZ:(Ref<Int_>, Ref<Int_>, Ref<Int_>) -> Ref<Int_> = function(_z:Int_, _x:Int_, _y:Int_):Int_ {
            return _z.sub(_x, _y);
        };
        for (_0 => _a in _sumZZ) {
            var _arg:T_argZZ = (_a == null ? null : _a.__copy__());
            _testFunZZ(_t, ((("AddZZ" : GoString))), addZZ, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argZZ(_a._z, _a._y, _a._x) : T_argZZ));
            _testFunZZ(_t, ((("AddZZ symmetric" : GoString))), addZZ, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argZZ(_a._x, _a._z, _a._y) : T_argZZ));
            _testFunZZ(_t, ((("SubZZ" : GoString))), subZZ, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argZZ(_a._y, _a._z, _a._x) : T_argZZ));
            _testFunZZ(_t, ((("SubZZ symmetric" : GoString))), subZZ, (_arg == null ? null : _arg.__copy__()));
        };
    }
function testProdZZ(_t:stdgo.testing.Testing.T_):Void {
        var mulZZ:(Ref<Int_>, Ref<Int_>, Ref<Int_>) -> Ref<Int_> = function(_z:Int_, _x:Int_, _y:Int_):Int_ {
            return _z.mul(_x, _y);
        };
        for (_0 => _a in _prodZZ) {
            var _arg:T_argZZ = (_a == null ? null : _a.__copy__());
            _testFunZZ(_t, ((("MulZZ" : GoString))), mulZZ, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argZZ(_a._z, _a._y, _a._x) : T_argZZ));
            _testFunZZ(_t, ((("MulZZ symmetric" : GoString))), mulZZ, (_arg == null ? null : _arg.__copy__()));
        };
    }
function _mulBytes(_x:Slice<GoByte>, _y:Slice<GoByte>):Slice<GoByte> {
        var _z:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... (((_x != null ? _x.length : ((0 : GoInt))) + (_y != null ? _y.length : ((0 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _k0:GoInt = (_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt));
        {
            var _j:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_j >= ((0 : GoInt)), _j--, {
                var _d:GoInt = (((_y != null ? _y[_j] : ((0 : GoUInt8))) : GoInt));
                if (_d != ((0 : GoInt))) {
                    var _k:GoInt = _k0;
                    var _carry:GoInt = ((0 : GoInt));
                    {
                        var _i:GoInt = (_x != null ? _x.length : ((0 : GoInt))) - ((1 : GoInt));
                        Go.cfor(_i >= ((0 : GoInt)), _i--, {
                            var _t:GoInt = ((((_z != null ? _z[_k] : ((0 : GoUInt8))) : GoInt)) + ((((_x != null ? _x[_i] : ((0 : GoUInt8))) : GoInt)) * _d)) + _carry;
                            {
                                final __tmp__0 = ((_t : GoByte));
                                final __tmp__1 = _t >> ((8 : GoUnTypedInt));
                                if (_z != null) _z[_k] = __tmp__0;
                                _carry = __tmp__1;
                            };
                            _k--;
                        });
                    };
                    if (_z != null) _z[_k] = ((_carry : GoByte));
                };
                _k0--;
            });
        };
        var _i:GoInt = ((0 : GoInt));
        while ((_i < (_z != null ? _z.length : ((0 : GoInt)))) && ((_z != null ? _z[_i] : ((0 : GoUInt8))) == ((0 : GoUInt8)))) {
            _i++;
        };
        return ((_z.__slice__(_i) : Slice<GoUInt8>));
    }
function _checkMul(_a:Slice<GoByte>, _b:Slice<GoByte>):Bool {
        var _x:Int_ = new Int_(), _y:Int_ = new Int_(), _z1:Int_ = new Int_();
        _x.setBytes(_a);
        _y.setBytes(_b);
        _z1.mul(_x, _y);
        var _z2:Int_ = new Int_();
        _z2.setBytes(_mulBytes(_a, _b));
        return _z1.cmp(_z2) == ((0 : GoInt));
    }
function testMul(_t:stdgo.testing.Testing.T_):Void {
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkMul), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
function testMulRangeZ(_t:stdgo.testing.Testing.T_):Void {
        var _tmp:Int_ = new Int_();
        for (_i => _r in _mulRangesN) {
            var _prod:GoString = ((_tmp.mulRange(((_r._a : GoInt64)), ((_r._b : GoInt64))).toString() : GoString));
            if (_prod != _r._prod) {
                _t.errorf(((("#%da: got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_prod), Go.toInterface(_r._prod));
            };
        };
        for (_i => _r in _mulRangesZ) {
            var _prod:GoString = ((_tmp.mulRange(_r._a, _r._b).toString() : GoString));
            if (_prod != _r._prod) {
                _t.errorf(((("#%db: got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_prod), Go.toInterface(_r._prod));
            };
        };
    }
function testBinomial(_t:stdgo.testing.Testing.T_):Void {
        var _z:Int_ = new Int_();
        for (_0 => _test in ((new Slice<T__struct_33>(
((new T__struct_33(((0 : GoInt64)), ((0 : GoInt64)), ((("1" : GoString)))) : T__struct_33)),
((new T__struct_33(((0 : GoInt64)), ((1 : GoInt64)), ((("0" : GoString)))) : T__struct_33)),
((new T__struct_33(((1 : GoInt64)), ((0 : GoInt64)), ((("1" : GoString)))) : T__struct_33)),
((new T__struct_33(((1 : GoInt64)), ((1 : GoInt64)), ((("1" : GoString)))) : T__struct_33)),
((new T__struct_33(((1 : GoInt64)), ((10 : GoInt64)), ((("0" : GoString)))) : T__struct_33)),
((new T__struct_33(((4 : GoInt64)), ((0 : GoInt64)), ((("1" : GoString)))) : T__struct_33)),
((new T__struct_33(((4 : GoInt64)), ((1 : GoInt64)), ((("4" : GoString)))) : T__struct_33)),
((new T__struct_33(((4 : GoInt64)), ((2 : GoInt64)), ((("6" : GoString)))) : T__struct_33)),
((new T__struct_33(((4 : GoInt64)), ((3 : GoInt64)), ((("4" : GoString)))) : T__struct_33)),
((new T__struct_33(((4 : GoInt64)), ((4 : GoInt64)), ((("1" : GoString)))) : T__struct_33)),
((new T__struct_33(((10 : GoInt64)), ((1 : GoInt64)), ((("10" : GoString)))) : T__struct_33)),
((new T__struct_33(((10 : GoInt64)), ((9 : GoInt64)), ((("10" : GoString)))) : T__struct_33)),
((new T__struct_33(((10 : GoInt64)), ((5 : GoInt64)), ((("252" : GoString)))) : T__struct_33)),
((new T__struct_33(((11 : GoInt64)), ((5 : GoInt64)), ((("462" : GoString)))) : T__struct_33)),
((new T__struct_33(((11 : GoInt64)), ((6 : GoInt64)), ((("462" : GoString)))) : T__struct_33)),
((new T__struct_33(((100 : GoInt64)), ((10 : GoInt64)), ((("17310309456440" : GoString)))) : T__struct_33)),
((new T__struct_33(((100 : GoInt64)), ((90 : GoInt64)), ((("17310309456440" : GoString)))) : T__struct_33)),
((new T__struct_33(((1000 : GoInt64)), ((10 : GoInt64)), ((("263409560461970212832400" : GoString)))) : T__struct_33)),
((new T__struct_33(((1000 : GoInt64)), ((990 : GoInt64)), ((("263409560461970212832400" : GoString)))) : T__struct_33))) : Slice<T__struct_33>))) {
            {
                var _got:GoString = ((_z.binomial(_test._n, _test._k).toString() : GoString));
                if (_got != _test._want) {
                    _t.errorf(((("Binomial(%d, %d) = %s; want %s" : GoString))), Go.toInterface(_test._n), Go.toInterface(_test._k), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function benchmarkBinomial(_b:stdgo.testing.Testing.B):Void {
        var _z:Int_ = new Int_();
        {
            var _i:GoInt = _b.n - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _z.binomial(((1000 : GoInt64)), ((990 : GoInt64)));
            });
        };
    }
function testDivisionSigns(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _divisionSignsTests) {
            var _x:Ref<Int_> = newInt(_test._x);
            var _y:Ref<Int_> = newInt(_test._y);
            var _q:Ref<Int_> = newInt(_test._q);
            var _r:Ref<Int_> = newInt(_test._r);
            var _d:Ref<Int_> = newInt(_test._d);
            var _m:Ref<Int_> = newInt(_test._m);
            var _q1:Ref<Int_> = new Int_().quo(_x, _y);
            var _r1:Ref<Int_> = new Int_().rem(_x, _y);
            if (!_isNormalized(_q1)) {
                _t.errorf(((("#%d Quo: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_q1));
            };
            if (!_isNormalized(_r1)) {
                _t.errorf(((("#%d Rem: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_r1));
            };
            if ((_q1.cmp(_q) != ((0 : GoInt))) || (_r1.cmp(_r) != ((0 : GoInt)))) {
                _t.errorf(((("#%d QuoRem: got (%s, %s), want (%s, %s)" : GoString))), Go.toInterface(_i), Go.toInterface(_q1), Go.toInterface(_r1), Go.toInterface(_q), Go.toInterface(_r));
            };
            var __tmp__ = new Int_().quoRem(_x, _y, new Int_()), _q2:Ref<Int_> = __tmp__._0, _r2:Ref<Int_> = __tmp__._1;
            if (!_isNormalized(_q2)) {
                _t.errorf(((("#%d Quo: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_q2));
            };
            if (!_isNormalized(_r2)) {
                _t.errorf(((("#%d Rem: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_r2));
            };
            if ((_q2.cmp(_q) != ((0 : GoInt))) || (_r2.cmp(_r) != ((0 : GoInt)))) {
                _t.errorf(((("#%d QuoRem: got (%s, %s), want (%s, %s)" : GoString))), Go.toInterface(_i), Go.toInterface(_q2), Go.toInterface(_r2), Go.toInterface(_q), Go.toInterface(_r));
            };
            var _d1:Ref<Int_> = new Int_().div(_x, _y);
            var _m1:Ref<Int_> = new Int_().mod(_x, _y);
            if (!_isNormalized(_d1)) {
                _t.errorf(((("#%d Div: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_d1));
            };
            if (!_isNormalized(_m1)) {
                _t.errorf(((("#%d Mod: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_m1));
            };
            if ((_d1.cmp(_d) != ((0 : GoInt))) || (_m1.cmp(_m) != ((0 : GoInt)))) {
                _t.errorf(((("#%d DivMod: got (%s, %s), want (%s, %s)" : GoString))), Go.toInterface(_i), Go.toInterface(_d1), Go.toInterface(_m1), Go.toInterface(_d), Go.toInterface(_m));
            };
            var __tmp__ = new Int_().divMod(_x, _y, new Int_()), _d2:Ref<Int_> = __tmp__._0, _m2:Ref<Int_> = __tmp__._1;
            if (!_isNormalized(_d2)) {
                _t.errorf(((("#%d Div: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_d2));
            };
            if (!_isNormalized(_m2)) {
                _t.errorf(((("#%d Mod: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_m2));
            };
            if ((_d2.cmp(_d) != ((0 : GoInt))) || (_m2.cmp(_m) != ((0 : GoInt)))) {
                _t.errorf(((("#%d DivMod: got (%s, %s), want (%s, %s)" : GoString))), Go.toInterface(_i), Go.toInterface(_d2), Go.toInterface(_m2), Go.toInterface(_d), Go.toInterface(_m));
            };
        };
    }
function _norm(_x:T_nat):T_nat {
        var _i:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) && ((_x != null ? _x[_i - ((1 : GoInt))] : new Word()) == ((0 : GoUInt)))) {
            _i--;
        };
        return (((_x.__slice__(0, _i) : T_nat)) == null ? null : ((_x.__slice__(0, _i) : T_nat)).__copy__());
    }
function testBits(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T_nat>(null, ((new Slice<Word>(((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((1 : GoUInt))) : T_nat)), ((new Slice<Word>(((0 : GoUInt)), ((1 : GoUInt)), ((2 : GoUInt)), ((3 : GoUInt)), ((4 : GoUInt))) : T_nat)), ((new Slice<Word>(((4 : GoUInt)), ((3 : GoUInt)), ((2 : GoUInt)), ((1 : GoUInt)), ((0 : GoUInt))) : T_nat)), ((new Slice<Word>(((4 : GoUInt)), ((3 : GoUInt)), ((2 : GoUInt)), ((1 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt)), ((0 : GoUInt))) : T_nat))) : Slice<T_nat>))) {
            var _z:Int_ = new Int_();
            _z._neg = true;
            var _got:Ref<Int_> = _z.setBits(_test);
            var _want:T_nat = (_norm((_test == null ? null : _test.__copy__())) == null ? null : _norm((_test == null ? null : _test.__copy__())).__copy__());
            if (_got._abs._cmp((_want == null ? null : _want.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("SetBits(%v) = %v; want %v" : GoString))), Go.toInterface(_test), Go.toInterface(_got._abs), Go.toInterface(_want));
            };
            if (_got._neg) {
                _t.errorf(((("SetBits(%v): got negative result" : GoString))), Go.toInterface(_test));
            };
            var _bits:T_nat = (((_z.bits() : T_nat)) == null ? null : ((_z.bits() : T_nat)).__copy__());
            if (_bits._cmp((_want == null ? null : _want.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("%v.Bits() = %v; want %v" : GoString))), Go.toInterface(_z._abs), Go.toInterface(_bits), Go.toInterface(_want));
            };
        };
    }
function _checkSetBytes(_b:Slice<GoByte>):Bool {
        var _hex1:GoString = stdgo.encoding.hex.Hex.encodeToString(new Int_().setBytes(_b).bytes());
        var _hex2:GoString = stdgo.encoding.hex.Hex.encodeToString(_b);
        while ((_hex1 != null ? _hex1.length : ((0 : GoInt))) < (_hex2 != null ? _hex2.length : ((0 : GoInt)))) {
            _hex1 = ((("0" : GoString))) + _hex1;
        };
        while ((_hex1 != null ? _hex1.length : ((0 : GoInt))) > (_hex2 != null ? _hex2.length : ((0 : GoInt)))) {
            _hex2 = ((("0" : GoString))) + _hex2;
        };
        return _hex1 == _hex2;
    }
function testSetBytes(_t:stdgo.testing.Testing.T_):Void {
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkSetBytes), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
function _checkBytes(_b:Slice<GoByte>):Bool {
        while (((_b != null ? _b.length : ((0 : GoInt))) > ((0 : GoInt))) && ((_b != null ? _b[((0 : GoInt))] : ((0 : GoUInt8))) == ((0 : GoUInt8)))) {
            _b = ((_b.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        };
        var _b2:Slice<GoUInt8> = new Int_().setBytes(_b).bytes();
        return stdgo.bytes.Bytes.equal(_b, _b2);
    }
function testBytes(_t:stdgo.testing.Testing.T_):Void {
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkBytes), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
function _checkQuo(_x:Slice<GoByte>, _y:Slice<GoByte>):Bool {
        var _u:Ref<Int_> = new Int_().setBytes(_x);
        var _v:Ref<Int_> = new Int_().setBytes(_y);
        if ((_v._abs != null ? _v._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return true;
        };
        var _r:Ref<Int_> = new Int_();
        var __tmp__ = new Int_().quoRem(_u, _v, _r), _q:Ref<Int_> = __tmp__._0, _r:Ref<Int_> = __tmp__._1;
        if (_r.cmp(_v) >= ((0 : GoInt))) {
            return false;
        };
        var _uprime:Ref<Int_> = new Int_().set(_q);
        _uprime.mul(_uprime, _v);
        _uprime.add(_uprime, _r);
        return _uprime.cmp(_u) == ((0 : GoInt));
    }
function testQuo(_t:stdgo.testing.Testing.T_):Void {
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkQuo), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
        for (_i => _test in _quoTests) {
            var __tmp__ = new Int_().setString(_test._x, ((10 : GoInt))), _x:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._y, ((10 : GoInt))), _y:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._q, ((10 : GoInt))), _expectedQ:Ref<Int_> = __tmp__._0, _2:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._r, ((10 : GoInt))), _expectedR:Ref<Int_> = __tmp__._0, _3:Bool = __tmp__._1;
            var _r:Ref<Int_> = new Int_();
            var __tmp__ = new Int_().quoRem(_x, _y, _r), _q:Ref<Int_> = __tmp__._0, _r:Ref<Int_> = __tmp__._1;
            if ((_q.cmp(_expectedQ) != ((0 : GoInt))) || (_r.cmp(_expectedR) != ((0 : GoInt)))) {
                _t.errorf(((("#%d got (%s, %s) want (%s, %s)" : GoString))), Go.toInterface(_i), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(_expectedQ), Go.toInterface(_expectedR));
            };
        };
    }
function testQuoStepD6(_t:stdgo.testing.Testing.T_):Void {
        var _u:Ref<Int_> = ((new Int_(false, ((new Slice<Word>(((0 : GoUInt)), ((0 : GoUInt)), (("2147483649" : GoUInt)), ((2147483647 : GoUInt))) : T_nat))) : Int_));
        var _v:Ref<Int_> = ((new Int_(false, ((new Slice<Word>(((5 : GoUInt)), (("2147483650" : GoUInt)), (("2147483648" : GoUInt))) : T_nat))) : Int_));
        var _r:Ref<Int_> = new Int_();
        var __tmp__ = new Int_().quoRem(_u, _v, _r), _q:Ref<Int_> = __tmp__._0, _r:Ref<Int_> = __tmp__._1;
        {};
        {};
        {};
        {};
        if (((((_q.toString() : GoString)) != ((("18446744073709551613" : GoString)))) && (((_q.toString() : GoString)) != ((("4294967293" : GoString))))) || ((((_r.toString() : GoString)) != ((("3138550867693340382088035895064302439801311770021610913807" : GoString)))) && (((_r.toString() : GoString)) != ((("39614081266355540837921718287" : GoString)))))) {
            _t.errorf(((("got (%s, %s) want (%s, %s) or (%s, %s)" : GoString))), Go.toInterface(_q), Go.toInterface(_r), Go.toInterface(((("18446744073709551613" : GoString)))), Go.toInterface(((("3138550867693340382088035895064302439801311770021610913807" : GoString)))), Go.toInterface(((("4294967293" : GoString)))), Go.toInterface(((("39614081266355540837921718287" : GoString)))));
        };
    }
function benchmarkQuoRem(_b:stdgo.testing.Testing.B):Void {
        var __tmp__ = new Int_().setString(((("153980389784927331788354528594524332344709972855165340650588877572729725338415474372475094155672066328274535240275856844648695200875763869073572078279316458648124537905600131008790701752441155668003033945258023841165089852359980273279085783159654751552359397986180318708491098942831252291841441726305535546071" : GoString))), ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("7746362281539803897849273317883545285945243323447099728551653406505888775727297253384154743724750941556720663282745352402758568446486952008757638690735720782793164586481245379056001310087907017524411556680030339452580238411650898523599802732790857831596547515523593979861803187084910989428312522918414417263055355460715745539358014631136245887418412633787074173796862711588221766398229333338511838891484974940633857861775630560092874987828057333663969469797013996401149696897591265769095952887917296740109742927689053276850469671231961384715398038978492733178835452859452433234470997285516534065058887757272972533841547437247509415567206632827453524027585684464869520087576386907357207827931645864812453790560013100879070175244115566800303394525802384116508985235998027327908578315965475155235939798618031870849109894283125229184144172630553554607112725169432413343763989564437170644270643461665184965150423819594083121075825" : GoString))), ((0 : GoInt))), _y:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
        var _q:Ref<Int_> = new Int_();
        var _r:Ref<Int_> = new Int_();
        _b.resetTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _q.quoRem(_y, _x, _r);
            });
        };
    }
function testBitLen(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _bitLenTests) {
            var __tmp__ = new Int_().setString(_test._in, ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("#%d test input invalid: %s" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in));
                continue;
            };
            {
                var _n:GoInt = _x.bitLen();
                if (_n != _test._out) {
                    _t.errorf(((("#%d got %d want %d" : GoString))), Go.toInterface(_i), Go.toInterface(_n), Go.toInterface(_test._out));
                };
            };
        };
    }
function testExp(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _expTests) {
            var __tmp__ = new Int_().setString(_test._x, ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _ok1:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._y, ((0 : GoInt))), _y:Ref<Int_> = __tmp__._0, _ok2:Bool = __tmp__._1;
            var _ok3:Bool = false, _ok4:Bool = false;
            var _out:Int_ = ((null : Ref<Int_>)), _m:Int_ = ((null : Ref<Int_>));
            if ((_test._out != null ? _test._out.length : ((0 : GoInt))) == ((0 : GoInt))) {
                {
                    final __tmp__0 = null;
                    final __tmp__1 = true;
                    _out = __tmp__0;
                    _ok3 = __tmp__1;
                };
            } else {
                {
                    var __tmp__ = new Int_().setString(_test._out, ((0 : GoInt)));
                    _out = __tmp__._0;
                    _ok3 = __tmp__._1;
                };
            };
            if ((_test._m != null ? _test._m.length : ((0 : GoInt))) == ((0 : GoInt))) {
                {
                    final __tmp__0 = null;
                    final __tmp__1 = true;
                    _m = __tmp__0;
                    _ok4 = __tmp__1;
                };
            } else {
                {
                    var __tmp__ = new Int_().setString(_test._m, ((0 : GoInt)));
                    _m = __tmp__._0;
                    _ok4 = __tmp__._1;
                };
            };
            if (((!_ok1 || !_ok2) || !_ok3) || !_ok4) {
                _t.errorf(((("#%d: error in input" : GoString))), Go.toInterface(_i));
                continue;
            };
            var _z1:Ref<Int_> = new Int_().exp(_x, _y, _m);
            if ((_z1 != null) && !_isNormalized(_z1)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_z1));
            };
            if (!(((_z1 == null) && (_out == null)) || (_z1.cmp(_out) == ((0 : GoInt))))) {
                _t.errorf(((("#%d: got %x want %x" : GoString))), Go.toInterface(_i), Go.toInterface(_z1), Go.toInterface(_out));
            };
            if (_m == null) {
                _m = (({ _abs : ((new Slice<Word>() : T_nat)), _neg : false } : Int_));
                var _z2:Ref<Int_> = new Int_().exp(_x, _y, _m);
                if (_z2.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(((("#%d: got %x want %x" : GoString))), Go.toInterface(_i), Go.toInterface(_z2), Go.toInterface(_z1));
                };
            };
        };
    }
function benchmarkExp(_b:stdgo.testing.Testing.B):Void {
        var __tmp__ = new Int_().setString(((("11001289118363089646017359372117963499250546375269047542777928006103246876688756735760905680604646624353196869572752623285140408755420374049317646428185270079555372763503115646054602867593662923894140940837479507194934267532831694565516466765025434902348314525627418515646588160955862839022051353653052947073136084780742729727874803457643848197499548297570026926927502505634297079527299004267769780768565695459945235586892627059178884998772989397505061206395455591503771677500931269477503508150175717121828518985901959919560700853226255420793148986854391552859459511723547532575574664944815966793196961286234040892865" : GoString))), ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF72" : GoString))), ((0 : GoInt))), _y:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString))), ((0 : GoInt))), _n:Ref<Int_> = __tmp__._0, _2:Bool = __tmp__._1;
        var _out:Ref<Int_> = new Int_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _out.exp(_x, _y, _n);
            });
        };
    }
function benchmarkExp2(_b:stdgo.testing.Testing.B):Void {
        var __tmp__ = new Int_().setString(((("2" : GoString))), ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF72" : GoString))), ((0 : GoInt))), _y:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("0xAC6BDB41324A9A9BF166DE5E1389582FAF72B6651987EE07FC3192943DB56050A37329CBB4A099ED8193E0757767A13DD52312AB4B03310DCD7F48A9DA04FD50E8083969EDB767B0CF6095179A163AB3661A05FBD5FAAAE82918A9962F0B93B855F97993EC975EEAA80D740ADBF4FF747359D041D5C33EA71D281E446B14773BCA97B43A23FB801676BD207A436C6481F1D2B9078717461A5B9D32E688F87748544523B524B0D57D5EA77A2775D2ECFA032CFBDBF52FB3786160279004E57AE6AF874E7303CE53299CCC041C7BC308D82A5698F3A8D0C38271AE35F8E9DBFBB694B5C803D89F7AE435DE236D525F54759B65E372FCD68EF20FA7111F9E4AFF73" : GoString))), ((0 : GoInt))), _n:Ref<Int_> = __tmp__._0, _2:Bool = __tmp__._1;
        var _out:Ref<Int_> = new Int_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _out.exp(_x, _y, _n);
            });
        };
    }
function _checkGcd(_aBytes:Slice<GoByte>, _bBytes:Slice<GoByte>):Bool {
        var _x:Ref<Int_> = new Int_();
        var _y:Ref<Int_> = new Int_();
        var _a:Ref<Int_> = new Int_().setBytes(_aBytes);
        var _b:Ref<Int_> = new Int_().setBytes(_bBytes);
        var _d:Ref<Int_> = new Int_().gcd(_x, _y, _a, _b);
        _x.mul(_x, _a);
        _y.mul(_y, _b);
        _x.add(_x, _y);
        return _x.cmp(_d) == ((0 : GoInt));
    }
function _euclidExtGCD(_a:Int_, _b:Int_):{ var _0 : Int_; var _1 : Int_; var _2 : Int_; } {
        var _g:Int_ = ((null : Ref<Int_>)), _x:Int_ = ((null : Ref<Int_>)), _y:Int_ = ((null : Ref<Int_>));
        var a:Ref<Int_> = new Int_().set(_a);
        var b:Ref<Int_> = new Int_().set(_b);
        var ua:Ref<Int_> = new Int_().setInt64(((1 : GoInt64)));
        var va:Ref<Int_> = new Int_();
        var ub:Ref<Int_> = new Int_();
        var vb:Ref<Int_> = new Int_().setInt64(((1 : GoInt64)));
        var _q:Ref<Int_> = new Int_();
        var _temp:Ref<Int_> = new Int_();
        var _r:Ref<Int_> = new Int_();
        while ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
            {
                var __tmp__ = _q.quoRem(a, b, _r);
                _q = __tmp__._0;
                _r = __tmp__._1;
            };
            {
                final __tmp__0 = b;
                final __tmp__1 = _r;
                final __tmp__2 = a;
                a = __tmp__0;
                b = __tmp__1;
                _r = __tmp__2;
            };
            _temp.set(ub);
            ub.mul(ub, _q);
            ub.sub(ua, ub);
            ua.set(_temp);
            _temp.set(vb);
            vb.mul(vb, _q);
            vb.sub(va, vb);
            va.set(_temp);
        };
        return { _0 : a, _1 : ua, _2 : va };
    }
function _checkLehmerGcd(_aBytes:Slice<GoByte>, _bBytes:Slice<GoByte>):Bool {
        var _a:Ref<Int_> = new Int_().setBytes(_aBytes);
        var _b:Ref<Int_> = new Int_().setBytes(_bBytes);
        if ((_a.sign() <= ((0 : GoInt))) || (_b.sign() <= ((0 : GoInt)))) {
            return true;
        };
        var _d:Ref<Int_> = new Int_()._lehmerGCD(null, null, _a, _b);
        var __tmp__ = _euclidExtGCD(_a, _b), _d0:Ref<Int_> = __tmp__._0, _0:Ref<Int_> = __tmp__._1, _1:Ref<Int_> = __tmp__._2;
        return _d.cmp(_d0) == ((0 : GoInt));
    }
function _checkLehmerExtGcd(_aBytes:Slice<GoByte>, _bBytes:Slice<GoByte>):Bool {
        var _a:Ref<Int_> = new Int_().setBytes(_aBytes);
        var _b:Ref<Int_> = new Int_().setBytes(_bBytes);
        var _x:Ref<Int_> = new Int_();
        var _y:Ref<Int_> = new Int_();
        if ((_a.sign() <= ((0 : GoInt))) || (_b.sign() <= ((0 : GoInt)))) {
            return true;
        };
        var _d:Ref<Int_> = new Int_()._lehmerGCD(_x, _y, _a, _b);
        var __tmp__ = _euclidExtGCD(_a, _b), _d0:Ref<Int_> = __tmp__._0, _x0:Ref<Int_> = __tmp__._1, _y0:Ref<Int_> = __tmp__._2;
        return ((_d.cmp(_d0) == ((0 : GoInt))) && (_x.cmp(_x0) == ((0 : GoInt)))) && (_y.cmp(_y0) == ((0 : GoInt)));
    }
function _testGcd(_t:stdgo.testing.Testing.T_, _d:Int_, _x:Int_, _y:Int_, _a:Int_, _b:Int_):Void {
        var x:Int_ = ((null : Ref<Int_>));
        if (_x != null) {
            x = new Int_();
        };
        var y:Int_ = ((null : Ref<Int_>));
        if (_y != null) {
            y = new Int_();
        };
        var d:Ref<Int_> = new Int_().gcd(x, y, _a, _b);
        if (d.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(((("GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(d), Go.toInterface(_d));
        };
        if ((_x != null) && (x.cmp(_x) != ((0 : GoInt)))) {
            _t.errorf(((("GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(x), Go.toInterface(_x));
        };
        if ((_y != null) && (y.cmp(_y) != ((0 : GoInt)))) {
            _t.errorf(((("GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(y), Go.toInterface(_y));
        };
        var _a2:Ref<Int_> = new Int_().set(_a);
        var _b2:Ref<Int_> = new Int_().set(_b);
        _a2.gcd(x, y, _a2, _b2);
        if (_a2.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(((("aliased z = a GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_a2), Go.toInterface(_d));
        };
        if ((_x != null) && (x.cmp(_x) != ((0 : GoInt)))) {
            _t.errorf(((("aliased z = a GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(x), Go.toInterface(_x));
        };
        if ((_y != null) && (y.cmp(_y) != ((0 : GoInt)))) {
            _t.errorf(((("aliased z = a GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(y), Go.toInterface(_y));
        };
        _a2 = new Int_().set(_a);
        _b2 = new Int_().set(_b);
        _b2.gcd(x, y, _a2, _b2);
        if (_b2.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(((("aliased z = b GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_b2), Go.toInterface(_d));
        };
        if ((_x != null) && (x.cmp(_x) != ((0 : GoInt)))) {
            _t.errorf(((("aliased z = b GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(x), Go.toInterface(_x));
        };
        if ((_y != null) && (y.cmp(_y) != ((0 : GoInt)))) {
            _t.errorf(((("aliased z = b GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(y), Go.toInterface(_y));
        };
        _a2 = new Int_().set(_a);
        _b2 = new Int_().set(_b);
        d = new Int_().gcd(_a2, _b2, _a2, _b2);
        if (d.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(((("aliased x = a, y = b GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(d), Go.toInterface(_d));
        };
        if ((_x != null) && (_a2.cmp(_x) != ((0 : GoInt)))) {
            _t.errorf(((("aliased x = a, y = b GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_a2), Go.toInterface(_x));
        };
        if ((_y != null) && (_b2.cmp(_y) != ((0 : GoInt)))) {
            _t.errorf(((("aliased x = a, y = b GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_b2), Go.toInterface(_y));
        };
        _a2 = new Int_().set(_a);
        _b2 = new Int_().set(_b);
        d = new Int_().gcd(_b2, _a2, _a2, _b2);
        if (d.cmp(_d) != ((0 : GoInt))) {
            _t.errorf(((("aliased x = b, y = a GCD(%s, %s, %s, %s): got d = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(d), Go.toInterface(_d));
        };
        if ((_x != null) && (_b2.cmp(_x) != ((0 : GoInt)))) {
            _t.errorf(((("aliased x = b, y = a GCD(%s, %s, %s, %s): got x = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_b2), Go.toInterface(_x));
        };
        if ((_y != null) && (_a2.cmp(_y) != ((0 : GoInt)))) {
            _t.errorf(((("aliased x = b, y = a GCD(%s, %s, %s, %s): got y = %s, want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_y), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_a2), Go.toInterface(_y));
        };
    }
function testGcd(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in _gcdTests) {
            var __tmp__ = new Int_().setString(_test._d, ((0 : GoInt))), _d:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._x, ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _2:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._y, ((0 : GoInt))), _y:Ref<Int_> = __tmp__._0, _3:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._a, ((0 : GoInt))), _a:Ref<Int_> = __tmp__._0, _4:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._b, ((0 : GoInt))), _b:Ref<Int_> = __tmp__._0, _5:Bool = __tmp__._1;
            _testGcd(_t, _d, null, null, _a, _b);
            _testGcd(_t, _d, _x, null, _a, _b);
            _testGcd(_t, _d, null, _y, _a, _b);
            _testGcd(_t, _d, _x, _y, _a, _b);
        };
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkGcd), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkLehmerGcd), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
        {
            var _err:stdgo.Error = stdgo.testing.quick.Quick.check(Go.toInterface(_checkLehmerExtGcd), null);
            if (_err != null) {
                _t.error(Go.toInterface(_err));
            };
        };
    }
function testRsh(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _rshTests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _in:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._out, ((10 : GoInt))), _expected:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            var _out:Ref<Int_> = new Int_().rsh(_in, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_out));
            };
            if (_out.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_expected));
            };
        };
    }
function testRshSelf(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _rshTests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _z:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._out, ((10 : GoInt))), _expected:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            _z.rsh(_z, _test._shift);
            if (!_isNormalized(_z)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_z));
            };
            if (_z.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_z), Go.toInterface(_expected));
            };
        };
    }
function testLsh(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _lshTests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _in:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._out, ((10 : GoInt))), _expected:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            var _out:Ref<Int_> = new Int_().lsh(_in, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_out));
            };
            if (_out.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_expected));
            };
        };
    }
function testLshSelf(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _lshTests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _z:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._out, ((10 : GoInt))), _expected:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            _z.lsh(_z, _test._shift);
            if (!_isNormalized(_z)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_z));
            };
            if (_z.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_z), Go.toInterface(_expected));
            };
        };
    }
function testLshRsh(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _rshTests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _in:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var _out:Ref<Int_> = new Int_().lsh(_in, _test._shift);
            _out = _out.rsh(_out, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_out));
            };
            if (_in.cmp(_out) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_in));
            };
        };
        for (_i => _test in _lshTests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _in:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            var _out:Ref<Int_> = new Int_().lsh(_in, _test._shift);
            _out.rsh(_out, _test._shift);
            if (!_isNormalized(_out)) {
                _t.errorf(((("#%d: %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_out));
            };
            if (_in.cmp(_out) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_in));
            };
        };
    }
function testCmpAbs(_t:stdgo.testing.Testing.T_):Void {
        var _values:Slice<Ref<Int_>> = new Slice<Ref<Int_>>(...[for (i in 0 ... (((_cmpAbsTests != null ? _cmpAbsTests.length : ((0 : GoInt))) : GoInt)).toBasic()) ((null : Ref<Int_>))]);
        var _prev:Int_ = ((null : Ref<Int_>));
        for (_i => _s in _cmpAbsTests) {
            var __tmp__ = new Int_().setString(_s, ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.fatalf(((("SetString(%s, 0) failed" : GoString))), Go.toInterface(_s));
            };
            if ((_prev != null) && (_prev.cmp(_x) >= ((0 : GoInt)))) {
                _t.fatal(Go.toInterface(((("cmpAbsTests entries not sorted in ascending order" : GoString)))));
            };
            if (_values != null) _values[_i] = _x;
            _prev = _x;
        };
        for (_i => _x in _values) {
            for (_j => _y in _values) {
                {
                    var _k:GoInt = ((0 : GoInt));
                    Go.cfor(_k < ((4 : GoInt)), _k++, {
                        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
                        _a.set(_x);
                        _b.set(_y);
                        if ((_k & ((1 : GoInt))) != ((0 : GoInt))) {
                            _a.neg(_a);
                        };
                        if ((_k & ((2 : GoInt))) != ((0 : GoInt))) {
                            _b.neg(_b);
                        };
                        var _got:GoInt = _a.cmpAbs(_b);
                        var _want:GoInt = ((0 : GoInt));
                        if (_i > _j) {
                            _want = ((1 : GoInt));
                        } else if (_i < _j) {
                            _want = ((-1 : GoInt));
                        };
                        if (_got != _want) {
                            _t.errorf(((("absCmp |%s|, |%s|: got %d; want %d" : GoString))), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_got), Go.toInterface(_want));
                        };
                    });
                };
            };
        };
    }
function testIntCmpSelf(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _s in _cmpAbsTests) {
            var __tmp__ = new Int_().setString(_s, ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.fatalf(((("SetString(%s, 0) failed" : GoString))), Go.toInterface(_s));
            };
            var _got:GoInt = _x.cmp(_x);
            var _want:GoInt = ((0 : GoInt));
            if (_got != _want) {
                _t.errorf(((("x = %s: x.Cmp(x): got %d; want %d" : GoString))), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testInt64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _s in _int64Tests) {
            var _x:Int_ = new Int_();
            var __tmp__ = _x.setString(_s, ((0 : GoInt))), _1:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("SetString(%s, 0) failed" : GoString))), Go.toInterface(_s));
                continue;
            };
            var __tmp__ = stdgo.strconv.Strconv.parseInt(_s, ((0 : GoInt)), ((64 : GoInt))), _want:GoInt64 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                if (((((_err.__underlying__().value : Dynamic)) : stdgo.strconv.Strconv.NumError)).err == stdgo.strconv.Strconv.errRange) {
                    if (_x.isInt64()) {
                        _t.errorf(((("IsInt64(%s) succeeded unexpectedly" : GoString))), Go.toInterface(_s));
                    };
                } else {
                    _t.errorf(((("ParseInt(%s) failed" : GoString))), Go.toInterface(_s));
                };
                continue;
            };
            if (!_x.isInt64()) {
                _t.errorf(((("IsInt64(%s) failed unexpectedly" : GoString))), Go.toInterface(_s));
            };
            var _got:GoInt64 = _x.int64();
            if (_got != _want) {
                _t.errorf(((("Int64(%s) = %d; want %d" : GoString))), Go.toInterface(_s), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testUint64(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _s in _uint64Tests) {
            var _x:Int_ = new Int_();
            var __tmp__ = _x.setString(_s, ((0 : GoInt))), _1:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("SetString(%s, 0) failed" : GoString))), Go.toInterface(_s));
                continue;
            };
            var __tmp__ = stdgo.strconv.Strconv.parseUint(_s, ((0 : GoInt)), ((64 : GoInt))), _want:GoUInt64 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                if (((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))) || (((((_err.__underlying__().value : Dynamic)) : stdgo.strconv.Strconv.NumError)).err == stdgo.strconv.Strconv.errRange)) {
                    if (_x.isUint64()) {
                        _t.errorf(((("IsUint64(%s) succeeded unexpectedly" : GoString))), Go.toInterface(_s));
                    };
                } else {
                    _t.errorf(((("ParseUint(%s) failed" : GoString))), Go.toInterface(_s));
                };
                continue;
            };
            if (!_x.isUint64()) {
                _t.errorf(((("IsUint64(%s) failed unexpectedly" : GoString))), Go.toInterface(_s));
            };
            var _got:GoUInt64 = _x.uint64();
            if (_got != _want) {
                _t.errorf(((("Uint64(%s) = %d; want %d" : GoString))), Go.toInterface(_s), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function _testBitFun(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_bitFun, _x:Int_, _y:Int_, _exp:GoString):Void {
        var _expected:Ref<Int_> = new Int_();
        _expected.setString(_exp, ((0 : GoInt)));
        var _out:Ref<Int_> = _f(new Int_(), _x, _y);
        if (_out.cmp(_expected) != ((0 : GoInt))) {
            _t.errorf(((("%s: got %s want %s" : GoString))), Go.toInterface(_msg), Go.toInterface(_out), Go.toInterface(_expected));
        };
    }
function _testBitFunSelf(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_bitFun, _x:Int_, _y:Int_, _exp:GoString):Void {
        var _self:Ref<Int_> = new Int_();
        _self.set(_x);
        var _expected:Ref<Int_> = new Int_();
        _expected.setString(_exp, ((0 : GoInt)));
        _self = _f(_self, _self, _y);
        if (_self.cmp(_expected) != ((0 : GoInt))) {
            _t.errorf(((("%s: got %s want %s" : GoString))), Go.toInterface(_msg), Go.toInterface(_self), Go.toInterface(_expected));
        };
    }
function _altBit(_x:Int_, _i:GoInt):GoUInt {
        var _z:Ref<Int_> = new Int_().rsh(_x, ((_i : GoUInt)));
        _z = _z.and(_z, newInt(((1 : GoInt64))));
        if (_z.cmp(new Int_()) != ((0 : GoInt))) {
            return ((1 : GoUInt));
        };
        return ((0 : GoUInt));
    }
function _altSetBit(_z:Int_, _x:Int_, _i:GoInt, _b:GoUInt):Int_ {
        var _one:Ref<Int_> = newInt(((1 : GoInt64)));
        var _m:Ref<Int_> = _one.lsh(_one, ((_i : GoUInt)));
        if (_b == ((1 : GoUInt))) {
            return _z.or(_x, _m);
        } else if (_b == ((0 : GoUInt))) {
            return _z.andNot(_x, _m);
        };
        throw Go.toInterface(((("set bit is not 0 or 1" : GoString))));
    }
function _testBitset(_t:stdgo.testing.Testing.T_, _x:Int_):Void {
        var _n:GoInt = _x.bitLen();
        var _z:Ref<Int_> = new Int_().set(_x);
        var _z1:Ref<Int_> = new Int_().set(_x);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < (_n + ((10 : GoInt))), _i++, {
                var _old:GoUInt = _z.bit(_i);
                var _old1:GoUInt = _altBit(_z1, _i);
                if (_old != _old1) {
                    _t.errorf(((("bitset: inconsistent value for Bit(%s, %d), got %v want %v" : GoString))), Go.toInterface(_z1), Go.toInterface(_i), Go.toInterface(_old), Go.toInterface(_old1));
                };
                var _z:Ref<Int_> = new Int_().setBit(_z, _i, ((1 : GoUInt)));
                var _z1:Ref<Int_> = _altSetBit(new Int_(), _z1, _i, ((1 : GoUInt)));
                if (_z.bit(_i) == ((0 : GoUInt))) {
                    _t.errorf(((("bitset: bit %d of %s got 0 want 1" : GoString))), Go.toInterface(_i), Go.toInterface(_x));
                };
                if (_z.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(((("bitset: inconsistent value after SetBit 1, got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_z1));
                };
                _z.setBit(_z, _i, ((0 : GoUInt)));
                _altSetBit(_z1, _z1, _i, ((0 : GoUInt)));
                if (_z.bit(_i) != ((0 : GoUInt))) {
                    _t.errorf(((("bitset: bit %d of %s got 1 want 0" : GoString))), Go.toInterface(_i), Go.toInterface(_x));
                };
                if (_z.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(((("bitset: inconsistent value after SetBit 0, got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_z1));
                };
                _altSetBit(_z1, _z1, _i, _old);
                _z.setBit(_z, _i, _old);
                if (_z.cmp(_z1) != ((0 : GoInt))) {
                    _t.errorf(((("bitset: inconsistent value after SetBit old, got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_z1));
                };
            });
        };
        if (_z.cmp(_x) != ((0 : GoInt))) {
            _t.errorf(((("bitset: got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_x));
        };
    }
function testBitSet(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in _bitwiseTests) {
            var _x:Ref<Int_> = new Int_();
            _x.setString(_test._x, ((0 : GoInt)));
            _testBitset(_t, _x);
            _x = new Int_();
            _x.setString(_test._y, ((0 : GoInt)));
            _testBitset(_t, _x);
        };
        for (_i => _test in _bitsetTests) {
            var _x:Ref<Int_> = new Int_();
            _x.setString(_test._x, ((0 : GoInt)));
            var _b:GoUInt = _x.bit(_test._i);
            if (_b != _test._b) {
                _t.errorf(((("#%d got %v want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_b), Go.toInterface(_test._b));
            };
        };
        var _z:Ref<Int_> = newInt(((1 : GoInt64)));
        _z.setBit(newInt(((0 : GoInt64))), ((2 : GoInt)), ((1 : GoUInt)));
        if (_z.cmp(newInt(((4 : GoInt64)))) != ((0 : GoInt))) {
            _t.errorf(((("destination leaked into result; got %s want 4" : GoString))), Go.toInterface(_z));
        };
    }
function testTrailingZeroBits(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _tzbTests) {
            var __tmp__ = new Int_().setString(_test._in, ((0 : GoInt))), _in:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var _want:GoUInt = _test._out;
            var _got:GoUInt = _in.trailingZeroBits();
            if (_got != _want) {
                _t.errorf(((("#%d: got %v want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function benchmarkBitset(_b:stdgo.testing.Testing.B):Void {
        var _z:Ref<Int_> = new Int_();
        _z.setBit(_z, ((512 : GoInt)), ((1 : GoUInt)));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _z.setBit(_z, _i & ((512 : GoInt)), ((1 : GoUInt)));
            });
        };
    }
function benchmarkBitsetNeg(_b:stdgo.testing.Testing.B):Void {
        var _z:Ref<Int_> = newInt(((-1 : GoInt64)));
        _z.setBit(_z, ((512 : GoInt)), ((0 : GoUInt)));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _z.setBit(_z, _i & ((512 : GoInt)), ((0 : GoUInt)));
            });
        };
    }
function benchmarkBitsetOrig(_b:stdgo.testing.Testing.B):Void {
        var _z:Ref<Int_> = new Int_();
        _altSetBit(_z, _z, ((512 : GoInt)), ((1 : GoUInt)));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _altSetBit(_z, _z, _i & ((512 : GoInt)), ((1 : GoUInt)));
            });
        };
    }
function benchmarkBitsetNegOrig(_b:stdgo.testing.Testing.B):Void {
        var _z:Ref<Int_> = newInt(((-1 : GoInt64)));
        _altSetBit(_z, _z, ((512 : GoInt)), ((0 : GoUInt)));
        _b.resetTimer();
        _b.startTimer();
        {
            var _i:GoInt = _b.n - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _altSetBit(_z, _z, _i & ((512 : GoInt)), ((0 : GoUInt)));
            });
        };
    }
function _tri(_n:GoUInt):Int_ {
        var _x:Ref<Int_> = newInt(((1 : GoInt64)));
        _x.lsh(_x, _n);
        var _x2:Ref<Int_> = new Int_().lsh(_x, _n);
        _x2.sub(_x2, _x);
        _x2.sub(_x2, _intOne);
        return _x2;
    }
function benchmarkModSqrt225_Tonelli(_b:stdgo.testing.Testing.B):Void {
        var _p:Ref<Int_> = _tri(((225 : GoUInt)));
        var _x:Ref<Int_> = newInt(((2 : GoInt64)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64(((2 : GoUInt64)));
                _x._modSqrtTonelliShanks(_x, _p);
            });
        };
    }
function benchmarkModSqrt225_3Mod4(_b:stdgo.testing.Testing.B):Void {
        var _p:Ref<Int_> = _tri(((225 : GoUInt)));
        var _x:Ref<Int_> = new Int_().setUint64(((2 : GoUInt64)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64(((2 : GoUInt64)));
                _x._modSqrt3Mod4Prime(_x, _p);
            });
        };
    }
function benchmarkModSqrt231_Tonelli(_b:stdgo.testing.Testing.B):Void {
        var _p:Ref<Int_> = _tri(((231 : GoUInt)));
        _p.sub(_p, _intOne);
        _p.sub(_p, _intOne);
        var _x:Ref<Int_> = new Int_().setUint64(((7 : GoUInt64)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64(((7 : GoUInt64)));
                _x._modSqrtTonelliShanks(_x, _p);
            });
        };
    }
function benchmarkModSqrt231_5Mod8(_b:stdgo.testing.Testing.B):Void {
        var _p:Ref<Int_> = _tri(((231 : GoUInt)));
        _p.sub(_p, _intOne);
        _p.sub(_p, _intOne);
        var _x:Ref<Int_> = new Int_().setUint64(((7 : GoUInt64)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _x.setUint64(((7 : GoUInt64)));
                _x._modSqrt5Mod8Prime(_x, _p);
            });
        };
    }
function testBitwise(_t:stdgo.testing.Testing.T_):Void {
        var _x:Ref<Int_> = new Int_();
        var _y:Ref<Int_> = new Int_();
        for (_0 => _test in _bitwiseTests) {
            _x.setString(_test._x, ((0 : GoInt)));
            _y.setString(_test._y, ((0 : GoInt)));
            _testBitFun(_t, ((("and" : GoString))), (Int__static_extension).and, _x, _y, _test._and);
            _testBitFunSelf(_t, ((("and" : GoString))), (Int__static_extension).and, _x, _y, _test._and);
            _testBitFun(_t, ((("andNot" : GoString))), (Int__static_extension).andNot, _x, _y, _test._andNot);
            _testBitFunSelf(_t, ((("andNot" : GoString))), (Int__static_extension).andNot, _x, _y, _test._andNot);
            _testBitFun(_t, ((("or" : GoString))), (Int__static_extension).or, _x, _y, _test._or);
            _testBitFunSelf(_t, ((("or" : GoString))), (Int__static_extension).or, _x, _y, _test._or);
            _testBitFun(_t, ((("xor" : GoString))), (Int__static_extension).xor, _x, _y, _test._xor);
            _testBitFunSelf(_t, ((("xor" : GoString))), (Int__static_extension).xor, _x, _y, _test._xor);
        };
    }
function testNot(_t:stdgo.testing.Testing.T_):Void {
        var _in:Ref<Int_> = new Int_();
        var _out:Ref<Int_> = new Int_();
        var _expected:Ref<Int_> = new Int_();
        for (_i => _test in _notTests) {
            _in.setString(_test._in, ((10 : GoInt)));
            _expected.setString(_test._out, ((10 : GoInt)));
            _out = _out.not(_in);
            if (_out.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_expected));
            };
            _out = _out.not(_out);
            if (_out.cmp(_in) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_in));
            };
        };
    }
function testModInverse(_t:stdgo.testing.Testing.T_):Void {
        var _element:Int_ = new Int_(), _modulus:Int_ = new Int_(), _gcd:Int_ = new Int_(), _inverse:Int_ = new Int_();
        var _one:Ref<Int_> = newInt(((1 : GoInt64)));
        for (_0 => _test in _modInverseTests) {
            (_element).setString(_test._element, ((10 : GoInt)));
            (_modulus).setString(_test._modulus, ((10 : GoInt)));
            (_inverse).modInverse(_element, _modulus);
            (_inverse).mul(_inverse, _element);
            (_inverse).mod(_inverse, _modulus);
            if ((_inverse).cmp(_one) != ((0 : GoInt))) {
                _t.errorf(((("ModInverse(%d,%d)*%d%%%d=%d, not 1" : GoString))), Go.toInterface(_element), Go.toInterface(_modulus), Go.toInterface(_element), Go.toInterface(_modulus), Go.toInterface(_inverse));
            };
        };
        {
            var _n:GoInt = ((2 : GoInt));
            Go.cfor(_n < ((100 : GoInt)), _n++, {
                (_modulus).setInt64(((_n : GoInt64)));
                {
                    var _x:GoInt = ((1 : GoInt));
                    Go.cfor(_x < _n, _x++, {
                        (_element).setInt64(((_x : GoInt64)));
                        (_gcd).gcd(null, null, _element, _modulus);
                        if ((_gcd).cmp(_one) != ((0 : GoInt))) {
                            continue;
                        };
                        (_inverse).modInverse(_element, _modulus);
                        (_inverse).mul(_inverse, _element);
                        (_inverse).mod(_inverse, _modulus);
                        if ((_inverse).cmp(_one) != ((0 : GoInt))) {
                            _t.errorf(((("ModInverse(%d,%d)*%d%%%d=%d, not 1" : GoString))), Go.toInterface(_element), Go.toInterface(_modulus), Go.toInterface(_element), Go.toInterface(_modulus), Go.toInterface(_inverse));
                        };
                    });
                };
            });
        };
    }
function benchmarkModInverse(_b:stdgo.testing.Testing.B):Void {
        var _p:Ref<Int_> = new Int_().setInt64(((1 : GoInt64)));
        _p._abs = (_p._abs._shl((_p._abs == null ? null : _p._abs.__copy__()), ((1279 : GoUInt))) == null ? null : _p._abs._shl((_p._abs == null ? null : _p._abs.__copy__()), ((1279 : GoUInt))).__copy__());
        _p.sub(_p, _intOne);
        var _x:Ref<Int_> = new Int_().sub(_p, _intOne);
        var _z:Ref<Int_> = new Int_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _z.modInverse(_x, _p);
            });
        };
    }
function _testModSqrt(_t:stdgo.testing.Testing.T_, _elt:Int_, _mod:Int_, _sq:Int_, _sqrt:Int_):Bool {
        var _sqChk:Int_ = new Int_(), _sqrtChk:Int_ = new Int_(), _sqrtsq:Int_ = new Int_();
        _sq.mul(_elt, _elt);
        _sq.mod(_sq, _mod);
        var _z:Ref<Int_> = _sqrt.modSqrt(_sq, _mod);
        if (_z != _sqrt) {
            _t.errorf(((("ModSqrt returned wrong value %s" : GoString))), Go.toInterface(_z));
        };
        _sqChk.add(_sq, _mod);
        _z = _sqrtChk.modSqrt(_sqChk, _mod);
        if ((_z != _sqrtChk) || (_z.cmp(_sqrt) != ((0 : GoInt)))) {
            _t.errorf(((("ModSqrt returned inconsistent value %s" : GoString))), Go.toInterface(_z));
        };
        _sqChk.sub(_sq, _mod);
        _z = _sqrtChk.modSqrt(_sqChk, _mod);
        if ((_z != _sqrtChk) || (_z.cmp(_sqrt) != ((0 : GoInt)))) {
            _t.errorf(((("ModSqrt returned inconsistent value %s" : GoString))), Go.toInterface(_z));
        };
        _z = _sqrtChk.modSqrt(_sqrtChk.set(_sq), _mod);
        if ((_z != _sqrtChk) || (_z.cmp(_sqrt) != ((0 : GoInt)))) {
            _t.errorf(((("ModSqrt returned inconsistent value %s" : GoString))), Go.toInterface(_z));
        };
        if (_sqrt.cmp(_elt) == ((0 : GoInt))) {
            return true;
        };
        _sqrtsq.mul(_sqrt, _sqrt);
        _sqrtsq.mod(_sqrtsq, _mod);
        return _sq.cmp(_sqrtsq) == ((0 : GoInt));
    }
function testModSqrt(_t:stdgo.testing.Testing.T_):Void {
        var _elt:Int_ = new Int_(), _mod:Int_ = new Int_(), _modx4:Int_ = new Int_(), _sq:Int_ = new Int_(), _sqrt:Int_ = new Int_();
        var _r:Ref<stdgo.math.rand.Rand.Rand> = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource(((9 : GoInt64))));
        for (_i => _s in ((_primes.__slice__(((1 : GoInt))) : Slice<GoString>))) {
            _mod.setString(_s, ((10 : GoInt)));
            _modx4.lsh(_mod, ((2 : GoUInt)));
            {
                var _x:GoInt = ((1 : GoInt));
                Go.cfor(_x < ((5 : GoInt)), _x++, {
                    _elt.rand(_r, _modx4);
                    _elt.sub(_elt, _mod);
                    if (!_testModSqrt(_t, _elt, _mod, _sq, _sqrt)) {
                        _t.errorf(((("#%d: failed (sqrt(e) = %s)" : GoString))), Go.toInterface(_i), Go.toInterface(_sqrt));
                    };
                });
            };
            if (stdgo.testing.Testing.short() && (_i > ((2 : GoInt)))) {
                break;
            };
        };
        if (stdgo.testing.Testing.short()) {
            return;
        };
        {
            var _n:GoInt = ((3 : GoInt));
            Go.cfor(_n < ((100 : GoInt)), _n++, {
                _mod.setInt64(((_n : GoInt64)));
                if (!_mod.probablyPrime(((10 : GoInt)))) {
                    continue;
                };
                var _isSquare:Slice<Bool> = new Slice<Bool>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) false]);
                {
                    var _x:GoInt = ((1 : GoInt));
                    Go.cfor(_x < _n, _x++, {
                        _elt.setInt64(((_x : GoInt64)));
                        if (!_testModSqrt(_t, _elt, _mod, _sq, _sqrt)) {
                            _t.errorf(((("#%d: failed (sqrt(%d,%d) = %s)" : GoString))), Go.toInterface(_x), Go.toInterface(_elt), Go.toInterface(_mod), Go.toInterface(_sqrt));
                        };
                        if (_isSquare != null) _isSquare[_sq.uint64()] = true;
                    });
                };
                {
                    var _x:GoInt = ((1 : GoInt));
                    Go.cfor(_x < _n, _x++, {
                        _sq.setInt64(((_x : GoInt64)));
                        var _z:Ref<Int_> = _sqrt.modSqrt(_sq, _mod);
                        if (!(_isSquare != null ? _isSquare[_x] : false) && (_z != null)) {
                            _t.errorf(((("#%d: failed (sqrt(%d,%d) = nil)" : GoString))), Go.toInterface(_x), Go.toInterface(_sqrt), Go.toInterface(_mod));
                        };
                    });
                };
            });
        };
    }
function testJacobi(_t:stdgo.testing.Testing.T_):Void {
        var _testCases:Slice<T__struct_44> = ((new Slice<T__struct_44>(
((new T__struct_44(((0 : GoInt64)), ((1 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((0 : GoInt64)), ((-1 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((1 : GoInt64)), ((1 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((1 : GoInt64)), ((-1 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((0 : GoInt64)), ((5 : GoInt64)), ((0 : GoInt))) : T__struct_44)),
((new T__struct_44(((1 : GoInt64)), ((5 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((2 : GoInt64)), ((5 : GoInt64)), ((-1 : GoInt))) : T__struct_44)),
((new T__struct_44(((-2 : GoInt64)), ((5 : GoInt64)), ((-1 : GoInt))) : T__struct_44)),
((new T__struct_44(((2 : GoInt64)), ((-5 : GoInt64)), ((-1 : GoInt))) : T__struct_44)),
((new T__struct_44(((-2 : GoInt64)), ((-5 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((3 : GoInt64)), ((5 : GoInt64)), ((-1 : GoInt))) : T__struct_44)),
((new T__struct_44(((5 : GoInt64)), ((5 : GoInt64)), ((0 : GoInt))) : T__struct_44)),
((new T__struct_44(((-5 : GoInt64)), ((5 : GoInt64)), ((0 : GoInt))) : T__struct_44)),
((new T__struct_44(((6 : GoInt64)), ((5 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((6 : GoInt64)), ((-5 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((-6 : GoInt64)), ((5 : GoInt64)), ((1 : GoInt))) : T__struct_44)),
((new T__struct_44(((-6 : GoInt64)), ((-5 : GoInt64)), ((-1 : GoInt))) : T__struct_44))) : Slice<T__struct_44>));
        var _x:Int_ = new Int_(), _y:Int_ = new Int_();
        for (_i => _test in _testCases) {
            _x.setInt64(_test._x);
            _y.setInt64(_test._y);
            var _expected:GoInt = _test._result;
            var _actual:GoInt = jacobi(_x, _y);
            if (_actual != _expected) {
                _t.errorf(((("#%d: Jacobi(%d, %d) = %d, but expected %d" : GoString))), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._y), Go.toInterface(_actual), Go.toInterface(_expected));
            };
        };
    }
function testJacobiPanic(_t:stdgo.testing.Testing.T_):Void {
        var __recover_exception__:AnyInterface = null;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            {};
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    var _msg:AnyInterface = Go.toInterface(({
                        final r = __recover_exception__;
                        __recover_exception__ = null;
                        r;
                    }));
                    if ((_msg == null) || (_msg == ((("test failure" : GoString))))) {
                        throw Go.toInterface(_msg);
                    };
                    _t.log(Go.toInterface(_msg));
                };
                a();
            });
            var _x:Ref<Int_> = newInt(((1 : GoInt64)));
            var _y:Ref<Int_> = newInt(((2 : GoInt64)));
            jacobi(_x, _y);
            throw Go.toInterface(((("test failure" : GoString))));
            for (defer in __deferstack__) {
                defer();
            };
        } catch(__exception__) {
            if (!(__exception__.native is AnyInterfaceData)) throw __exception__;
            __recover_exception__ = __exception__.native;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (__recover_exception__ != null) throw __recover_exception__;
                return;
            };
        };
    }
function testIssue2607(_t:stdgo.testing.Testing.T_):Void {
        var _n:Ref<Int_> = newInt(((10 : GoInt64)));
        _n.rand(stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource(((9 : GoInt64)))), _n);
    }
function testSqrt(_t:stdgo.testing.Testing.T_):Void {
        var _root:GoInt = ((0 : GoInt));
        var _r:Ref<Int_> = new Int_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((10000 : GoInt)), _i++, {
                if (((_root + ((1 : GoInt))) * (_root + ((1 : GoInt)))) <= _i) {
                    _root++;
                };
                var _n:Ref<Int_> = newInt(((_i : GoInt64)));
                _r.setInt64(((-2 : GoInt64)));
                _r.sqrt(_n);
                if (_r.cmp(newInt(((_root : GoInt64)))) != ((0 : GoInt))) {
                    _t.errorf(((("Sqrt(%v) = %v, want %v" : GoString))), Go.toInterface(_n), Go.toInterface(_r), Go.toInterface(_root));
                };
            });
        };
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((1000 : GoInt)), _i = _i + (((10 : GoInt))), {
                var __tmp__ = new Int_().setString(((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), _i), ((10 : GoInt))), _n:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
                var _r:Ref<Int_> = new Int_().sqrt(_n);
                var __tmp__ = new Int_().setString(((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), _i / ((2 : GoInt))), ((10 : GoInt))), _root:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
                if (_r.cmp(_root) != ((0 : GoInt))) {
                    _t.errorf(((("Sqrt(1e%d) = %v, want 1e%d" : GoString))), Go.toInterface(_i), Go.toInterface(_r), Go.toInterface(_i / ((2 : GoInt))));
                };
            });
        };
        _r.setInt64(((100 : GoInt64)));
        _r.sqrt(_r);
        if (_r.int64() != ((10 : GoInt64))) {
            _t.errorf(((("Sqrt(100) = %v, want 10 (aliased output)" : GoString))), Go.toInterface(_r.int64()));
        };
    }
function testIssue22830(_t:stdgo.testing.Testing.T_):Void {
        var _one:Ref<Int_> = new Int_().setInt64(((1 : GoInt64)));
        var __tmp__ = new Int_().setString(((("84555555300000000000" : GoString))), ((10 : GoInt))), _base:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("66666670001111111111" : GoString))), ((10 : GoInt))), _mod:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
        var __tmp__ = new Int_().setString(((("17888885298888888889" : GoString))), ((10 : GoInt))), _want:Ref<Int_> = __tmp__._0, _2:Bool = __tmp__._1;
        var _tests:Slice<GoInt64> = ((new Slice<GoInt64>(((0 : GoInt64)), ((1 : GoInt64)), ((-1 : GoInt64))) : Slice<GoInt64>));
        for (_3 => _n in _tests) {
            var _m:Ref<Int_> = newInt(_n);
            {
                var _got:Ref<Int_> = _m.exp(_base, _one, _mod);
                if (_got.cmp(_want) != ((0 : GoInt))) {
                    _t.errorf(((("(%v).Exp(%s, 1, %s) = %s, want %s" : GoString))), Go.toInterface(_n), Go.toInterface(_base), Go.toInterface(_mod), Go.toInterface(_got), Go.toInterface(_want));
                };
            };
        };
    }
function benchmarkSqrt(_b:stdgo.testing.Testing.B):Void {
        var __tmp__ = new Int_().setString(((("1" : GoString))) + stdgo.strings.Strings.repeat(((("0" : GoString))), ((1001 : GoInt))), ((10 : GoInt))), _n:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
        _b.resetTimer();
        var _t:Ref<Int_> = new Int_();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _t.sqrt(_n);
            });
        };
    }
function _benchmarkIntSqr(_b:stdgo.testing.Testing.B, _nwords:GoInt):Void {
        var _x:Ref<Int_> = new Int_();
        _x._abs = (_rndNat(_nwords) == null ? null : _rndNat(_nwords).__copy__());
        var _t:Ref<Int_> = new Int_();
        _b.resetTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _t.mul(_x, _x);
            });
        };
    }
function benchmarkIntSqr(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _sqrBenchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            _b.run(stdgo.fmt.Fmt.sprintf(((("%d" : GoString))), Go.toInterface(_n)), function(_b:stdgo.testing.Testing.B):Void {
                _benchmarkIntSqr(_b, _n);
            });
        };
    }
function _benchmarkDiv(_b:stdgo.testing.Testing.B, _aSize:GoInt, _bSize:GoInt):Void {
        var _r:Ref<stdgo.math.rand.Rand.Rand> = stdgo.math.rand.Rand.new_(stdgo.math.rand.Rand.newSource(((1234 : GoInt64))));
        var _aa:Ref<Int_> = _randInt(_r, ((_aSize : GoUInt)));
        var _bb:Ref<Int_> = _randInt(_r, ((_bSize : GoUInt)));
        if (_aa.cmp(_bb) < ((0 : GoInt))) {
            {
                final __tmp__0 = _bb;
                final __tmp__1 = _aa;
                _aa = __tmp__0;
                _bb = __tmp__1;
            };
        };
        var _x:Ref<Int_> = new Int_();
        var _y:Ref<Int_> = new Int_();
        _b.resetTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _x.divMod(_aa, _bb, _y);
            });
        };
    }
function benchmarkDiv(_b:stdgo.testing.Testing.B):Void {
        var _sizes:Slice<GoInt> = ((new Slice<GoInt>(
((10 : GoInt)),
((20 : GoInt)),
((50 : GoInt)),
((100 : GoInt)),
((200 : GoInt)),
((500 : GoInt)),
((1000 : GoInt)),
((10000 : GoInt)),
((100000 : GoInt)),
((1e+06 : GoInt)),
((1e+07 : GoInt))) : Slice<GoInt>));
        for (_0 => _i in _sizes) {
            var _j:GoInt = ((2 : GoInt)) * _i;
            _b.run(stdgo.fmt.Fmt.sprintf(((("%d/%d" : GoString))), Go.toInterface(_j), Go.toInterface(_i)), function(_b:stdgo.testing.Testing.B):Void {
                _benchmarkDiv(_b, _j, _i);
            });
        };
    }
function testFillBytes(_t:stdgo.testing.Testing.T_):Void {
        var _checkResult:(Ref<stdgo.testing.Testing.T_>, Slice<GoUInt8>, Ref<Int_>) -> Void = function(_t:stdgo.testing.Testing.T_, _buf:Slice<GoByte>, _want:Int_):Void {
            _t.helper();
            var _got:Ref<Int_> = new Int_().setBytes(_buf);
            if (_got.cmpAbs(_want) != ((0 : GoInt))) {
                _t.errorf(((("got 0x%x, want 0x%x: %x" : GoString))), Go.toInterface(_got), Go.toInterface(_want), Go.toInterface(_buf));
            };
        };
        var _panics:(() -> Void) -> Bool = function(_f:() -> Void):Bool {
            var __recover_exception__:AnyInterface = null;
            var __deferstack__:Array<Void -> Void> = [];
            var _panic:Bool = false;
            try {
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _panic = ({
                            final r = __recover_exception__;
                            __recover_exception__ = null;
                            r;
                        }) != null;
                    };
                    a();
                });
                _f();
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    return _panic;
                };
                for (defer in __deferstack__) {
                    defer();
                };
            } catch(__exception__) {
                if (!(__exception__.native is AnyInterfaceData)) throw __exception__;
                __recover_exception__ = __exception__.native;
                {
                    for (defer in __deferstack__) {
                        defer();
                    };
                    if (__recover_exception__ != null) throw __recover_exception__;
                    return _panic;
                };
            };
        };
        for (_0 => _n in ((new Slice<GoString>(((("0" : GoString))), ((("1000" : GoString))), ((("0xffffffff" : GoString))), ((("-0xffffffff" : GoString))), ((("0xffffffffffffffff" : GoString))), ((("0x10000000000000000" : GoString))), ((("0xabababababababababababababababababababababababababa" : GoString))), ((("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff" : GoString)))) : Slice<GoString>))) {
            _t.run(_n, function(_t:stdgo.testing.Testing.T_):Void {
                _t.logf(_n);
                var __tmp__ = new Int_().setString(_n, ((0 : GoInt))), _x:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
                if (!_ok) {
                    throw Go.toInterface(((("invalid test entry" : GoString))));
                };
                var _byteLen:GoInt = (_x.bitLen() + ((7 : GoInt))) / ((8 : GoInt));
                var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_byteLen : GoInt)).toBasic()) ((0 : GoUInt8))]);
                _checkResult(_t, _x.fillBytes(_buf), _x);
                _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((100 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]);
                for (_i => _ in _buf) {
                    if (_buf != null) _buf[_i] = ((255 : GoUInt8));
                };
                _checkResult(_t, _x.fillBytes(_buf), _x);
                if (_byteLen > ((0 : GoInt))) {
                    _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((_byteLen - ((1 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]);
                    if (!_panics(function():Void {
                        _x.fillBytes(_buf);
                    })) {
                        _t.errorf(((("expected panic for small buffer and value %x" : GoString))), Go.toInterface(_x));
                    };
                };
            });
        };
    }
function _writeMultiple(_s:stdgo.fmt.Fmt.State, _text:GoString, _count:GoInt):Void {
        if ((_text != null ? _text.length : ((0 : GoInt))) > ((0 : GoInt))) {
            var _b:Slice<GoUInt8> = ((_text : Slice<GoByte>));
            Go.cfor(_count > ((0 : GoInt)), _count--, {
                _s.write(_b);
            });
        };
    }
function _scanSign(_r:stdgo.io.Io.ByteScanner):{ var _0 : Bool; var _1 : Error; } {
        var _neg:Bool = false, _err:Error = ((null : stdgo.Error));
        var _ch:GoByte = ((0 : GoUInt8));
        {
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
            if (_err != null) {
                return { _0 : false, _1 : _err };
            };
        };
        if (_ch == ((((("-" : GoString))).code : GoRune))) {
            _neg = true;
        } else if (_ch == ((((("+" : GoString))).code : GoRune))) {} else {
            _r.unreadByte();
        };
        return { _0 : _neg, _1 : _err };
    }
function testIntText(_t:stdgo.testing.Testing.T_):Void {
        var _z:Ref<Int_> = new Int_();
        for (_0 => _test in _stringTests) {
            if (!_test._ok) {
                continue;
            };
            var __tmp__ = _z.setString(_test._in, _test._base), _1:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("%v: failed to parse" : GoString))), Go.toInterface(_test));
                continue;
            };
            var _base:GoInt = _test._base;
            if (_base == ((0 : GoInt))) {
                _base = ((10 : GoInt));
            };
            {
                var _got:GoString = _z.text(_base);
                if (_got != _test._out) {
                    _t.errorf(((("%v: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_test._out));
                };
            };
        };
    }
function testAppendText(_t:stdgo.testing.Testing.T_):Void {
        var _z:Ref<Int_> = new Int_();
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        for (_0 => _test in _stringTests) {
            if (!_test._ok) {
                continue;
            };
            var __tmp__ = _z.setString(_test._in, _test._base), _1:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("%v: failed to parse" : GoString))), Go.toInterface(_test));
                continue;
            };
            var _base:GoInt = _test._base;
            if (_base == ((0 : GoInt))) {
                _base = ((10 : GoInt));
            };
            var _i:GoInt = (_buf != null ? _buf.length : ((0 : GoInt)));
            _buf = _z.append(_buf, _base);
            {
                var _got:GoString = ((((_buf.__slice__(_i) : Slice<GoUInt8>)) : GoString));
                if (_got != _test._out) {
                    _t.errorf(((("%v: got %s; want %s" : GoString))), Go.toInterface(_test), Go.toInterface(_got), Go.toInterface(_test._out));
                };
            };
        };
    }
function _format(_base:GoInt):GoString {
        if (_base == ((2 : GoInt))) {
            return ((("%b" : GoString)));
        } else if (_base == ((8 : GoInt))) {
            return ((("%o" : GoString)));
        } else if (_base == ((16 : GoInt))) {
            return ((("%x" : GoString)));
        };
        return ((("%d" : GoString)));
    }
function testGetString(_t:stdgo.testing.Testing.T_):Void {
        var _z:Ref<Int_> = new Int_();
        for (_i => _test in _stringTests) {
            if (!_test._ok) {
                continue;
            };
            _z.setInt64(_test._val);
            if (_test._base == ((10 : GoInt))) {
                {
                    var _got:GoString = ((_z.toString() : GoString));
                    if (_got != _test._out) {
                        _t.errorf(((("#%da got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_test._out));
                    };
                };
            };
            var _f:GoString = _format(_test._base);
            var _got:GoString = stdgo.fmt.Fmt.sprintf(_f, Go.toInterface(_z));
            if (_f == ((("%d" : GoString)))) {
                if (_got != stdgo.fmt.Fmt.sprintf(((("%d" : GoString))), Go.toInterface(_test._val))) {
                    _t.errorf(((("#%db got %s; want %d" : GoString))), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_test._val));
                };
            } else {
                if (_got != _test._out) {
                    _t.errorf(((("#%dc got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_got), Go.toInterface(_test._out));
                };
            };
        };
    }
function testSetString(_t:stdgo.testing.Testing.T_):Void {
        var _tmp:Ref<Int_> = new Int_();
        for (_i => _test in _stringTests) {
            _tmp.setInt64(((1234567890 : GoInt64)));
            var __tmp__ = new Int_().setString(_test._in, _test._base), _n1:Ref<Int_> = __tmp__._0, _ok1:Bool = __tmp__._1;
            var __tmp__ = _tmp.setString(_test._in, _test._base), _n2:Ref<Int_> = __tmp__._0, _ok2:Bool = __tmp__._1;
            var _expected:Ref<Int_> = newInt(_test._val);
            if ((_ok1 != _test._ok) || (_ok2 != _test._ok)) {
                _t.errorf(((("#%d (input \'%s\') ok incorrect (should be %t)" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_test._ok));
                continue;
            };
            if (!_ok1) {
                if (_n1 != null) {
                    _t.errorf(((("#%d (input \'%s\') n1 != nil" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in));
                };
                continue;
            };
            if (!_ok2) {
                if (_n2 != null) {
                    _t.errorf(((("#%d (input \'%s\') n2 != nil" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in));
                };
                continue;
            };
            if (_ok1 && !_isNormalized(_n1)) {
                _t.errorf(((("#%d (input \'%s\'): %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_n1));
            };
            if (_ok2 && !_isNormalized(_n2)) {
                _t.errorf(((("#%d (input \'%s\'): %v is not normalized" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_n2));
            };
            if (_n1.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d (input \'%s\') got: %s want: %d" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_n1), Go.toInterface(_test._val));
            };
            if (_n2.cmp(_expected) != ((0 : GoInt))) {
                _t.errorf(((("#%d (input \'%s\') got: %s want: %d" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_n2), Go.toInterface(_test._val));
            };
        };
    }
function testFormat(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _formatTests) {
            var _x:Int_ = ((null : Ref<Int_>));
            if (_test._input != ((("<nil>" : GoString)))) {
                var _ok:Bool = false;
                {
                    var __tmp__ = new Int_().setString(_test._input, ((0 : GoInt)));
                    _x = __tmp__._0;
                    _ok = __tmp__._1;
                };
                if (!_ok) {
                    _t.errorf(((("#%d failed reading input %s" : GoString))), Go.toInterface(_i), Go.toInterface(_test._input));
                };
            };
            var _output:GoString = stdgo.fmt.Fmt.sprintf(_test._format, Go.toInterface(_x));
            if (_output != _test._output) {
                _t.errorf(((("#%d got %q; want %q, {%q, %q, %q}" : GoString))), Go.toInterface(_i), Go.toInterface(_output), Go.toInterface(_test._output), Go.toInterface(_test._input), Go.toInterface(_test._format), Go.toInterface(_test._output));
            };
        };
    }
function testScan(_t:stdgo.testing.Testing.T_):Void {
        var _buf:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        for (_i => _test in _scanTests) {
            var _x:Ref<Int_> = new Int_();
            _buf.reset();
            _buf.writeString(_test._input);
            {
                var __tmp__ = stdgo.fmt.Fmt.fscanf(_buf, _test._format, Go.toInterface(_x)), _0:GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(((("#%d error: %s" : GoString))), Go.toInterface(_i), Go.toInterface(_err));
                };
            };
            if (((_x.toString() : GoString)) != _test._output) {
                _t.errorf(((("#%d got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(((_x.toString() : GoString))), Go.toInterface(_test._output));
            };
            if (_buf.len() != _test._remaining) {
                _t.errorf(((("#%d got %d bytes remaining; want %d" : GoString))), Go.toInterface(_i), Go.toInterface(_buf.len()), Go.toInterface(_test._remaining));
            };
        };
    }
function testIntGobEncoding(_t:stdgo.testing.Testing.T_):Void {
        var _medium:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        var _enc:Ref<stdgo.encoding.gob.Gob.Encoder> = stdgo.encoding.gob.Gob.newEncoder(_medium);
        var _dec:Ref<stdgo.encoding.gob.Gob.Decoder> = stdgo.encoding.gob.Gob.newDecoder(_medium);
        for (_0 => _test in _encodingTests) {
            for (_1 => _sign in ((new Slice<GoString>(((("" : GoString))), ((("+" : GoString))), ((("-" : GoString)))) : Slice<GoString>))) {
                var _x:GoString = _sign + _test;
                _medium.reset();
                var _tx:Int_ = new Int_();
                _tx.setString(_x, ((10 : GoInt)));
                {
                    var _err:stdgo.Error = _enc.encode(Go.toInterface(_tx));
                    if (_err != null) {
                        _t.errorf(((("encoding of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                        continue;
                    };
                };
                var _rx:Int_ = new Int_();
                {
                    var _err:stdgo.Error = _dec.decode(Go.toInterface(_rx));
                    if (_err != null) {
                        _t.errorf(((("decoding of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp(_tx) != ((0 : GoInt))) {
                    _t.errorf(((("transmission of %s failed: got %s want %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_rx), Go.toInterface(_tx));
                };
            };
        };
    }
function testGobEncodingNilIntInSlice(_t:stdgo.testing.Testing.T_):Void {
        var _buf:Ref<stdgo.bytes.Bytes.Buffer> = new stdgo.bytes.Bytes.Buffer();
        var _enc:Ref<stdgo.encoding.gob.Gob.Encoder> = stdgo.encoding.gob.Gob.newEncoder(_buf);
        var _dec:Ref<stdgo.encoding.gob.Gob.Decoder> = stdgo.encoding.gob.Gob.newDecoder(_buf);
        var _in:Slice<Ref<Int_>> = new Slice<Ref<Int_>>(...[for (i in 0 ... ((((1 : GoInt)) : GoInt)).toBasic()) ((null : Ref<Int_>))]);
        var _err:stdgo.Error = _enc.encode(Go.toInterface(_in));
        if (_err != null) {
            _t.errorf(((("gob encode failed: %q" : GoString))), Go.toInterface(_err));
        };
        var _out:Slice<Int_> = ((null : Slice<Ref<Int_>>));
        _err = _dec.decode(Go.toInterface(_out));
        if (_err != null) {
            _t.fatalf(((("gob decode failed: %q" : GoString))), Go.toInterface(_err));
        };
        if ((_out != null ? _out.length : ((0 : GoInt))) != ((1 : GoInt))) {
            _t.fatalf(((("wrong len; want 1 got %d" : GoString))), Go.toInterface((_out != null ? _out.length : ((0 : GoInt)))));
        };
        var _zero:Int_ = new Int_();
        if ((_out != null ? _out[((0 : GoInt))] : ((null : Ref<Int_>))).cmp(_zero) != ((0 : GoInt))) {
            _t.fatalf(((("transmission of (*Int)(nil) failed: got %s want 0" : GoString))), Go.toInterface(_out));
        };
    }
function testIntJSONEncoding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in _encodingTests) {
            for (_1 => _sign in ((new Slice<GoString>(((("" : GoString))), ((("+" : GoString))), ((("-" : GoString)))) : Slice<GoString>))) {
                var _x:GoString = _sign + _test;
                var _tx:Int_ = new Int_();
                _tx.setString(_x, ((10 : GoInt)));
                var __tmp__ = stdgo.encoding.json.Json.marshal(Go.toInterface(_tx)), _b:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(((("marshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                    continue;
                };
                var _rx:Int_ = new Int_();
                {
                    var _err:stdgo.Error = stdgo.encoding.json.Json.unmarshal(_b, Go.toInterface(_rx));
                    if (_err != null) {
                        _t.errorf(((("unmarshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp(_tx) != ((0 : GoInt))) {
                    _t.errorf(((("JSON encoding of %s failed: got %s want %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_rx), Go.toInterface(_tx));
                };
            };
        };
    }
function testIntXMLEncoding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in _encodingTests) {
            for (_1 => _sign in ((new Slice<GoString>(((("" : GoString))), ((("+" : GoString))), ((("-" : GoString)))) : Slice<GoString>))) {
                var _x:GoString = _sign + _test;
                var _tx:Int_ = new Int_();
                _tx.setString(_x, ((0 : GoInt)));
                var __tmp__ = stdgo.encoding.xml.Xml_.marshal(Go.toInterface(_tx)), _b:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(((("marshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                    continue;
                };
                var _rx:Int_ = new Int_();
                {
                    var _err:stdgo.Error = stdgo.encoding.xml.Xml_.unmarshal(_b, Go.toInterface(_rx));
                    if (_err != null) {
                        _t.errorf(((("unmarshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp(_tx) != ((0 : GoInt))) {
                    _t.errorf(((("XML encoding of %s failed: got %s want %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_rx), Go.toInterface(_tx));
                };
            };
        };
    }
function testLinkerGC(_t:stdgo.testing.Testing.T_):Void {
        if (stdgo.testing.Testing.short()) {
            _t.skip(Go.toInterface(((("skipping in short mode" : GoString)))));
        };
        _t.parallel();
        var _tmp:GoString = _t.tempDir();
        var _goBin:GoString = stdgo.internal.testenv.Testenv.goToolPath(_t);
        var _goFile:GoString = stdgo.path.filepath.Filepath.join(_tmp, ((("x.go" : GoString))));
        var _file:Slice<GoUInt8> = (("package main\nimport _ \"math/big\"\nfunc main() {}\n" : Slice<GoByte>));
        {
            var _err:stdgo.Error = stdgo.os.Os.writeFile(_goFile, _file, ((420 : GoUInt32)));
            if (_err != null) {
                _t.fatal(Go.toInterface(_err));
            };
        };
        var _cmd:Ref<stdgo.os.exec.Exec.Cmd> = stdgo.os.exec.Exec.command(_goBin, ((("build" : GoString))), ((("-o" : GoString))), ((("x.exe" : GoString))), ((("x.go" : GoString))));
        _cmd.dir = _tmp;
        {
            var __tmp__ = _cmd.combinedOutput(), _out:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != null) {
                _t.fatalf(((("compile: %v, %s" : GoString))), Go.toInterface(_err), Go.toInterface(_out));
            };
        };
        _cmd = stdgo.os.exec.Exec.command(_goBin, ((("tool" : GoString))), ((("nm" : GoString))), ((("x.exe" : GoString))));
        _cmd.dir = _tmp;
        var __tmp__ = _cmd.combinedOutput(), _nm:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            _t.fatalf(((("nm: %v, %s" : GoString))), Go.toInterface(_err), Go.toInterface(_nm));
        };
        {};
        if (!stdgo.bytes.Bytes.contains(_nm, ((((("runtime.main" : GoString))) : Slice<GoByte>)))) {
            _t.errorf(((("expected symbol %q not found" : GoString))), Go.toInterface(((("runtime.main" : GoString)))));
        };
        var _bad:Slice<GoString> = ((new Slice<GoString>(((("math/big.(*Float)" : GoString))), ((("math/big.(*Rat)" : GoString))), ((("math/big.(*Int)" : GoString)))) : Slice<GoString>));
        for (_0 => _sym in _bad) {
            if (stdgo.bytes.Bytes.contains(_nm, ((_sym : Slice<GoByte>)))) {
                _t.errorf(((("unexpected symbol %q found" : GoString))), Go.toInterface(_sym));
            };
        };
        if (_t.failed()) {
            _t.logf(((("Got: %s" : GoString))), Go.toInterface(_nm));
        };
    }
function _basicMul(_z:T_nat, _x:T_nat, _y:T_nat):Void {
        ((_z.__slice__(((0 : GoInt)), (_x != null ? _x.length : ((0 : GoInt))) + (_y != null ? _y.length : ((0 : GoInt)))) : T_nat))._clear();
        for (_i => _d in _y) {
            if (_d != ((0 : GoUInt))) {
                if (_z != null) _z[(_x != null ? _x.length : ((0 : GoInt))) + _i] = _addMulVVW(((_z.__slice__(_i, _i + (_x != null ? _x.length : ((0 : GoInt)))) : T_nat)), _x, _d);
            };
        };
    }
function _karatsubaAdd(_z:T_nat, _x:T_nat, _n:GoInt):Void {
        {
            var _c:Word = _addVV(((_z.__slice__(((0 : GoInt)), _n) : T_nat)), _z, _x);
            if (_c != ((0 : GoUInt))) {
                _addVW(((_z.__slice__(_n, _n + (_n >> ((1 : GoUnTypedInt)))) : T_nat)), ((_z.__slice__(_n) : T_nat)), _c);
            };
        };
    }
function _karatsubaSub(_z:T_nat, _x:T_nat, _n:GoInt):Void {
        {
            var _c:Word = _subVV(((_z.__slice__(((0 : GoInt)), _n) : T_nat)), _z, _x);
            if (_c != ((0 : GoUInt))) {
                _subVW(((_z.__slice__(_n, _n + (_n >> ((1 : GoUnTypedInt)))) : T_nat)), ((_z.__slice__(_n) : T_nat)), _c);
            };
        };
    }
function _karatsuba(_z:T_nat, _x:T_nat, _y:T_nat):Void {
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if ((((_n & ((1 : GoInt))) != ((0 : GoInt))) || (_n < _karatsubaThreshold)) || (_n < ((2 : GoInt)))) {
            _basicMul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()));
            return;
        };
        var _n2:GoInt = _n >> ((1 : GoUnTypedInt));
        var _x1:T_nat = (((_x.__slice__(_n2) : T_nat)) == null ? null : ((_x.__slice__(_n2) : T_nat)).__copy__()), _x0:T_nat = (((_x.__slice__(((0 : GoInt)), _n2) : T_nat)) == null ? null : ((_x.__slice__(((0 : GoInt)), _n2) : T_nat)).__copy__());
        var _y1:T_nat = (((_y.__slice__(_n2) : T_nat)) == null ? null : ((_y.__slice__(_n2) : T_nat)).__copy__()), _y0:T_nat = (((_y.__slice__(((0 : GoInt)), _n2) : T_nat)) == null ? null : ((_y.__slice__(((0 : GoInt)), _n2) : T_nat)).__copy__());
        _karatsuba((_z == null ? null : _z.__copy__()), (_x0 == null ? null : _x0.__copy__()), (_y0 == null ? null : _y0.__copy__()));
        _karatsuba((((_z.__slice__(_n) : T_nat)) == null ? null : ((_z.__slice__(_n) : T_nat)).__copy__()), (_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__()));
        var _s:GoInt = ((1 : GoInt));
        var _xd:T_nat = (((_z.__slice__(((2 : GoInt)) * _n, (((2 : GoInt)) * _n) + _n2) : T_nat)) == null ? null : ((_z.__slice__(((2 : GoInt)) * _n, (((2 : GoInt)) * _n) + _n2) : T_nat)).__copy__());
        if (_subVV(_xd, _x1, _x0) != ((0 : GoUInt))) {
            _s = -_s;
            _subVV(_xd, _x0, _x1);
        };
        var _yd:T_nat = (((_z.__slice__((((2 : GoInt)) * _n) + _n2, ((3 : GoInt)) * _n) : T_nat)) == null ? null : ((_z.__slice__((((2 : GoInt)) * _n) + _n2, ((3 : GoInt)) * _n) : T_nat)).__copy__());
        if (_subVV(_yd, _y0, _y1) != ((0 : GoUInt))) {
            _s = -_s;
            _subVV(_yd, _y1, _y0);
        };
        var _p:T_nat = (((_z.__slice__(_n * ((3 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(_n * ((3 : GoInt))) : T_nat)).__copy__());
        _karatsuba((_p == null ? null : _p.__copy__()), (_xd == null ? null : _xd.__copy__()), (_yd == null ? null : _yd.__copy__()));
        var _r:T_nat = (((_z.__slice__(_n * ((4 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(_n * ((4 : GoInt))) : T_nat)).__copy__());
        Go.copySlice(_r, ((_z.__slice__(0, _n * ((2 : GoInt))) : T_nat)));
        _karatsubaAdd((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (_r == null ? null : _r.__copy__()), _n);
        _karatsubaAdd((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (((_r.__slice__(_n) : T_nat)) == null ? null : ((_r.__slice__(_n) : T_nat)).__copy__()), _n);
        if (_s > ((0 : GoInt))) {
            _karatsubaAdd((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (_p == null ? null : _p.__copy__()), _n);
        } else {
            _karatsubaSub((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (_p == null ? null : _p.__copy__()), _n);
        };
    }
function _alias(_x:T_nat, _y:T_nat):Bool {
        return (((_x != null ? _x.cap() : ((0 : GoInt))) > ((0 : GoInt))) && ((_y != null ? _y.cap() : ((0 : GoInt))) > ((0 : GoInt)))) && (Go.pointer((((_x.__slice__(((0 : GoInt)), (_x != null ? _x.cap() : ((0 : GoInt)))) : T_nat)) != null ? ((_x.__slice__(((0 : GoInt)), (_x != null ? _x.cap() : ((0 : GoInt)))) : T_nat))[(_x != null ? _x.cap() : ((0 : GoInt))) - ((1 : GoInt))] : new Word())) == Go.pointer((((_y.__slice__(((0 : GoInt)), (_y != null ? _y.cap() : ((0 : GoInt)))) : T_nat)) != null ? ((_y.__slice__(((0 : GoInt)), (_y != null ? _y.cap() : ((0 : GoInt)))) : T_nat))[(_y != null ? _y.cap() : ((0 : GoInt))) - ((1 : GoInt))] : new Word())));
    }
function _addAt(_z:T_nat, _x:T_nat, _i:GoInt):Void {
        {
            var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
            if (_n > ((0 : GoInt))) {
                {
                    var _c:Word = _addVV(((_z.__slice__(_i, _i + _n) : T_nat)), ((_z.__slice__(_i) : T_nat)), _x);
                    if (_c != ((0 : GoUInt))) {
                        var _j:GoInt = _i + _n;
                        if (_j < (_z != null ? _z.length : ((0 : GoInt)))) {
                            _addVW(((_z.__slice__(_j) : T_nat)), ((_z.__slice__(_j) : T_nat)), _c);
                        };
                    };
                };
            };
        };
    }
function _max(_x:GoInt, _y:GoInt):GoInt {
        if (_x > _y) {
            return _x;
        };
        return _y;
    }
function _karatsubaLen(_n:GoInt, _threshold:GoInt):GoInt {
        var _i:GoUInt = ((((0 : GoUInt)) : GoUInt));
        while (_n > _threshold) {
            _n = _n >> (((1 : GoUnTypedInt)));
            _i++;
        };
        return _n << _i;
    }
function _basicSqr(_z:T_nat, _x:T_nat):Void {
        var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _tp:Ref<T_nat> = _getNat(((2 : GoInt)) * _n);
        var _t:T_nat = (_tp == null ? null : _tp.__copy__());
        _t._clear();
        {
            var __tmp__ = _mulWW((_x != null ? _x[((0 : GoInt))] : new Word()), (_x != null ? _x[((0 : GoInt))] : new Word()));
            if (_z != null) _z[((1 : GoInt))] = __tmp__._0;
            if (_z != null) _z[((0 : GoInt))] = __tmp__._1;
        };
        {
            var _i:GoInt = ((1 : GoInt));
            Go.cfor(_i < _n, _i++, {
                var _d:Word = (_x != null ? _x[_i] : new Word());
                {
                    var __tmp__ = _mulWW(_d, _d);
                    if (_z != null) _z[(((2 : GoInt)) * _i) + ((1 : GoInt))] = __tmp__._0;
                    if (_z != null) _z[((2 : GoInt)) * _i] = __tmp__._1;
                };
                if (_t != null) _t[((2 : GoInt)) * _i] = _addMulVVW(((_t.__slice__(_i, ((2 : GoInt)) * _i) : T_nat)), ((_x.__slice__(((0 : GoInt)), _i) : T_nat)), _d);
            });
        };
        if (_t != null) _t[(((2 : GoInt)) * _n) - ((1 : GoInt))] = _shlVU(((_t.__slice__(((1 : GoInt)), (((2 : GoInt)) * _n) - ((1 : GoInt))) : T_nat)), ((_t.__slice__(((1 : GoInt)), (((2 : GoInt)) * _n) - ((1 : GoInt))) : T_nat)), ((1 : GoUInt)));
        _addVV(_z, _z, _t);
        _putNat(_tp);
    }
function _karatsubaSqr(_z:T_nat, _x:T_nat):Void {
        var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if ((((_n & ((1 : GoInt))) != ((0 : GoInt))) || (_n < _karatsubaSqrThreshold)) || (_n < ((2 : GoInt)))) {
            _basicSqr((((_z.__slice__(0, ((2 : GoInt)) * _n) : T_nat)) == null ? null : ((_z.__slice__(0, ((2 : GoInt)) * _n) : T_nat)).__copy__()), (_x == null ? null : _x.__copy__()));
            return;
        };
        var _n2:GoInt = _n >> ((1 : GoUnTypedInt));
        var _x1:T_nat = (((_x.__slice__(_n2) : T_nat)) == null ? null : ((_x.__slice__(_n2) : T_nat)).__copy__()), _x0:T_nat = (((_x.__slice__(((0 : GoInt)), _n2) : T_nat)) == null ? null : ((_x.__slice__(((0 : GoInt)), _n2) : T_nat)).__copy__());
        _karatsubaSqr((_z == null ? null : _z.__copy__()), (_x0 == null ? null : _x0.__copy__()));
        _karatsubaSqr((((_z.__slice__(_n) : T_nat)) == null ? null : ((_z.__slice__(_n) : T_nat)).__copy__()), (_x1 == null ? null : _x1.__copy__()));
        var _xd:T_nat = (((_z.__slice__(((2 : GoInt)) * _n, (((2 : GoInt)) * _n) + _n2) : T_nat)) == null ? null : ((_z.__slice__(((2 : GoInt)) * _n, (((2 : GoInt)) * _n) + _n2) : T_nat)).__copy__());
        if (_subVV(_xd, _x1, _x0) != ((0 : GoUInt))) {
            _subVV(_xd, _x0, _x1);
        };
        var _p:T_nat = (((_z.__slice__(_n * ((3 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(_n * ((3 : GoInt))) : T_nat)).__copy__());
        _karatsubaSqr((_p == null ? null : _p.__copy__()), (_xd == null ? null : _xd.__copy__()));
        var _r:T_nat = (((_z.__slice__(_n * ((4 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(_n * ((4 : GoInt))) : T_nat)).__copy__());
        Go.copySlice(_r, ((_z.__slice__(0, _n * ((2 : GoInt))) : T_nat)));
        _karatsubaAdd((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (_r == null ? null : _r.__copy__()), _n);
        _karatsubaAdd((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (((_r.__slice__(_n) : T_nat)) == null ? null : ((_r.__slice__(_n) : T_nat)).__copy__()), _n);
        _karatsubaSub((((_z.__slice__(_n2) : T_nat)) == null ? null : ((_z.__slice__(_n2) : T_nat)).__copy__()), (_p == null ? null : _p.__copy__()), _n);
    }
function _getNat(_n:GoInt):T_nat {
        var _z:T_nat = ((null : Ref<T_nat>));
        {
            var _v:AnyInterface = Go.toInterface(_natPool.get());
            if (_v != null) {
                _z = ((((_v.value : Dynamic)).__t__ : T_nat));
            };
        };
        if (_z == null) {
            _z = new T_nat();
        };
        _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
        return _z;
    }
function _putNat(_x:T_nat):Void {
        _natPool.put(Go.toInterface(_x));
    }
function _same(_x:T_nat, _y:T_nat):Bool {
        return (((_x != null ? _x.length : ((0 : GoInt))) == (_y != null ? _y.length : ((0 : GoInt)))) && ((_x != null ? _x.length : ((0 : GoInt))) > ((0 : GoInt)))) && (Go.pointer((_x != null ? _x[((0 : GoInt))] : new Word())) == Go.pointer((_y != null ? _y[((0 : GoInt))] : new Word())));
    }
function _bigEndianWord(_buf:Slice<GoByte>):Word {
        if (false) {
            return ((stdgo.encoding.binary.Binary.bigEndian.uint64(_buf) : Word));
        };
        return ((stdgo.encoding.binary.Binary.bigEndian.uint32(_buf) : Word));
    }
function testCmp(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _a in _cmpTests) {
            var _r:GoInt = _a._x._cmp((_a._y == null ? null : _a._y.__copy__()));
            if (_r != _a._r) {
                _t.errorf(((("#%d got r = %v; want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_r), Go.toInterface(_a._r));
            };
        };
    }
function _natFromString(_s:GoString):T_nat {
        var __tmp__ = ((new T_nat() : T_nat))._scan(stdgo.strings.Strings.newReader(_s), ((0 : GoInt)), false), _x:T_nat = __tmp__._0, _0:GoInt = __tmp__._1, _1:GoInt = __tmp__._2, _err:stdgo.Error = __tmp__._3;
        if (_err != null) {
            throw Go.toInterface(_err);
        };
        return (_x == null ? null : _x.__copy__());
    }
function testSet(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _sumNN) {
            var _z:T_nat = (((new T_nat() : T_nat))._set((_a._z == null ? null : _a._z.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_a._z == null ? null : _a._z.__copy__())).__copy__());
            if (_z._cmp((_a._z == null ? null : _a._z.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("got z = %v; want %v" : GoString))), Go.toInterface(_z), Go.toInterface(_a._z));
            };
        };
    }
function _testFunNN(_t:stdgo.testing.Testing.T_, _msg:GoString, _f:T_funNN, _a:T_argNN):Void {
        var _z:T_nat = (_f(null, _a._x, _a._y) == null ? null : _f(null, _a._x, _a._y).__copy__());
        if (_z._cmp((_a._z == null ? null : _a._z.__copy__())) != ((0 : GoInt))) {
            _t.errorf(((("%s%+v\n\tgot z = %v; want %v" : GoString))), Go.toInterface(_msg), Go.toInterface(_a), Go.toInterface(_z), Go.toInterface(_a._z));
        };
    }
function testFunNN(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _sumNN) {
            var _arg:T_argNN = (_a == null ? null : _a.__copy__());
            _testFunNN(_t, ((("add" : GoString))), T_nat_static_extension._add, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argNN((_a._z == null ? null : _a._z.__copy__()), (_a._y == null ? null : _a._y.__copy__()), (_a._x == null ? null : _a._x.__copy__())) : T_argNN));
            _testFunNN(_t, ((("add symmetric" : GoString))), T_nat_static_extension._add, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argNN((_a._x == null ? null : _a._x.__copy__()), (_a._z == null ? null : _a._z.__copy__()), (_a._y == null ? null : _a._y.__copy__())) : T_argNN));
            _testFunNN(_t, ((("sub" : GoString))), T_nat_static_extension._sub, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argNN((_a._y == null ? null : _a._y.__copy__()), (_a._z == null ? null : _a._z.__copy__()), (_a._x == null ? null : _a._x.__copy__())) : T_argNN));
            _testFunNN(_t, ((("sub symmetric" : GoString))), T_nat_static_extension._sub, (_arg == null ? null : _arg.__copy__()));
        };
        for (_1 => _a in _prodNN) {
            var _arg:T_argNN = (_a == null ? null : _a.__copy__());
            _testFunNN(_t, ((("mul" : GoString))), T_nat_static_extension._mul, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_argNN((_a._z == null ? null : _a._z.__copy__()), (_a._y == null ? null : _a._y.__copy__()), (_a._x == null ? null : _a._x.__copy__())) : T_argNN));
            _testFunNN(_t, ((("mul symmetric" : GoString))), T_nat_static_extension._mul, (_arg == null ? null : _arg.__copy__()));
        };
    }
function testMulRangeN(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _r in _mulRangesN) {
            var _prod:GoString = ((((new T_nat() : T_nat))._mulRange(_r._a, _r._b)._utoa(((10 : GoInt))) : GoString));
            if (_prod != _r._prod) {
                _t.errorf(((("#%d: got %s; want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_prod), Go.toInterface(_r._prod));
            };
        };
    }
function _allocBytes(_f:() -> Void):GoUInt64 {
        var _stats:stdgo.runtime.Runtime.MemStats = new stdgo.runtime.Runtime.MemStats();
        stdgo.runtime.Runtime.readMemStats(_stats);
        var _t:GoUInt64 = _stats.totalAlloc;
        _f();
        stdgo.runtime.Runtime.readMemStats(_stats);
        return _stats.totalAlloc - _t;
    }
function testMulUnbalanced(_t:stdgo.testing.Testing.T_):Void {
        var __recover_exception__:AnyInterface = null;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            {
                var _a0 = stdgo.runtime.Runtime.gomaxprocs(((1 : GoInt)));
                __deferstack__.unshift(() -> stdgo.runtime.Runtime.gomaxprocs(_a0));
            };
            var _x:T_nat = (_rndNat(((50000 : GoInt))) == null ? null : _rndNat(((50000 : GoInt))).__copy__());
            var _y:T_nat = (_rndNat(((40 : GoInt))) == null ? null : _rndNat(((40 : GoInt))).__copy__());
            var _allocSize:GoUInt64 = _allocBytes(function():Void {
                ((new T_nat() : T_nat))._mul((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()));
            });
            var _inputSize:GoUInt64 = ((((_x != null ? _x.length : ((0 : GoInt))) + (_y != null ? _y.length : ((0 : GoInt)))) : GoUInt64)) * ((4 : GoUInt64));
            {
                var _ratio:GoUInt64 = _allocSize / ((_inputSize : GoUInt64));
                if (_ratio > ((10 : GoUInt64))) {
                    _t.errorf(((("multiplication uses too much memory (%d > %d times the size of inputs)" : GoString))), Go.toInterface(_allocSize), Go.toInterface(_ratio));
                };
            };
            for (defer in __deferstack__) {
                defer();
            };
        } catch(__exception__) {
            if (!(__exception__.native is AnyInterfaceData)) throw __exception__;
            __recover_exception__ = __exception__.native;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (__recover_exception__ != null) throw __recover_exception__;
                return;
            };
        };
    }
function _rndNat(_n:GoInt):T_nat {
        return (((_rndV(_n) : T_nat))._norm() == null ? null : ((_rndV(_n) : T_nat))._norm().__copy__());
    }
function _rndNat1(_n:GoInt):T_nat {
        var _x:T_nat = (((_rndV(_n) : T_nat))._norm() == null ? null : ((_rndV(_n) : T_nat))._norm().__copy__());
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _x._setWord(((1 : GoUInt)));
        };
        return (_x == null ? null : _x.__copy__());
    }
function benchmarkMul(_b:stdgo.testing.Testing.B):Void {
        var _mulx:T_nat = (_rndNat(((10000 : GoInt))) == null ? null : _rndNat(((10000 : GoInt))).__copy__());
        var _muly:T_nat = (_rndNat(((10000 : GoInt))) == null ? null : _rndNat(((10000 : GoInt))).__copy__());
        _b.resetTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                var _z:T_nat = new T_nat();
                _z._mul((_mulx == null ? null : _mulx.__copy__()), (_muly == null ? null : _muly.__copy__()));
            });
        };
    }
function _benchmarkNatMul(_b:stdgo.testing.Testing.B, _nwords:GoInt):Void {
        var _x:T_nat = (_rndNat(_nwords) == null ? null : _rndNat(_nwords).__copy__());
        var _y:T_nat = (_rndNat(_nwords) == null ? null : _rndNat(_nwords).__copy__());
        var _z:T_nat = new T_nat();
        _b.resetTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _z._mul((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()));
            });
        };
    }
function benchmarkNatMul(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _mulBenchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            _b.run(stdgo.fmt.Fmt.sprintf(((("%d" : GoString))), Go.toInterface(_n)), function(_b:stdgo.testing.Testing.B):Void {
                _benchmarkNatMul(_b, _n);
            });
        };
    }
function testNLZ(_t:stdgo.testing.Testing.T_):Void {
        var _x:Word = (("2147483648" : GoUInt));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i <= ((32 : GoInt)), _i++, {
                if (((_nlz(_x) : GoInt)) != _i) {
                    _t.errorf(((("failed at %x: got %d want %d" : GoString))), Go.toInterface(_x), Go.toInterface(_nlz(_x)), Go.toInterface(_i));
                };
                _x = _x >> (((1 : GoUnTypedInt)));
            });
        };
    }
function testShiftLeft(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _leftShiftTests) {
            var _z:T_nat = new T_nat();
            _z = (_z._shl((_test._in == null ? null : _test._in.__copy__()), _test._shift) == null ? null : _z._shl((_test._in == null ? null : _test._in.__copy__()), _test._shift).__copy__());
            for (_j => _d in _test._out) {
                if ((_j >= (_z != null ? _z.length : ((0 : GoInt)))) || ((_z != null ? _z[_j] : new Word()) != _d)) {
                    _t.errorf(((("#%d: got: %v want: %v" : GoString))), Go.toInterface(_i), Go.toInterface(_z), Go.toInterface(_test._out));
                    break;
                };
            };
        };
    }
function testShiftRight(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _rightShiftTests) {
            var _z:T_nat = new T_nat();
            _z = (_z._shr((_test._in == null ? null : _test._in.__copy__()), _test._shift) == null ? null : _z._shr((_test._in == null ? null : _test._in.__copy__()), _test._shift).__copy__());
            for (_j => _d in _test._out) {
                if ((_j >= (_z != null ? _z.length : ((0 : GoInt)))) || ((_z != null ? _z[_j] : new Word()) != _d)) {
                    _t.errorf(((("#%d: got: %v want: %v" : GoString))), Go.toInterface(_i), Go.toInterface(_z), Go.toInterface(_test._out));
                    break;
                };
            };
        };
    }
function benchmarkZeroShifts(_b:stdgo.testing.Testing.B):Void {
        var _x:T_nat = (_rndNat(((800 : GoInt))) == null ? null : _rndNat(((800 : GoInt))).__copy__());
        _b.run(((("Shl" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _b.n, _i++, {
                    var _z:T_nat = new T_nat();
                    _z._shl((_x == null ? null : _x.__copy__()), ((0 : GoUInt)));
                });
            };
        });
        _b.run(((("ShlSame" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _b.n, _i++, {
                    _x._shl((_x == null ? null : _x.__copy__()), ((0 : GoUInt)));
                });
            };
        });
        _b.run(((("Shr" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _b.n, _i++, {
                    var _z:T_nat = new T_nat();
                    _z._shr((_x == null ? null : _x.__copy__()), ((0 : GoUInt)));
                });
            };
        });
        _b.run(((("ShrSame" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _b.n, _i++, {
                    _x._shr((_x == null ? null : _x.__copy__()), ((0 : GoUInt)));
                });
            };
        });
    }
function _runModWTests(_t:stdgo.testing.Testing.T_, _tests:Slice<T_modWTest>):Void {
        for (_i => _test in _tests) {
            var __tmp__ = new Int_().setString(_test._in, ((10 : GoInt))), _in:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._dividend, ((10 : GoInt))), _d:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            var __tmp__ = new Int_().setString(_test._out, ((10 : GoInt))), _out:Ref<Int_> = __tmp__._0, _2:Bool = __tmp__._1;
            var _r:Word = _in._abs._modW((_d._abs != null ? _d._abs[((0 : GoInt))] : new Word()));
            if (_r != (_out._abs != null ? _out._abs[((0 : GoInt))] : new Word())) {
                _t.errorf(((("#%d failed: got %d want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_r), Go.toInterface(_out));
            };
        };
    }
function testModW(_t:stdgo.testing.Testing.T_):Void {
        if (true) {
            _runModWTests(_t, _modWTests32);
        };
        if (false) {
            _runModWTests(_t, _modWTests64);
        };
    }
function testMontgomery(_t:stdgo.testing.Testing.T_):Void {
        var _one:Ref<Int_> = newInt(((1 : GoInt64)));
        var __B:Ref<Int_> = new Int_().lsh(_one, ((32 : GoUInt)));
        for (_i => _test in _montgomeryTests) {
            var _x:T_nat = (_natFromString(_test._x) == null ? null : _natFromString(_test._x).__copy__());
            var _y:T_nat = (_natFromString(_test._y) == null ? null : _natFromString(_test._y).__copy__());
            var _m:T_nat = (_natFromString(_test._m) == null ? null : _natFromString(_test._m).__copy__());
            while ((_x != null ? _x.length : ((0 : GoInt))) < (_m != null ? _m.length : ((0 : GoInt)))) {
                _x = ((_x != null ? _x.__append__(((0 : GoUInt))) : new Slice<Slice<Word>>(((0 : GoUInt)))) == null ? null : (_x != null ? _x.__append__(((0 : GoUInt))) : new Slice<Slice<Word>>(((0 : GoUInt)))).__copy__());
            };
            while ((_y != null ? _y.length : ((0 : GoInt))) < (_m != null ? _m.length : ((0 : GoInt)))) {
                _y = ((_y != null ? _y.__append__(((0 : GoUInt))) : new Slice<Slice<Word>>(((0 : GoUInt)))) == null ? null : (_y != null ? _y.__append__(((0 : GoUInt))) : new Slice<Slice<Word>>(((0 : GoUInt)))).__copy__());
            };
            if (_x._cmp((_m == null ? null : _m.__copy__())) > ((0 : GoInt))) {
                var __tmp__ = ((new T_nat() : T_nat))._div(null, (_x == null ? null : _x.__copy__()), (_m == null ? null : _m.__copy__())), _0:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
                _t.errorf(((("#%d: x > m (0x%s > 0x%s; use 0x%s)" : GoString))), Go.toInterface(_i), Go.toInterface(_x._utoa(((16 : GoInt)))), Go.toInterface(_m._utoa(((16 : GoInt)))), Go.toInterface(_r._utoa(((16 : GoInt)))));
            };
            if (_y._cmp((_m == null ? null : _m.__copy__())) > ((0 : GoInt))) {
                var __tmp__ = ((new T_nat() : T_nat))._div(null, (_x == null ? null : _x.__copy__()), (_m == null ? null : _m.__copy__())), _1:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
                _t.errorf(((("#%d: y > m (0x%s > 0x%s; use 0x%s)" : GoString))), Go.toInterface(_i), Go.toInterface(_y._utoa(((16 : GoInt)))), Go.toInterface(_m._utoa(((16 : GoInt)))), Go.toInterface(_r._utoa(((16 : GoInt)))));
            };
            var _out:T_nat = new T_nat();
            if (true) {
                _out = (_natFromString(_test._out32) == null ? null : _natFromString(_test._out32).__copy__());
            } else {
                _out = (_natFromString(_test._out64) == null ? null : _natFromString(_test._out64).__copy__());
            };
            var _xi:Ref<Int_> = (({ _abs : (_x == null ? null : _x.__copy__()), _neg : false } : Int_));
            var _yi:Ref<Int_> = (({ _abs : (_y == null ? null : _y.__copy__()), _neg : false } : Int_));
            var _mi:Ref<Int_> = (({ _abs : (_m == null ? null : _m.__copy__()), _neg : false } : Int_));
            var _p:Ref<Int_> = new Int_().mod(new Int_().mul(_xi, new Int_().mul(_yi, new Int_().modInverse(new Int_().lsh(_one, (((_m != null ? _m.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))), _mi))), _mi);
            if (_out._cmp((_p._abs._norm() == null ? null : _p._abs._norm().__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("#%d: out in table=0x%s, computed=0x%s" : GoString))), Go.toInterface(_i), Go.toInterface(_out._utoa(((16 : GoInt)))), Go.toInterface(_p._abs._norm()._utoa(((16 : GoInt)))));
            };
            var _k:Ref<Int_> = new Int_().mod((({ _abs : (_m == null ? null : _m.__copy__()), _neg : false } : Int_)), __B);
            _k = new Int_().sub(__B, _k);
            _k = new Int_().mod(_k, __B);
            var _k0:Word = ((new Int_().modInverse(_k, __B).uint64() : Word));
            if (_k0 != ((_test._k0 : Word))) {
                _t.errorf(((("#%d: k0 in table=%#x, computed=%#x\n" : GoString))), Go.toInterface(_i), Go.toInterface(_test._k0), Go.toInterface(_k0));
            };
            var _z:T_nat = (((new T_nat() : T_nat))._montgomery((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__()), _k0, (_m != null ? _m.length : ((0 : GoInt)))) == null ? null : ((new T_nat() : T_nat))._montgomery((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__()), _k0, (_m != null ? _m.length : ((0 : GoInt)))).__copy__());
            _z = (_z._norm() == null ? null : _z._norm().__copy__());
            if (_z._cmp((_out == null ? null : _out.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("#%d: got 0x%s want 0x%s" : GoString))), Go.toInterface(_i), Go.toInterface(_z._utoa(((16 : GoInt)))), Go.toInterface(_out._utoa(((16 : GoInt)))));
            };
        };
    }
function testExpNN(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _expNNTests) {
            var _x:T_nat = (_natFromString(_test._x) == null ? null : _natFromString(_test._x).__copy__());
            var _y:T_nat = (_natFromString(_test._y) == null ? null : _natFromString(_test._y).__copy__());
            var _out:T_nat = (_natFromString(_test._out) == null ? null : _natFromString(_test._out).__copy__());
            var _m:T_nat = new T_nat();
            if ((_test._m != null ? _test._m.length : ((0 : GoInt))) > ((0 : GoInt))) {
                _m = (_natFromString(_test._m) == null ? null : _natFromString(_test._m).__copy__());
            };
            var _z:T_nat = (((new T_nat() : T_nat))._expNN((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : ((new T_nat() : T_nat))._expNN((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
            if (_z._cmp((_out == null ? null : _out.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("#%d got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_z._utoa(((10 : GoInt)))), Go.toInterface(_out._utoa(((10 : GoInt)))));
            };
        };
    }
function benchmarkExp3Power(_b:stdgo.testing.Testing.B):Void {
        {};
        for (_0 => _y in ((new Slice<Word>(((16 : GoUInt)), ((64 : GoUInt)), ((256 : GoUInt)), ((1024 : GoUInt)), ((4096 : GoUInt)), ((16384 : GoUInt)), ((65536 : GoUInt)), ((262144 : GoUInt)), ((1048576 : GoUInt)), ((4194304 : GoUInt))) : Slice<Word>))) {
            _b.run(stdgo.fmt.Fmt.sprintf(((("%#x" : GoString))), Go.toInterface(_y)), function(_b:stdgo.testing.Testing.B):Void {
                var _z:T_nat = new T_nat();
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _z._expWW(((3 : GoUInt)), _y);
                    });
                };
            });
        };
    }
function _fibo(_n:GoInt):T_nat {
        if (_n == ((0 : GoInt))) {
            return null;
        } else if (_n == ((1 : GoInt))) {
            return ((new Slice<Word>(((1 : GoUInt))) : T_nat));
        };
        var _f0:T_nat = (_fibo(((0 : GoInt))) == null ? null : _fibo(((0 : GoInt))).__copy__());
        var _f1:T_nat = (_fibo(((1 : GoInt))) == null ? null : _fibo(((1 : GoInt))).__copy__());
        var _f2:T_nat = new T_nat();
        {
            var _i:GoInt = ((1 : GoInt));
            Go.cfor(_i < _n, _i++, {
                _f2 = (_f2._add((_f0 == null ? null : _f0.__copy__()), (_f1 == null ? null : _f1.__copy__())) == null ? null : _f2._add((_f0 == null ? null : _f0.__copy__()), (_f1 == null ? null : _f1.__copy__())).__copy__());
                {
                    final __tmp__0 = (_f1 == null ? null : _f1.__copy__());
                    final __tmp__1 = (_f2 == null ? null : _f2.__copy__());
                    final __tmp__2 = (_f0 == null ? null : _f0.__copy__());
                    _f0 = __tmp__0;
                    _f1 = __tmp__1;
                    _f2 = __tmp__2;
                };
            });
        };
        return (_f1 == null ? null : _f1.__copy__());
    }
function testFibo(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _want in _fiboNums) {
            var _n:GoInt = _i * ((10 : GoInt));
            var _got:GoString = ((_fibo(_n)._utoa(((10 : GoInt))) : GoString));
            if (_got != _want) {
                _t.errorf(((("fibo(%d) failed: got %s want %s" : GoString))), Go.toInterface(_n), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function benchmarkFibo(_b:stdgo.testing.Testing.B):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _fibo(((1 : GoInt)));
                _fibo(((10 : GoInt)));
                _fibo(((100 : GoInt)));
                _fibo(((1000 : GoInt)));
                _fibo(((10000 : GoInt)));
                _fibo(((100000 : GoInt)));
            });
        };
    }
function testBit(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _bitTests) {
            var _x:T_nat = (_natFromString(_test._x) == null ? null : _natFromString(_test._x).__copy__());
            {
                var _got:GoUInt = _x._bit(_test._i);
                if (_got != _test._want) {
                    _t.errorf(((("#%d: %s.bit(%d) = %v; want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._i), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
        };
    }
function testSticky(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _stickyTests) {
            var _x:T_nat = (_natFromString(_test._x) == null ? null : _natFromString(_test._x).__copy__());
            {
                var _got:GoUInt = _x._sticky(_test._i);
                if (_got != _test._want) {
                    _t.errorf(((("#%d: %s.sticky(%d) = %v; want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._i), Go.toInterface(_got), Go.toInterface(_test._want));
                };
            };
            if (_test._want == ((1 : GoUInt))) {
                {
                    var _d:GoUInt = ((((1 : GoUInt)) : GoUInt));
                    Go.cfor(_d <= ((3 : GoUInt)), _d++, {
                        {
                            var _got:GoUInt = _x._sticky(_test._i + _d);
                            if (_got != ((1 : GoUInt))) {
                                _t.errorf(((("#%d: %s.sticky(%d) = %v; want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_test._x), Go.toInterface(_test._i + _d), Go.toInterface(_got), Go.toInterface(((1 : GoInt))));
                            };
                        };
                    });
                };
            };
        };
    }
function _testSqr(_t:stdgo.testing.Testing.T_, _x:T_nat):Void {
        var _got:T_nat = new Slice<Word>(...[for (i in 0 ... ((((2 : GoInt)) * (_x != null ? _x.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        var _want:T_nat = new Slice<Word>(...[for (i in 0 ... ((((2 : GoInt)) * (_x != null ? _x.length : ((0 : GoInt))) : GoInt)).toBasic()) new Word()]);
        _got = (_got._sqr((_x == null ? null : _x.__copy__())) == null ? null : _got._sqr((_x == null ? null : _x.__copy__())).__copy__());
        _want = (_want._mul((_x == null ? null : _x.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _want._mul((_x == null ? null : _x.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
        if (_got._cmp((_want == null ? null : _want.__copy__())) != ((0 : GoInt))) {
            _t.errorf(((("basicSqr(%v), got %v, want %v" : GoString))), Go.toInterface(_x), Go.toInterface(_got), Go.toInterface(_want));
        };
    }
function testSqr(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _prodNN) {
            if (_a._x != null) {
                _testSqr(_t, (_a._x == null ? null : _a._x.__copy__()));
            };
            if (_a._y != null) {
                _testSqr(_t, (_a._y == null ? null : _a._y.__copy__()));
            };
            if (_a._z != null) {
                _testSqr(_t, (_a._z == null ? null : _a._z.__copy__()));
            };
        };
    }
function _benchmarkNatSqr(_b:stdgo.testing.Testing.B, _nwords:GoInt):Void {
        var _x:T_nat = (_rndNat(_nwords) == null ? null : _rndNat(_nwords).__copy__());
        var _z:T_nat = new T_nat();
        _b.resetTimer();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _z._sqr((_x == null ? null : _x.__copy__()));
            });
        };
    }
function benchmarkNatSqr(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _n in _sqrBenchSizes) {
            if (_isRaceBuilder && (_n > ((1000 : GoInt)))) {
                continue;
            };
            _b.run(stdgo.fmt.Fmt.sprintf(((("%d" : GoString))), Go.toInterface(_n)), function(_b:stdgo.testing.Testing.B):Void {
                _benchmarkNatSqr(_b, _n);
            });
        };
    }
function benchmarkNatSetBytes(_b:stdgo.testing.Testing.B):Void {
        {};
        var _lengths:Slice<GoInt> = ((new Slice<GoInt>(((8 : GoInt)), ((24 : GoInt)), ((128 : GoInt)), ((7 : GoInt)), ((23 : GoInt)), ((127 : GoInt))) : Slice<GoInt>));
        var _n:T_nat = new Slice<Word>(...[for (i in 0 ... ((((4 : GoInt)) : GoInt)).toBasic()) new Word()]);
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((128 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        for (_0 => _l in _lengths) {
            _b.run(stdgo.fmt.Fmt.sprint(_l), function(_b:stdgo.testing.Testing.B):Void {
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _n._setBytes(((_buf.__slice__(0, _l) : Slice<GoUInt8>)));
                    });
                };
            });
        };
    }
function testNatDiv(_t:stdgo.testing.Testing.T_):Void {
        var _sizes:Slice<GoInt> = ((new Slice<GoInt>(
((1 : GoInt)),
((2 : GoInt)),
((5 : GoInt)),
((8 : GoInt)),
((15 : GoInt)),
((25 : GoInt)),
((40 : GoInt)),
((65 : GoInt)),
((100 : GoInt)),
((200 : GoInt)),
((500 : GoInt)),
((800 : GoInt)),
((1500 : GoInt)),
((2500 : GoInt)),
((4000 : GoInt)),
((6500 : GoInt)),
((10000 : GoInt))) : Slice<GoInt>));
        for (_0 => _i in _sizes) {
            for (_1 => _j in _sizes) {
                var _a:T_nat = (_rndNat1(_i) == null ? null : _rndNat1(_i).__copy__());
                var _b:T_nat = (_rndNat1(_j) == null ? null : _rndNat1(_j).__copy__());
                if (((_b != null ? _b.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_b != null ? _b[((0 : GoInt))] : new Word()) == ((1 : GoUInt)))) {
                    if (_b != null) _b[((0 : GoInt))] = ((2 : GoUInt));
                };
                var _c:T_nat = (_rndNat1((_b != null ? _b.length : ((0 : GoInt)))) == null ? null : _rndNat1((_b != null ? _b.length : ((0 : GoInt)))).__copy__());
                if (((_c != null ? _c.length : ((0 : GoInt))) == (_b != null ? _b.length : ((0 : GoInt)))) && ((_c != null ? _c[(_c != null ? _c.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) >= (_b != null ? _b[(_b != null ? _b.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()))) {
                    if (_c != null) _c[(_c != null ? _c.length : ((0 : GoInt))) - ((1 : GoInt))] = ((0 : GoUInt));
                    _c = (_c._norm() == null ? null : _c._norm().__copy__());
                };
                var _x:T_nat = (((new T_nat() : T_nat))._mul((_a == null ? null : _a.__copy__()), (_b == null ? null : _b.__copy__())) == null ? null : ((new T_nat() : T_nat))._mul((_a == null ? null : _a.__copy__()), (_b == null ? null : _b.__copy__())).__copy__());
                _x = (_x._add((_x == null ? null : _x.__copy__()), (_c == null ? null : _c.__copy__())) == null ? null : _x._add((_x == null ? null : _x.__copy__()), (_c == null ? null : _c.__copy__())).__copy__());
                var _q:T_nat = new T_nat(), _r:T_nat = new T_nat();
                {
                    var __tmp__ = _q._div((_r == null ? null : _r.__copy__()), (_x == null ? null : _x.__copy__()), (_b == null ? null : _b.__copy__()));
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                if (_q._cmp((_a == null ? null : _a.__copy__())) != ((0 : GoInt))) {
                    _t.fatalf(((("wrong quotient: got %s; want %s for %s/%s" : GoString))), Go.toInterface(_q._utoa(((10 : GoInt)))), Go.toInterface(_a._utoa(((10 : GoInt)))), Go.toInterface(_x._utoa(((10 : GoInt)))), Go.toInterface(_b._utoa(((10 : GoInt)))));
                };
                if (_r._cmp((_c == null ? null : _c.__copy__())) != ((0 : GoInt))) {
                    _t.fatalf(((("wrong remainder: got %s; want %s for %s/%s" : GoString))), Go.toInterface(_r._utoa(((10 : GoInt)))), Go.toInterface(_c._utoa(((10 : GoInt)))), Go.toInterface(_x._utoa(((10 : GoInt)))), Go.toInterface(_b._utoa(((10 : GoInt)))));
                };
            };
        };
    }
function testIssue37499(_t:stdgo.testing.Testing.T_):Void {
        var _u:T_nat = (_natFromString(((("0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706b39f8489c1d28e57bb5ba4ef9fd9387a3e344402c0a453381" : GoString)))) == null ? null : _natFromString(((("0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706b39f8489c1d28e57bb5ba4ef9fd9387a3e344402c0a453381" : GoString)))).__copy__());
        var _v:T_nat = (_natFromString(((("0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706c" : GoString)))) == null ? null : _natFromString(((("0x2b6c385a05be027f5c22005b63c42a1165b79ff510e1706c" : GoString)))).__copy__());
        var _q:T_nat = (((new T_nat() : T_nat))._make(((8 : GoInt))) == null ? null : ((new T_nat() : T_nat))._make(((8 : GoInt))).__copy__());
        _q._divBasic((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
        _q = (_q._norm() == null ? null : _q._norm().__copy__());
        {
            var _s:GoString = ((_q._utoa(((16 : GoInt))) : GoString));
            if (_s != ((("fffffffffffffffffffffffffffffffffffffffffffffffb" : GoString)))) {
                _t.fatalf(((("incorrect quotient: %s" : GoString))), Go.toInterface(_s));
            };
        };
    }
function testIssue42552(_t:stdgo.testing.Testing.T_):Void {
        var _u:T_nat = (_natFromString(((("0xc23b166884c3869092a520eceedeced2b00847bd256c9cf3b2c5e2227c15bd5e6ee7ef8a2f49236ad0eedf2c8a3b453cf6e0706f64285c526b372c4b1321245519d430540804a50b7ca8b6f1b34a2ec05cdbc24de7599af112d3e3c8db347e8799fe70f16e43c6566ba3aeb169463a3ecc486172deb2d9b80a3699c776e44fef20036bd946f1b4d054dd88a2c1aeb986199b0b2b7e58c42288824b74934d112fe1fc06e06b4d99fe1c5e725946b23210521e209cd507cce90b5f39a523f27e861f9e232aee50c3f585208b4573dcc0b897b6177f2ba20254fd5c50a033e849dee1b3a93bd2dc44ba8ca836cab2c2ae50e50b126284524fa0187af28628ff0face68d87709200329db1392852c8b8963fbe3d05fb1efe19f0ed5ca9fadc2f96f82187c24bb2512b2e85a66333a7e176605695211e1c8e0b9b9e82813e50654964945b1e1e66a90840396c7d10e23e47f364d2d3f660fa54598e18d1ca2ea4fe4f35a40a11f69f201c80b48eaee3e2e9b0eda63decf92bec08a70f731587d4ed0f218d5929285c8b2ccbc497e20db42de73885191fa453350335990184d8df805072f958d5354debda38f5421effaaafd6cb9b721ace74be0892d77679f62a4a126697cd35797f6858193da4ba1770c06aea2e5c59ec04b8ea26749e61b72ecdde403f3bc7e5e546cd799578cc939fa676dfd5e648576d4a06cbadb028adc2c0b461f145b2321f42e5e0f3b4fb898ecd461df07a6f5154067787bf74b5cc5c03704a1ce47494961931f0263b0aac32505102595957531a2de69dd71aac51f8a49902f81f21283dbe8e21e01e5d82517868826f86acf338d935aa6b4d5a25c8d540389b277dd9d64569d68baf0f71bd03dba45b92a7fc052601d1bd011a2fc6790a23f97c6fa5caeea040ab86841f268d39ce4f7caf01069df78bba098e04366492f0c2ac24f1bf16828752765fa523c9a4d42b71109d123e6be8c7b1ab3ccf8ea03404075fe1a9596f1bba1d267f9a7879ceece514818316c9c0583469d2367831fc42b517ea028a28df7c18d783d16ea2436cee2b15d52db68b5dfdee6b4d26f0905f9b030c911a04d078923a4136afea96eed6874462a482917353264cc9bee298f167ac65a6db4e4eda88044b39cc0b33183843eaa946564a00c3a0ab661f2c915e70bf0bb65bfbb6fa2eea20aed16bf2c1a1d00ec55fb4ff2f76b8e462ea70c19efa579c9ee78194b86708fdae66a9ce6e2cf3d366037798cfb50277ba6d2fd4866361022fd788ab7735b40b8b61d55e32243e06719e53992e9ac16c9c4b6e6933635c3c47c8f7e73e17dd54d0dd8aeba5d76de46894e7b3f9d3ec25ad78ee82297ba69905ea0fa094b8667faa2b8885e2187b3da80268aa1164761d7b0d6de206b676777348152b8ae1d4afed753bc63c739a5ca8ce7afb2b241a226bd9e502baba391b5b13f5054f070b65a9cf3a67063bfaa803ba390732cd03888f664023f888741d04d564e0b5674b0a183ace81452001b3fbb4214c77d42ca75376742c471e58f67307726d56a1032bd236610cbcbcd03d0d7a452900136897dc55bb3ce959d10d4e6a10fb635006bd8c41cd9ded2d3dfdd8f2e229590324a7370cb2124210b2330f4c56155caa09a2564932ceded8d92c79664dcdeb87faad7d3da006cc2ea267ee3df41e9677789cc5a8cc3b83add6491561b3047919e0648b1b2e97d7ad6f6c2aa80cab8e9ae10e1f75b1fdd0246151af709d259a6a0ed0b26bd711024965ecad7c41387de45443defce53f66612948694a6032279131c257119ed876a8e805dfb49576ef5c563574115ee87050d92d191bc761ef51d966918e2ef925639400069e3959d8fe19f36136e947ff430bf74e71da0aa5923b00000000" : GoString)))) == null ? null : _natFromString(((("0xc23b166884c3869092a520eceedeced2b00847bd256c9cf3b2c5e2227c15bd5e6ee7ef8a2f49236ad0eedf2c8a3b453cf6e0706f64285c526b372c4b1321245519d430540804a50b7ca8b6f1b34a2ec05cdbc24de7599af112d3e3c8db347e8799fe70f16e43c6566ba3aeb169463a3ecc486172deb2d9b80a3699c776e44fef20036bd946f1b4d054dd88a2c1aeb986199b0b2b7e58c42288824b74934d112fe1fc06e06b4d99fe1c5e725946b23210521e209cd507cce90b5f39a523f27e861f9e232aee50c3f585208b4573dcc0b897b6177f2ba20254fd5c50a033e849dee1b3a93bd2dc44ba8ca836cab2c2ae50e50b126284524fa0187af28628ff0face68d87709200329db1392852c8b8963fbe3d05fb1efe19f0ed5ca9fadc2f96f82187c24bb2512b2e85a66333a7e176605695211e1c8e0b9b9e82813e50654964945b1e1e66a90840396c7d10e23e47f364d2d3f660fa54598e18d1ca2ea4fe4f35a40a11f69f201c80b48eaee3e2e9b0eda63decf92bec08a70f731587d4ed0f218d5929285c8b2ccbc497e20db42de73885191fa453350335990184d8df805072f958d5354debda38f5421effaaafd6cb9b721ace74be0892d77679f62a4a126697cd35797f6858193da4ba1770c06aea2e5c59ec04b8ea26749e61b72ecdde403f3bc7e5e546cd799578cc939fa676dfd5e648576d4a06cbadb028adc2c0b461f145b2321f42e5e0f3b4fb898ecd461df07a6f5154067787bf74b5cc5c03704a1ce47494961931f0263b0aac32505102595957531a2de69dd71aac51f8a49902f81f21283dbe8e21e01e5d82517868826f86acf338d935aa6b4d5a25c8d540389b277dd9d64569d68baf0f71bd03dba45b92a7fc052601d1bd011a2fc6790a23f97c6fa5caeea040ab86841f268d39ce4f7caf01069df78bba098e04366492f0c2ac24f1bf16828752765fa523c9a4d42b71109d123e6be8c7b1ab3ccf8ea03404075fe1a9596f1bba1d267f9a7879ceece514818316c9c0583469d2367831fc42b517ea028a28df7c18d783d16ea2436cee2b15d52db68b5dfdee6b4d26f0905f9b030c911a04d078923a4136afea96eed6874462a482917353264cc9bee298f167ac65a6db4e4eda88044b39cc0b33183843eaa946564a00c3a0ab661f2c915e70bf0bb65bfbb6fa2eea20aed16bf2c1a1d00ec55fb4ff2f76b8e462ea70c19efa579c9ee78194b86708fdae66a9ce6e2cf3d366037798cfb50277ba6d2fd4866361022fd788ab7735b40b8b61d55e32243e06719e53992e9ac16c9c4b6e6933635c3c47c8f7e73e17dd54d0dd8aeba5d76de46894e7b3f9d3ec25ad78ee82297ba69905ea0fa094b8667faa2b8885e2187b3da80268aa1164761d7b0d6de206b676777348152b8ae1d4afed753bc63c739a5ca8ce7afb2b241a226bd9e502baba391b5b13f5054f070b65a9cf3a67063bfaa803ba390732cd03888f664023f888741d04d564e0b5674b0a183ace81452001b3fbb4214c77d42ca75376742c471e58f67307726d56a1032bd236610cbcbcd03d0d7a452900136897dc55bb3ce959d10d4e6a10fb635006bd8c41cd9ded2d3dfdd8f2e229590324a7370cb2124210b2330f4c56155caa09a2564932ceded8d92c79664dcdeb87faad7d3da006cc2ea267ee3df41e9677789cc5a8cc3b83add6491561b3047919e0648b1b2e97d7ad6f6c2aa80cab8e9ae10e1f75b1fdd0246151af709d259a6a0ed0b26bd711024965ecad7c41387de45443defce53f66612948694a6032279131c257119ed876a8e805dfb49576ef5c563574115ee87050d92d191bc761ef51d966918e2ef925639400069e3959d8fe19f36136e947ff430bf74e71da0aa5923b00000000" : GoString)))).__copy__());
        var _v:T_nat = (_natFromString(((("0x838332321d443a3d30373d47301d47073847473a383d3030f25b3d3d3e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e00000000000000000041603038331c3d32f5303441e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e01c0a5459bfc7b9be9fcbb9d2383840464319434707303030f43a32f53034411c0a5459413820878787878787878787878787878787878787878787878787878787878787878787870630303a3a30334036605b923a6101f83638413943413960204337602043323801526040523241846038414143015238604060328452413841413638523c0240384141364036605b923a6101f83638413943413960204334602043323801526040523241846038414143015238604060328452413841413638523c02403841413638433030f25a8b83838383838383838383838383838383837d838383ffffffffffffffff838383838383838383000000000000000000030000007d26e27c7c8b83838383838383838383838383838383837d838383ffffffffffffffff83838383838383838383838383838383838383838383435960f535073030f3343200000000000000011881301938343030fa398383300000002300000000000000000000f11af4600c845252904141364138383c60406032414443095238010241414303364443434132305b595a15434160b042385341ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff47476043410536613603593a6005411c437405fcfcfcfcfcfcfc0000000000005a3b075815054359000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" : GoString)))) == null ? null : _natFromString(((("0x838332321d443a3d30373d47301d47073847473a383d3030f25b3d3d3e00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002e00000000000000000041603038331c3d32f5303441e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e0e01c0a5459bfc7b9be9fcbb9d2383840464319434707303030f43a32f53034411c0a5459413820878787878787878787878787878787878787878787878787878787878787878787870630303a3a30334036605b923a6101f83638413943413960204337602043323801526040523241846038414143015238604060328452413841413638523c0240384141364036605b923a6101f83638413943413960204334602043323801526040523241846038414143015238604060328452413841413638523c02403841413638433030f25a8b83838383838383838383838383838383837d838383ffffffffffffffff838383838383838383000000000000000000030000007d26e27c7c8b83838383838383838383838383838383837d838383ffffffffffffffff83838383838383838383838383838383838383838383435960f535073030f3343200000000000000011881301938343030fa398383300000002300000000000000000000f11af4600c845252904141364138383c60406032414443095238010241414303364443434132305b595a15434160b042385341ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff47476043410536613603593a6005411c437405fcfcfcfcfcfcfc0000000000005a3b075815054359000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000" : GoString)))).__copy__());
        var _q:T_nat = (((new T_nat() : T_nat))._make(((16 : GoInt))) == null ? null : ((new T_nat() : T_nat))._make(((16 : GoInt))).__copy__());
        _q._div((_q == null ? null : _q.__copy__()), (_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
    }
function _maxPow(_b:Word):{ var _0 : Word; var _1 : GoInt; } {
        var _p:Word = new Word(), _n:GoInt = ((0 : GoInt));
        {
            final __tmp__0 = _b;
            final __tmp__1 = ((1 : GoInt));
            _p = __tmp__0;
            _n = __tmp__1;
        };
        {
            var _max:Word = (("4294967295" : GoUInt)) / _b;
            while (_p <= _max) {
                _p = _p * (_b);
                _n++;
            };
        };
        return { _0 : _p, _1 : _n };
    }
function _pow(_x:Word, _n:GoInt):Word {
        var _p:Word = new Word();
        _p = ((1 : GoUInt));
        while (_n > ((0 : GoInt))) {
            if ((_n & ((1 : GoInt))) != ((0 : GoInt))) {
                _p = _p * (_x);
            };
            _x = _x * (_x);
            _n = _n >> (((1 : GoUnTypedInt)));
        };
        return _p;
    }
function _divisors(_m:GoInt, _b:Word, _ndigits:GoInt, _bb:Word):Slice<T_divisor> {
        if ((_leafSize == ((0 : GoInt))) || (_m <= _leafSize)) {
            return ((null : Slice<T_divisor>));
        };
        var _k:GoInt = ((1 : GoInt));
        {
            var _words:GoInt = _leafSize;
            Go.cfor((_words < (_m >> ((1 : GoUnTypedInt)))) && (_k < (_cacheBase10._table != null ? _cacheBase10._table.length : ((0 : GoInt)))), _words = _words << (((1 : GoUnTypedInt))), {
                _k++;
            });
        };
        var _table:Slice<T_divisor> = ((null : Slice<T_divisor>));
        if (_b == ((10 : GoUInt))) {
            _cacheBase10.lock();
            _table = ((_cacheBase10._table.__slice__(((0 : GoInt)), _k) : Slice<T_divisor>));
        } else {
            _table = new Slice<T_divisor>(...[for (i in 0 ... ((_k : GoInt)).toBasic()) new T_divisor()]);
        };
        if ((_table != null ? _table[_k - ((1 : GoInt))] : new T_divisor())._ndigits == ((0 : GoInt))) {
            var _larger:T_nat = new T_nat();
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _k, _i++, {
                    if ((_table != null ? _table[_i] : new T_divisor())._ndigits == ((0 : GoInt))) {
                        if (_i == ((0 : GoInt))) {
                            (_table != null ? _table[((0 : GoInt))] : new T_divisor())._bbb = (((new T_nat() : T_nat))._expWW(_bb, ((_leafSize : Word))) == null ? null : ((new T_nat() : T_nat))._expWW(_bb, ((_leafSize : Word))).__copy__());
                            (_table != null ? _table[((0 : GoInt))] : new T_divisor())._ndigits = _ndigits * _leafSize;
                        } else {
                            (_table != null ? _table[_i] : new T_divisor())._bbb = (((new T_nat() : T_nat))._sqr(((_table != null ? _table[_i - ((1 : GoInt))] : new T_divisor())._bbb == null ? null : (_table != null ? _table[_i - ((1 : GoInt))] : new T_divisor())._bbb.__copy__())) == null ? null : ((new T_nat() : T_nat))._sqr(((_table != null ? _table[_i - ((1 : GoInt))] : new T_divisor())._bbb == null ? null : (_table != null ? _table[_i - ((1 : GoInt))] : new T_divisor())._bbb.__copy__())).__copy__());
                            (_table != null ? _table[_i] : new T_divisor())._ndigits = ((2 : GoInt)) * (_table != null ? _table[_i - ((1 : GoInt))] : new T_divisor())._ndigits;
                        };
                        _larger = (((new T_nat() : T_nat))._set(((_table != null ? _table[_i] : new T_divisor())._bbb == null ? null : (_table != null ? _table[_i] : new T_divisor())._bbb.__copy__())) == null ? null : ((new T_nat() : T_nat))._set(((_table != null ? _table[_i] : new T_divisor())._bbb == null ? null : (_table != null ? _table[_i] : new T_divisor())._bbb.__copy__())).__copy__());
                        while (_mulAddVWW(_larger, _larger, _b, ((0 : GoUInt))) == ((0 : GoUInt))) {
                            (_table != null ? _table[_i] : new T_divisor())._bbb = ((_table != null ? _table[_i] : new T_divisor())._bbb._set((_larger == null ? null : _larger.__copy__())) == null ? null : (_table != null ? _table[_i] : new T_divisor())._bbb._set((_larger == null ? null : _larger.__copy__())).__copy__());
                            (_table != null ? _table[_i] : new T_divisor())._ndigits++;
                        };
                        (_table != null ? _table[_i] : new T_divisor())._nbits = (_table != null ? _table[_i] : new T_divisor())._bbb._bitLen();
                    };
                });
            };
        };
        if (_b == ((10 : GoUInt))) {
            _cacheBase10.unlock();
        };
        return _table;
    }
function testMaxBase(_t:stdgo.testing.Testing.T_):Void {
        if (false) {
            _t.fatalf(((("%d != %d" : GoString))), Go.toInterface(((62 : GoInt32))), Go.toInterface((((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))).length : ((0 : GoInt)))));
        };
    }
function _log2(_x:Word):GoInt {
        return stdgo.math.bits.Bits.len(((_x : GoUInt))) - ((1 : GoInt));
    }
function _itoa(_x:T_nat, _base:GoInt):Slice<GoByte> {
        if (_base < ((2 : GoInt))) {
            throw Go.toInterface(((("illegal base" : GoString))));
        } else if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((((("0" : GoString))) : Slice<GoByte>));
        };
        var _i:GoInt = (_x._bitLen() / _log2(((_base : Word)))) + ((1 : GoInt));
        var _s:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_i : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _q:T_nat = (((new T_nat() : T_nat))._set((_x == null ? null : _x.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_x == null ? null : _x.__copy__())).__copy__());
        while ((_q != null ? _q.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _i--;
            var _r:Word = new Word();
            {
                var __tmp__ = _q._divW((_q == null ? null : _q.__copy__()), ((_base : Word)));
                _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                _r = __tmp__._1;
            };
            if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_r] : ((0 : GoUInt8)));
        };
        return ((_s.__slice__(_i) : Slice<GoUInt8>));
    }
function testString(_t:stdgo.testing.Testing.T_):Void {
        var _panicStr:GoString = (("" : GoString));
        {
            var a = function():Void {
                __deferstack__.unshift(() -> {
                    var a = function():Void {
                        _panicStr = ((({
                            final r = __recover_exception__;
                            __recover_exception__ = null;
                            r;
                        }).value : GoString));
                    };
                    a();
                });
                _natOne._utoa(((1 : GoInt)));
            };
            a();
        };
        if (_panicStr != ((("invalid base" : GoString)))) {
            _t.errorf(((("expected panic for invalid base" : GoString))));
        };
        for (_0 => _a in _strTests) {
            var _s:GoString = ((_a._x._utoa(_a._b) : GoString));
            if (_s != _a._s) {
                _t.errorf(((("string%+v\n\tgot s = %s; want %s" : GoString))), Go.toInterface(_a), Go.toInterface(_s), Go.toInterface(_a._s));
            };
            var __tmp__ = ((new T_nat() : T_nat))._scan(stdgo.strings.Strings.newReader(_a._s), _a._b, false), _x:T_nat = __tmp__._0, _b:GoInt = __tmp__._1, _1:GoInt = __tmp__._2, _err:stdgo.Error = __tmp__._3;
            if (_x._cmp((_a._x == null ? null : _a._x.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("scan%+v\n\tgot z = %v; want %v" : GoString))), Go.toInterface(_a), Go.toInterface(_x), Go.toInterface(_a._x));
            };
            if (_b != _a._b) {
                _t.errorf(((("scan%+v\n\tgot b = %d; want %d" : GoString))), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_a._b));
            };
            if (_err != null) {
                _t.errorf(((("scan%+v\n\tgot error = %s" : GoString))), Go.toInterface(_a), Go.toInterface(_err));
            };
        };
    }
function testScanBase(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _natScanTests) {
            var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_a._s);
            var __tmp__ = ((new T_nat() : T_nat))._scan(_r, _a._base, _a._frac), _x:T_nat = __tmp__._0, _b:GoInt = __tmp__._1, _count:GoInt = __tmp__._2, _err:stdgo.Error = __tmp__._3;
            if (_err != _a._err) {
                _t.errorf(((("scan%+v\n\tgot error = %v; want %v" : GoString))), Go.toInterface(_a), Go.toInterface(_err), Go.toInterface(_a._err));
            };
            if (_x._cmp((_a._x == null ? null : _a._x.__copy__())) != ((0 : GoInt))) {
                _t.errorf(((("scan%+v\n\tgot z = %v; want %v" : GoString))), Go.toInterface(_a), Go.toInterface(_x), Go.toInterface(_a._x));
            };
            if (_b != _a._b) {
                _t.errorf(((("scan%+v\n\tgot b = %d; want %d" : GoString))), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_a._base));
            };
            if (_count != _a._count) {
                _t.errorf(((("scan%+v\n\tgot count = %d; want %d" : GoString))), Go.toInterface(_a), Go.toInterface(_count), Go.toInterface(_a._count));
            };
            var __tmp__ = _r.readRune(), _next:GoInt32 = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err == stdgo.io.Io.eof) {
                _next = ((0 : GoInt32));
                _err = ((null : stdgo.Error));
            };
            if ((_err == null) && (_next != _a._next)) {
                _t.errorf(((("scan%+v\n\tgot next = %q; want %q" : GoString))), Go.toInterface(_a), Go.toInterface(_next), Go.toInterface(_a._next));
            };
        };
    }
function testScanPi(_t:stdgo.testing.Testing.T_):Void {
        var _x:T_nat = new T_nat();
        var __tmp__ = _x._scan(stdgo.strings.Strings.newReader(_pi), ((10 : GoInt)), false), _z:T_nat = __tmp__._0, _0:GoInt = __tmp__._1, _1:GoInt = __tmp__._2, _err:stdgo.Error = __tmp__._3;
        if (_err != null) {
            _t.errorf(((("scanning pi: %s" : GoString))), Go.toInterface(_err));
        };
        {
            var _s:GoString = ((_z._utoa(((10 : GoInt))) : GoString));
            if (_s != _pi) {
                _t.errorf(((("scanning pi: got %s" : GoString))), Go.toInterface(_s));
            };
        };
    }
function testScanPiParallel(_t:stdgo.testing.Testing.T_):Void {
        {};
        var _c:Chan<GoInt> = new Chan<GoInt>(0, () -> ((0 : GoInt)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((2 : GoInt)), _i++, {
                Go.routine(() -> {
                    var a = function():Void {
                        testScanPi(_t);
                        _c.__send__(((0 : GoInt)));
                    };
                    a();
                });
            });
        };
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((2 : GoInt)), _i++, {
                _c.__get__();
            });
        };
    }
function benchmarkScanPi(_b:stdgo.testing.Testing.B):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                var _x:T_nat = new T_nat();
                _x._scan(stdgo.strings.Strings.newReader(_pi), ((10 : GoInt)), false);
            });
        };
    }
function benchmarkStringPiParallel(_b:stdgo.testing.Testing.B):Void {
        var _x:T_nat = new T_nat();
        {
            var __tmp__ = _x._scan(stdgo.strings.Strings.newReader(_pi), ((0 : GoInt)), false);
            _x = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
        };
        if (((_x._utoa(((10 : GoInt))) : GoString)) != _pi) {
            throw Go.toInterface(((("benchmark incorrect: conversion failed" : GoString))));
        };
        _b.runParallel(function(_pb:stdgo.testing.Testing.PB):Void {
            while (_pb.next()) {
                _x._utoa(((10 : GoInt)));
            };
        });
    }
function benchmarkScan(_b:stdgo.testing.Testing.B):Void {
        {};
        for (_0 => _base in ((new Slice<GoInt>(((2 : GoInt)), ((8 : GoInt)), ((10 : GoInt)), ((16 : GoInt))) : Slice<GoInt>))) {
            for (_1 => _y in ((new Slice<Word>(((10 : GoUInt)), ((100 : GoUInt)), ((1000 : GoUInt)), ((10000 : GoUInt)), ((100000 : GoUInt))) : Slice<Word>))) {
                if (_isRaceBuilder && (_y > ((1000 : GoUInt)))) {
                    continue;
                };
                _b.run(stdgo.fmt.Fmt.sprintf(((("%d/Base%d" : GoString))), Go.toInterface(_y), Go.toInterface(_base)), function(_b:stdgo.testing.Testing.B):Void {
                    _b.stopTimer();
                    var _z:T_nat = new T_nat();
                    _z = (_z._expWW(((10 : GoUInt)), _y) == null ? null : _z._expWW(((10 : GoUInt)), _y).__copy__());
                    var _s:Slice<GoUInt8> = _z._utoa(_base);
                    {
                        var _t:Slice<GoUInt8> = _itoa((_z == null ? null : _z.__copy__()), _base);
                        if (!stdgo.bytes.Bytes.equal(_s, _t)) {
                            _b.fatalf(((("scanning: got %s; want %s" : GoString))), Go.toInterface(_s), Go.toInterface(_t));
                        };
                    };
                    _b.startTimer();
                    {
                        var _i:GoInt = ((0 : GoInt));
                        Go.cfor(_i < _b.n, _i++, {
                            _z._scan(stdgo.bytes.Bytes.newReader(_s), _base, false);
                        });
                    };
                });
            };
        };
    }
function benchmarkString(_b:stdgo.testing.Testing.B):Void {
        {};
        for (_0 => _base in ((new Slice<GoInt>(((2 : GoInt)), ((8 : GoInt)), ((10 : GoInt)), ((16 : GoInt))) : Slice<GoInt>))) {
            for (_1 => _y in ((new Slice<Word>(((10 : GoUInt)), ((100 : GoUInt)), ((1000 : GoUInt)), ((10000 : GoUInt)), ((100000 : GoUInt))) : Slice<Word>))) {
                if (_isRaceBuilder && (_y > ((1000 : GoUInt)))) {
                    continue;
                };
                _b.run(stdgo.fmt.Fmt.sprintf(((("%d/Base%d" : GoString))), Go.toInterface(_y), Go.toInterface(_base)), function(_b:stdgo.testing.Testing.B):Void {
                    _b.stopTimer();
                    var _z:T_nat = new T_nat();
                    _z = (_z._expWW(((10 : GoUInt)), _y) == null ? null : _z._expWW(((10 : GoUInt)), _y).__copy__());
                    _z._utoa(_base);
                    _b.startTimer();
                    {
                        var _i:GoInt = ((0 : GoInt));
                        Go.cfor(_i < _b.n, _i++, {
                            _z._utoa(_base);
                        });
                    };
                });
            };
        };
    }
function benchmarkLeafSize(_b:stdgo.testing.Testing.B):Void {
        {
            var _n:GoInt = ((0 : GoInt));
            Go.cfor(_n <= ((16 : GoInt)), _n++, {
                _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                    leafSizeHelper(_b, ((10 : GoInt)), _n);
                });
            });
        };
        for (_0 => _n in ((new Slice<GoInt>(((32 : GoInt)), ((64 : GoInt))) : Slice<GoInt>))) {
            _b.run(stdgo.fmt.Fmt.sprint(_n), function(_b:stdgo.testing.Testing.B):Void {
                leafSizeHelper(_b, ((10 : GoInt)), _n);
            });
        };
    }
function leafSizeHelper(_b:stdgo.testing.Testing.B, _base:GoInt, _size:GoInt):Void {
        _b.stopTimer();
        var _originalLeafSize:GoInt = _leafSize;
        _resetTable(((_cacheBase10._table.__slice__(0) : Slice<T_divisor>)));
        _leafSize = _size;
        _b.startTimer();
        {
            var _d:GoInt = ((1 : GoInt));
            Go.cfor(_d <= ((10000 : GoInt)), _d = _d * (((10 : GoInt))), {
                _b.stopTimer();
                var _z:T_nat = new T_nat();
                _z = (_z._expWW(((_base : Word)), ((_d : Word))) == null ? null : _z._expWW(((_base : Word)), ((_d : Word))).__copy__());
                _z._utoa(_base);
                _b.startTimer();
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _z._utoa(_base);
                    });
                };
            });
        };
        _b.stopTimer();
        _resetTable(((_cacheBase10._table.__slice__(0) : Slice<T_divisor>)));
        _leafSize = _originalLeafSize;
        _b.startTimer();
    }
function _resetTable(_table:Slice<T_divisor>):Void {
        if ((_table != null) && ((_table != null ? _table[((0 : GoInt))] : new T_divisor())._bbb != null)) {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < (_table != null ? _table.length : ((0 : GoInt))), _i++, {
                    (_table != null ? _table[_i] : new T_divisor())._bbb = null;
                    (_table != null ? _table[_i] : new T_divisor())._nbits = ((0 : GoInt));
                    (_table != null ? _table[_i] : new T_divisor())._ndigits = ((0 : GoInt));
                });
            };
        };
    }
function testStringPowers(_t:stdgo.testing.Testing.T_):Void {
        var _p:Word = new Word();
        {
            var _b:GoInt = ((2 : GoInt));
            Go.cfor(_b <= ((16 : GoInt)), _b++, {
                {
                    _p = ((0 : GoUInt));
                    Go.cfor(_p <= ((512 : GoUInt)), _p++, {
                        if (stdgo.testing.Testing.short() && (_p > ((10 : GoUInt)))) {
                            break;
                        };
                        var _x:T_nat = (((new T_nat() : T_nat))._expWW(((_b : Word)), _p) == null ? null : ((new T_nat() : T_nat))._expWW(((_b : Word)), _p).__copy__());
                        var _xs:Slice<GoUInt8> = _x._utoa(_b);
                        var _xs2:Slice<GoUInt8> = _itoa((_x == null ? null : _x.__copy__()), _b);
                        if (!stdgo.bytes.Bytes.equal(_xs, _xs2)) {
                            _t.errorf(((("failed at %d ** %d in base %d: %s != %s" : GoString))), Go.toInterface(_b), Go.toInterface(_p), Go.toInterface(_b), Go.toInterface(_xs), Go.toInterface(_xs2));
                        };
                    });
                };
                if ((_b >= ((3 : GoInt))) && stdgo.testing.Testing.short()) {
                    break;
                };
            });
        };
    }
function _divWVW(_z:Slice<Word>, _xn:Word, _x:Slice<Word>, _y:Word):Word {
        var _r:Word = new Word();
        _r = _xn;
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((1 : GoInt))) {
            var __tmp__ = stdgo.math.bits.Bits.div(((_r : GoUInt)), (((_x != null ? _x[((0 : GoInt))] : new Word()) : GoUInt)), ((_y : GoUInt))), _qq:GoUInt = __tmp__._0, _rr:GoUInt = __tmp__._1;
            if (_z != null) _z[((0 : GoInt))] = ((_qq : Word));
            return ((_rr : Word));
        };
        var _rec:Word = _reciprocalWord(_y);
        {
            var _i:GoInt = (_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                {
                    var __tmp__ = _divWW(_r, (_x != null ? _x[_i] : new Word()), _y, _rec);
                    if (_z != null) _z[_i] = __tmp__._0;
                    _r = __tmp__._1;
                };
            });
        };
        return _r;
    }
function _greaterThan(_x1:Word, _x2:Word, _y1:Word, _y2:Word):Bool {
        return (_x1 > _y1) || ((_x1 == _y1) && (_x2 > _y2));
    }
function _cutSpace(_r:GoRune):GoRune {
        if (stdgo.unicode.Unicode.isSpace(_r)) {
            return ((-1 : GoInt32));
        };
        return _r;
    }
function testProbablyPrime(_t:stdgo.testing.Testing.T_):Void {
        var _nreps:GoInt = ((20 : GoInt));
        if (stdgo.testing.Testing.short()) {
            _nreps = ((1 : GoInt));
        };
        for (_i => _s in _primes) {
            var __tmp__ = new Int_().setString(_s, ((10 : GoInt))), _p:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
            if ((!_p.probablyPrime(_nreps) || ((_nreps != ((1 : GoInt))) && !_p.probablyPrime(((1 : GoInt))))) || !_p.probablyPrime(((0 : GoInt)))) {
                _t.errorf(((("#%d prime found to be non-prime (%s)" : GoString))), Go.toInterface(_i), Go.toInterface(_s));
            };
        };
        for (_i => _s in _composites) {
            _s = stdgo.strings.Strings.map(_cutSpace, _s);
            var __tmp__ = new Int_().setString(_s, ((10 : GoInt))), _c:Ref<Int_> = __tmp__._0, _1:Bool = __tmp__._1;
            if ((_c.probablyPrime(_nreps) || ((_nreps != ((1 : GoInt))) && _c.probablyPrime(((1 : GoInt))))) || _c.probablyPrime(((0 : GoInt)))) {
                _t.errorf(((("#%d composite found to be prime (%s)" : GoString))), Go.toInterface(_i), Go.toInterface(_s));
            };
        };
        var _c:Ref<Int_> = newInt(((11 : GoInt64)));
        for (_2 => _n in ((new Slice<GoInt>(((-1 : GoInt)), ((0 : GoInt)), ((1 : GoInt))) : Slice<GoInt>))) {
            {
                var a = function():Void {
                    __deferstack__.unshift(() -> {
                        var a = function():Void {
                            if ((_n < ((0 : GoInt))) && (({
                                final r = __recover_exception__;
                                __recover_exception__ = null;
                                r;
                            }) == null)) {
                                _t.fatalf(((("expected panic from ProbablyPrime(%d)" : GoString))), Go.toInterface(_n));
                            };
                        };
                        a();
                    });
                    if (!_c.probablyPrime(_n)) {
                        _t.fatalf(((("%v should be a prime" : GoString))), Go.toInterface(_c));
                    };
                };
                a();
            };
        };
    }
function benchmarkProbablyPrime(_b:stdgo.testing.Testing.B):Void {
        var __tmp__ = new Int_().setString(((("203956878356401977405765866929034577280193993314348263094772646453283062722701277632936616063144088173312372882677123879538709400158306567338328279154499698366071906766440037074217117805690872792848149112022286332144876183376326512083574821647933992961249917319836219304274280243803104015000563790123" : GoString))), ((10 : GoInt))), _p:Ref<Int_> = __tmp__._0, _0:Bool = __tmp__._1;
        for (_1 => _n in ((new Slice<GoInt>(((0 : GoInt)), ((1 : GoInt)), ((5 : GoInt)), ((10 : GoInt)), ((20 : GoInt))) : Slice<GoInt>))) {
            _b.run(stdgo.fmt.Fmt.sprintf(((("n=%d" : GoString))), Go.toInterface(_n)), function(_b:stdgo.testing.Testing.B):Void {
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _b.n, _i++, {
                        _p.probablyPrime(_n);
                    });
                };
            });
        };
        _b.run(((("Lucas" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _b.n, _i++, {
                    _p._abs._probablyPrimeLucas();
                });
            };
        });
        _b.run(((("MillerRabinBase2" : GoString))), function(_b:stdgo.testing.Testing.B):Void {
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _b.n, _i++, {
                    _p._abs._probablyPrimeMillerRabin(((1 : GoInt)), true);
                });
            };
        });
    }
function testMillerRabinPseudoprimes(_t:stdgo.testing.Testing.T_):Void {
        _testPseudoprimes(_t, ((("probablyPrimeMillerRabin" : GoString))), function(_n:T_nat):Bool {
            return _n._probablyPrimeMillerRabin(((1 : GoInt)), true) && !_n._probablyPrimeLucas();
        }, ((new Slice<GoInt>(
((2047 : GoInt)),
((3277 : GoInt)),
((4033 : GoInt)),
((4681 : GoInt)),
((8321 : GoInt)),
((15841 : GoInt)),
((29341 : GoInt)),
((42799 : GoInt)),
((49141 : GoInt)),
((52633 : GoInt)),
((65281 : GoInt)),
((74665 : GoInt)),
((80581 : GoInt)),
((85489 : GoInt)),
((88357 : GoInt)),
((90751 : GoInt))) : Slice<GoInt>)));
    }
function testLucasPseudoprimes(_t:stdgo.testing.Testing.T_):Void {
        _testPseudoprimes(_t, ((("probablyPrimeLucas" : GoString))), function(_n:T_nat):Bool {
            return _n._probablyPrimeLucas() && !_n._probablyPrimeMillerRabin(((1 : GoInt)), true);
        }, ((new Slice<GoInt>(
((989 : GoInt)),
((3239 : GoInt)),
((5777 : GoInt)),
((10877 : GoInt)),
((27971 : GoInt)),
((29681 : GoInt)),
((30739 : GoInt)),
((31631 : GoInt)),
((39059 : GoInt)),
((72389 : GoInt)),
((73919 : GoInt)),
((75077 : GoInt))) : Slice<GoInt>)));
    }
function _testPseudoprimes(_t:stdgo.testing.Testing.T_, _name:GoString, _cond:T_nat -> Bool, _want:Slice<GoInt>):Void {
        var _n:T_nat = ((new Slice<Word>(((1 : GoUInt))) : T_nat));
        {
            var _i:GoInt = ((3 : GoInt));
            Go.cfor(_i < ((100000 : GoInt)), _i = _i + (((2 : GoInt))), {
                if (stdgo.testing.Testing.short()) {
                    if ((_want != null ? _want.length : ((0 : GoInt))) == ((0 : GoInt))) {
                        break;
                    };
                    if (_i < ((_want != null ? _want[((0 : GoInt))] : ((0 : GoInt))) - ((2 : GoInt)))) {
                        _i = (_want != null ? _want[((0 : GoInt))] : ((0 : GoInt))) - ((2 : GoInt));
                    };
                };
                if (_n != null) _n[((0 : GoInt))] = ((_i : Word));
                var _pseudo:Bool = _cond((_n == null ? null : _n.__copy__()));
                if (_pseudo && (((_want != null ? _want.length : ((0 : GoInt))) == ((0 : GoInt))) || (_i != (_want != null ? _want[((0 : GoInt))] : ((0 : GoInt)))))) {
                    _t.errorf(((("%s(%v, base=2) = true, want false" : GoString))), Go.toInterface(_name), Go.toInterface(_i));
                } else if ((!_pseudo && ((_want != null ? _want.length : ((0 : GoInt))) >= ((1 : GoInt)))) && (_i == (_want != null ? _want[((0 : GoInt))] : ((0 : GoInt))))) {
                    _t.errorf(((("%s(%v, base=2) = false, want true" : GoString))), Go.toInterface(_name), Go.toInterface(_i));
                };
                if (((_want != null ? _want.length : ((0 : GoInt))) > ((0 : GoInt))) && (_i == (_want != null ? _want[((0 : GoInt))] : ((0 : GoInt))))) {
                    _want = ((_want.__slice__(((1 : GoInt))) : Slice<GoInt>));
                };
            });
        };
        if ((_want != null ? _want.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _t.fatalf(((("forgot to test %v" : GoString))), Go.toInterface(_want));
        };
    }
function newRat(_a:GoInt64, _b:GoInt64):Rat {
        return new Rat().setFrac64(_a, _b);
    }
function _quotToFloat32(_a:T_nat, _b:T_nat):{ var _0 : GoFloat32; var _1 : Bool; } {
        var _f:GoFloat32 = ((0 : GoFloat32)), _exact:Bool = false;
        {};
        var _alen:GoInt = _a._bitLen();
        if (_alen == ((0 : GoInt))) {
            return { _0 : ((0 : GoFloat32)), _1 : true };
        };
        var _blen:GoInt = _b._bitLen();
        if (_blen == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        var _exp:GoInt = _alen - _blen;
        var _a2:T_nat = new T_nat(), _b2:T_nat = new T_nat();
        _a2 = (_a2._set((_a == null ? null : _a.__copy__())) == null ? null : _a2._set((_a == null ? null : _a.__copy__())).__copy__());
        _b2 = (_b2._set((_b == null ? null : _b.__copy__())) == null ? null : _b2._set((_b == null ? null : _b.__copy__())).__copy__());
        {
            var _shift:GoInt = ((25 : GoInt)) - _exp;
            if (_shift > ((0 : GoInt))) {
                _a2 = (_a2._shl((_a2 == null ? null : _a2.__copy__()), ((_shift : GoUInt))) == null ? null : _a2._shl((_a2 == null ? null : _a2.__copy__()), ((_shift : GoUInt))).__copy__());
            } else if (_shift < ((0 : GoInt))) {
                _b2 = (_b2._shl((_b2 == null ? null : _b2.__copy__()), ((-_shift : GoUInt))) == null ? null : _b2._shl((_b2 == null ? null : _b2.__copy__()), ((-_shift : GoUInt))).__copy__());
            };
        };
        var _q:T_nat = new T_nat();
        var __tmp__ = _q._div((_a2 == null ? null : _a2.__copy__()), (_a2 == null ? null : _a2.__copy__()), (_b2 == null ? null : _b2.__copy__())), _q:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
        var _mantissa:GoUInt32 = _low32((_q == null ? null : _q.__copy__()));
        var _haveRem:Bool = (_r != null ? _r.length : ((0 : GoInt))) > ((0 : GoInt));
        if ((_mantissa >> ((25 : GoUnTypedInt))) == ((1 : GoUInt32))) {
            if ((_mantissa & ((1 : GoUInt32))) == ((1 : GoUInt32))) {
                _haveRem = true;
            };
            _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
            _exp++;
        };
        if ((_mantissa >> ((24 : GoUnTypedInt))) != ((1 : GoUInt32))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("expected exactly %d bits of result" : GoString))), Go.toInterface(((25 : GoInt)))));
        };
        if ((((-149 : GoInt)) <= _exp) && (_exp <= ((-126 : GoInt)))) {
            var _shift:GoUInt = (((((-126 : GoInt)) - (_exp - ((1 : GoInt)))) : GoUInt));
            var _lostbits:GoUInt32 = _mantissa & ((((1 : GoUInt32)) << _shift) - ((1 : GoUInt32)));
            _haveRem = _haveRem || (_lostbits != ((0 : GoUInt32)));
            _mantissa = _mantissa >> (_shift);
            _exp = ((-125 : GoInt));
        };
        _exact = !_haveRem;
        if ((_mantissa & ((1 : GoUInt32))) != ((0 : GoUInt32))) {
            _exact = false;
            if (_haveRem || ((_mantissa & ((2 : GoUInt32))) != ((0 : GoUInt32)))) {
                {
                    _mantissa++;
                    if (_mantissa >= ((33554432 : GoUInt32))) {
                        _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
                        _exp++;
                    };
                };
            };
        };
        _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
        _f = ((stdgo.math.Math.ldexp(((_mantissa : GoFloat64)), _exp - ((24 : GoInt))) : GoFloat32));
        if (stdgo.math.Math.isInf(((_f : GoFloat64)), ((0 : GoInt)))) {
            _exact = false;
        };
        return { _0 : _f, _1 : _exact };
    }
function _quotToFloat64(_a:T_nat, _b:T_nat):{ var _0 : GoFloat64; var _1 : Bool; } {
        var _f:GoFloat64 = ((0 : GoFloat64)), _exact:Bool = false;
        {};
        var _alen:GoInt = _a._bitLen();
        if (_alen == ((0 : GoInt))) {
            return { _0 : ((0 : GoFloat64)), _1 : true };
        };
        var _blen:GoInt = _b._bitLen();
        if (_blen == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        var _exp:GoInt = _alen - _blen;
        var _a2:T_nat = new T_nat(), _b2:T_nat = new T_nat();
        _a2 = (_a2._set((_a == null ? null : _a.__copy__())) == null ? null : _a2._set((_a == null ? null : _a.__copy__())).__copy__());
        _b2 = (_b2._set((_b == null ? null : _b.__copy__())) == null ? null : _b2._set((_b == null ? null : _b.__copy__())).__copy__());
        {
            var _shift:GoInt = ((54 : GoInt)) - _exp;
            if (_shift > ((0 : GoInt))) {
                _a2 = (_a2._shl((_a2 == null ? null : _a2.__copy__()), ((_shift : GoUInt))) == null ? null : _a2._shl((_a2 == null ? null : _a2.__copy__()), ((_shift : GoUInt))).__copy__());
            } else if (_shift < ((0 : GoInt))) {
                _b2 = (_b2._shl((_b2 == null ? null : _b2.__copy__()), ((-_shift : GoUInt))) == null ? null : _b2._shl((_b2 == null ? null : _b2.__copy__()), ((-_shift : GoUInt))).__copy__());
            };
        };
        var _q:T_nat = new T_nat();
        var __tmp__ = _q._div((_a2 == null ? null : _a2.__copy__()), (_a2 == null ? null : _a2.__copy__()), (_b2 == null ? null : _b2.__copy__())), _q:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
        var _mantissa:GoUInt64 = _low64((_q == null ? null : _q.__copy__()));
        var _haveRem:Bool = (_r != null ? _r.length : ((0 : GoInt))) > ((0 : GoInt));
        if ((_mantissa >> ((54 : GoUnTypedInt))) == ((1 : GoUInt64))) {
            if ((_mantissa & ((1 : GoUInt64))) == ((1 : GoUInt64))) {
                _haveRem = true;
            };
            _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
            _exp++;
        };
        if ((_mantissa >> ((53 : GoUnTypedInt))) != ((1 : GoUInt64))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("expected exactly %d bits of result" : GoString))), Go.toInterface(((54 : GoInt)))));
        };
        if ((((-1074 : GoInt)) <= _exp) && (_exp <= ((-1022 : GoInt)))) {
            var _shift:GoUInt = (((((-1022 : GoInt)) - (_exp - ((1 : GoInt)))) : GoUInt));
            var _lostbits:GoUInt64 = _mantissa & ((((1 : GoUInt64)) << _shift) - ((1 : GoUInt64)));
            _haveRem = _haveRem || (_lostbits != ((0 : GoUInt64)));
            _mantissa = _mantissa >> (_shift);
            _exp = ((-1021 : GoInt));
        };
        _exact = !_haveRem;
        if ((_mantissa & ((1 : GoUInt64))) != ((0 : GoUInt64))) {
            _exact = false;
            if (_haveRem || ((_mantissa & ((2 : GoUInt64))) != ((0 : GoUInt64)))) {
                {
                    _mantissa++;
                    if (_mantissa >= (("18014398509481984" : GoUInt64))) {
                        _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
                        _exp++;
                    };
                };
            };
        };
        _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
        _f = stdgo.math.Math.ldexp(((_mantissa : GoFloat64)), _exp - ((53 : GoInt)));
        if (stdgo.math.Math.isInf(_f, ((0 : GoInt)))) {
            _exact = false;
        };
        return { _0 : _f, _1 : _exact };
    }
function _mulDenom(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        if (((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) && ((_y != null ? _y.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            return (_z._setWord(((1 : GoUInt))) == null ? null : _z._setWord(((1 : GoUInt))).__copy__());
        } else if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (_z._set((_y == null ? null : _y.__copy__())) == null ? null : _z._set((_y == null ? null : _y.__copy__())).__copy__());
        } else if ((_y != null ? _y.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        return (_z._mul((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__())) == null ? null : _z._mul((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__())).__copy__());
    }
function testZeroRat(_t:stdgo.testing.Testing.T_):Void {
        var __recover_exception__:AnyInterface = null;
        var __deferstack__:Array<Void -> Void> = [];
        try {
            var _x:Rat = new Rat(), _y:Rat = new Rat(), _z:Rat = new Rat();
            _y.setFrac64(((0 : GoInt64)), ((42 : GoInt64)));
            if (_x.cmp(_y) != ((0 : GoInt))) {
                _t.errorf(((("x and y should be both equal and zero" : GoString))));
            };
            {
                var _s:GoString = ((_x.toString() : GoString));
                if (_s != ((("0/1" : GoString)))) {
                    _t.errorf(((("got x = %s, want 0/1" : GoString))), Go.toInterface(_s));
                };
            };
            {
                var _s:GoString = _x.ratString();
                if (_s != ((("0" : GoString)))) {
                    _t.errorf(((("got x = %s, want 0" : GoString))), Go.toInterface(_s));
                };
            };
            _z.add(_x, _y);
            {
                var _s:GoString = _z.ratString();
                if (_s != ((("0" : GoString)))) {
                    _t.errorf(((("got x+y = %s, want 0" : GoString))), Go.toInterface(_s));
                };
            };
            _z.sub(_x, _y);
            {
                var _s:GoString = _z.ratString();
                if (_s != ((("0" : GoString)))) {
                    _t.errorf(((("got x-y = %s, want 0" : GoString))), Go.toInterface(_s));
                };
            };
            _z.mul(_x, _y);
            {
                var _s:GoString = _z.ratString();
                if (_s != ((("0" : GoString)))) {
                    _t.errorf(((("got x*y = %s, want 0" : GoString))), Go.toInterface(_s));
                };
            };
            __deferstack__.unshift(() -> {
                var a = function():Void {
                    {
                        var _s:AnyInterface = Go.toInterface(({
                            final r = __recover_exception__;
                            __recover_exception__ = null;
                            r;
                        }));
                        if ((_s == null) || (((_s.value : GoString)) != ((("division by zero" : GoString))))) {
                            throw Go.toInterface(_s);
                        };
                    };
                };
                a();
            });
            _z.quo(_x, _y);
            for (defer in __deferstack__) {
                defer();
            };
        } catch(__exception__) {
            if (!(__exception__.native is AnyInterfaceData)) throw __exception__;
            __recover_exception__ = __exception__.native;
            {
                for (defer in __deferstack__) {
                    defer();
                };
                if (__recover_exception__ != null) throw __recover_exception__;
                return;
            };
        };
    }
function testRatSign(_t:stdgo.testing.Testing.T_):Void {
        var _zero:Ref<Rat> = newRat(((0 : GoInt64)), ((1 : GoInt64)));
        for (_0 => _a in _setStringTests) {
            var __tmp__ = new Rat().setString(_a._in), _x:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _s:GoInt = _x.sign();
            var _e:GoInt = _x.cmp(_zero);
            if (_s != _e) {
                _t.errorf(((("got %d; want %d for z = %v" : GoString))), Go.toInterface(_s), Go.toInterface(_e), Go.toInterface(_x));
            };
        };
    }
function testRatCmp(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _ratCmpTests) {
            var __tmp__ = new Rat().setString(_test._rat1), _x:Ref<Rat> = __tmp__._0, _0:Bool = __tmp__._1;
            var __tmp__ = new Rat().setString(_test._rat2), _y:Ref<Rat> = __tmp__._0, _1:Bool = __tmp__._1;
            var _out:GoInt = _x.cmp(_y);
            if (_out != _test._out) {
                _t.errorf(((("#%d got out = %v; want %v" : GoString))), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_test._out));
            };
        };
    }
function testIsInt(_t:stdgo.testing.Testing.T_):Void {
        var _one:Ref<Int_> = newInt(((1 : GoInt64)));
        for (_0 => _a in _setStringTests) {
            var __tmp__ = new Rat().setString(_a._in), _x:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _i:Bool = _x.isInt();
            var _e:Bool = _x.denom().cmp(_one) == ((0 : GoInt));
            if (_i != _e) {
                _t.errorf(((("got IsInt(%v) == %v; want %v" : GoString))), Go.toInterface(_x), Go.toInterface(_i), Go.toInterface(_e));
            };
        };
    }
function testRatAbs(_t:stdgo.testing.Testing.T_):Void {
        var _zero:Ref<Rat> = new Rat();
        for (_0 => _a in _setStringTests) {
            var __tmp__ = new Rat().setString(_a._in), _x:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _e:Ref<Rat> = new Rat().set(_x);
            if (_e.cmp(_zero) < ((0 : GoInt))) {
                _e.sub(_zero, _e);
            };
            var _z:Ref<Rat> = new Rat().abs(_x);
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(((("got Abs(%v) = %v; want %v" : GoString))), Go.toInterface(_x), Go.toInterface(_z), Go.toInterface(_e));
            };
        };
    }
function testRatNeg(_t:stdgo.testing.Testing.T_):Void {
        var _zero:Ref<Rat> = new Rat();
        for (_0 => _a in _setStringTests) {
            var __tmp__ = new Rat().setString(_a._in), _x:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            var _e:Ref<Rat> = new Rat().sub(_zero, _x);
            var _z:Ref<Rat> = new Rat().neg(_x);
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(((("got Neg(%v) = %v; want %v" : GoString))), Go.toInterface(_x), Go.toInterface(_z), Go.toInterface(_e));
            };
        };
    }
function testRatInv(_t:stdgo.testing.Testing.T_):Void {
        var _zero:Ref<Rat> = new Rat();
        for (_0 => _a in _setStringTests) {
            var __tmp__ = new Rat().setString(_a._in), _x:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                continue;
            };
            if (_x.cmp(_zero) == ((0 : GoInt))) {
                continue;
            };
            var _e:Ref<Rat> = new Rat().setFrac(_x.denom(), _x.num());
            var _z:Ref<Rat> = new Rat().inv(_x);
            if (_z.cmp(_e) != ((0 : GoInt))) {
                _t.errorf(((("got Inv(%v) = %v; want %v" : GoString))), Go.toInterface(_x), Go.toInterface(_z), Go.toInterface(_e));
            };
        };
    }
function _testRatBin(_t:stdgo.testing.Testing.T_, _i:GoInt, _name:GoString, _f:T_ratBinFun, _a:T_ratBinArg):Void {
        var __tmp__ = new Rat().setString(_a._x), _x:Ref<Rat> = __tmp__._0, _0:Bool = __tmp__._1;
        var __tmp__ = new Rat().setString(_a._y), _y:Ref<Rat> = __tmp__._0, _1:Bool = __tmp__._1;
        var __tmp__ = new Rat().setString(_a._z), _z:Ref<Rat> = __tmp__._0, _2:Bool = __tmp__._1;
        var _out:Ref<Rat> = _f(new Rat(), _x, _y);
        if (_out.cmp(_z) != ((0 : GoInt))) {
            _t.errorf(((("%s #%d got %s want %s" : GoString))), Go.toInterface(_name), Go.toInterface(_i), Go.toInterface(_out), Go.toInterface(_z));
        };
    }
function testRatBin(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _ratBinTests) {
            var _arg:T_ratBinArg = ((new T_ratBinArg(_test._x, _test._y, _test._sum) : T_ratBinArg));
            _testRatBin(_t, _i, ((("Add" : GoString))), (Rat_static_extension).add, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_ratBinArg(_test._y, _test._x, _test._sum) : T_ratBinArg));
            _testRatBin(_t, _i, ((("Add symmetric" : GoString))), (Rat_static_extension).add, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_ratBinArg(_test._sum, _test._x, _test._y) : T_ratBinArg));
            _testRatBin(_t, _i, ((("Sub" : GoString))), (Rat_static_extension).sub, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_ratBinArg(_test._sum, _test._y, _test._x) : T_ratBinArg));
            _testRatBin(_t, _i, ((("Sub symmetric" : GoString))), (Rat_static_extension).sub, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_ratBinArg(_test._x, _test._y, _test._prod) : T_ratBinArg));
            _testRatBin(_t, _i, ((("Mul" : GoString))), (Rat_static_extension).mul, (_arg == null ? null : _arg.__copy__()));
            _arg = ((new T_ratBinArg(_test._y, _test._x, _test._prod) : T_ratBinArg));
            _testRatBin(_t, _i, ((("Mul symmetric" : GoString))), (Rat_static_extension).mul, (_arg == null ? null : _arg.__copy__()));
            if (_test._x != ((("0" : GoString)))) {
                _arg = ((new T_ratBinArg(_test._prod, _test._x, _test._y) : T_ratBinArg));
                _testRatBin(_t, _i, ((("Quo" : GoString))), (Rat_static_extension).quo, (_arg == null ? null : _arg.__copy__()));
            };
            if (_test._y != ((("0" : GoString)))) {
                _arg = ((new T_ratBinArg(_test._prod, _test._y, _test._x) : T_ratBinArg));
                _testRatBin(_t, _i, ((("Quo symmetric" : GoString))), (Rat_static_extension).quo, (_arg == null ? null : _arg.__copy__()));
            };
        };
    }
function testIssue820(_t:stdgo.testing.Testing.T_):Void {
        var _x:Ref<Rat> = newRat(((3 : GoInt64)), ((1 : GoInt64)));
        var _y:Ref<Rat> = newRat(((2 : GoInt64)), ((1 : GoInt64)));
        var _z:Ref<Rat> = _y.quo(_x, _y);
        var _q:Ref<Rat> = newRat(((3 : GoInt64)), ((2 : GoInt64)));
        if (_z.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_q));
        };
        _y = newRat(((3 : GoInt64)), ((1 : GoInt64)));
        _x = newRat(((2 : GoInt64)), ((1 : GoInt64)));
        _z = _y.quo(_x, _y);
        _q = newRat(((2 : GoInt64)), ((3 : GoInt64)));
        if (_z.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_q));
        };
        _x = newRat(((3 : GoInt64)), ((1 : GoInt64)));
        _z = _x.quo(_x, _x);
        _q = newRat(((3 : GoInt64)), ((3 : GoInt64)));
        if (_z.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("got %s want %s" : GoString))), Go.toInterface(_z), Go.toInterface(_q));
        };
    }
function testRatSetFrac64Rat(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _setFrac64Tests) {
            var _x:Ref<Rat> = new Rat().setFrac64(_test._a, _test._b);
            if (_x.ratString() != _test._out) {
                _t.errorf(((("#%d got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_x.ratString()), Go.toInterface(_test._out));
            };
        };
    }
function testIssue2379(_t:stdgo.testing.Testing.T_):Void {
        var _q:Ref<Rat> = newRat(((3 : GoInt64)), ((2 : GoInt64)));
        var _x:Ref<Rat> = new Rat();
        _x.setFrac(newInt(((3 : GoInt64))), newInt(((2 : GoInt64))));
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("1) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q));
        };
        _x = newRat(((2 : GoInt64)), ((3 : GoInt64)));
        _x.setFrac(newInt(((3 : GoInt64))), _x.num());
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("2) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q));
        };
        _x = newRat(((2 : GoInt64)), ((3 : GoInt64)));
        _x.setFrac(_x.denom(), newInt(((2 : GoInt64))));
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("3) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q));
        };
        _x = newRat(((2 : GoInt64)), ((3 : GoInt64)));
        _x.setFrac(_x.denom(), _x.num());
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("4) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q));
        };
        _q = newRat(((1 : GoInt64)), ((1 : GoInt64)));
        _x = new Rat();
        var _n:Ref<Int_> = newInt(((7 : GoInt64)));
        _x.setFrac(_n, _n);
        if (_x.cmp(_q) != ((0 : GoInt))) {
            _t.errorf(((("5) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q));
        };
    }
function testIssue3521(_t:stdgo.testing.Testing.T_):Void {
        var _a:Ref<Int_> = new Int_();
        var _b:Ref<Int_> = new Int_();
        _a.setString(((("64375784358435883458348587" : GoString))), ((0 : GoInt)));
        _b.setString(((("4789759874531" : GoString))), ((0 : GoInt)));
        var _zero:Ref<Rat> = new Rat();
        var _one:Ref<Int_> = newInt(((1 : GoInt64)));
        if (_zero.denom().cmp(_one) != ((0 : GoInt))) {
            _t.errorf(((("0) got %s want %s" : GoString))), Go.toInterface(_zero.denom()), Go.toInterface(_one));
        };
        var _s:Ref<Int_> = _zero._b;
        var _d:Ref<Int_> = _zero.denom();
        if (_d == _s) {
            _t.errorf(((("1a) got %s (%p) == %s (%p) want different *Int values" : GoString))), Go.toInterface(_d), Go.toInterface(_d), Go.toInterface(_s), Go.toInterface(_s));
        };
        var _d1:Ref<Int_> = _zero.denom();
        var _d2:Ref<Int_> = _zero.denom();
        if (_d1 == _d2) {
            _t.errorf(((("1b) got %s (%p) == %s (%p) want different *Int values" : GoString))), Go.toInterface(_d1), Go.toInterface(_d1), Go.toInterface(_d2), Go.toInterface(_d2));
        };
        var _x:Ref<Rat> = new Rat();
        _x.set(_x);
        _s = _x._b;
        _d = _x.denom();
        if (_d != _s) {
            _t.errorf(((("1c) got %s (%p) != %s (%p) want identical *Int values" : GoString))), Go.toInterface(_d), Go.toInterface(_d), Go.toInterface(_s), Go.toInterface(_s));
        };
        _x.denom().set(new Int_().neg(_b));
        if (_x.cmp(_zero) != ((0 : GoInt))) {
            _t.errorf(((("1d) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_zero));
        };
        _x.num().set(_a);
        var _qab:Ref<Rat> = new Rat().setFrac(_a, _b);
        if (_x.cmp(_qab) != ((0 : GoInt))) {
            _t.errorf(((("1e) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_qab));
        };
        _x.setFrac64(((10 : GoInt64)), ((2 : GoInt64)));
        _x.denom().setInt64(((3 : GoInt64)));
        var _q53:Ref<Rat> = newRat(((5 : GoInt64)), ((3 : GoInt64)));
        if (_x.cmp(_q53) != ((0 : GoInt))) {
            _t.errorf(((("2a) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q53));
        };
        _x = newRat(((10 : GoInt64)), ((2 : GoInt64)));
        _x.denom().setInt64(((3 : GoInt64)));
        if (_x.cmp(_q53) != ((0 : GoInt))) {
            _t.errorf(((("2b) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q53));
        };
        _x.setFrac(_a, _b);
        _a = _x.num();
        _b = _x.denom();
        _a.setInt64(((5 : GoInt64)));
        _b.setInt64(((3 : GoInt64)));
        if (_x.cmp(_q53) != ((0 : GoInt))) {
            _t.errorf(((("3) got %s want %s" : GoString))), Go.toInterface(_x), Go.toInterface(_q53));
        };
    }
function testFloat32Distribution(_t:stdgo.testing.Testing.T_):Void {
        var _add:Slice<GoInt64> = ((new Slice<GoInt64>(((0 : GoInt64)), ((1 : GoInt64)), ((3 : GoInt64)), ((5 : GoInt64)), ((7 : GoInt64)), ((9 : GoInt64)), ((11 : GoInt64))) : Slice<GoInt64>));
        var _winc:GoUInt64 = ((((5 : GoUInt64)) : GoUInt64)), _einc:GoInt = ((15 : GoInt));
        if (_long.value) {
            {
                final __tmp__0 = ((((1 : GoUInt64)) : GoUInt64));
                final __tmp__1 = ((1 : GoInt));
                _winc = __tmp__0;
                _einc = __tmp__1;
            };
        };
        for (_0 => _sign in ((("+-" : GoString)))) {
            for (_1 => _a in _add) {
                {
                    var _wid:GoUInt64 = ((((0 : GoUInt64)) : GoUInt64));
                    Go.cfor(_wid < ((30 : GoUInt64)), _wid = _wid + (_winc), {
                        var _b:GoInt64 = (((1 : GoInt64)) << _wid) + _a;
                        if (_sign == ((((("-" : GoString))).code : GoRune))) {
                            _b = -_b;
                        };
                        {
                            var _exp:GoInt = ((-150 : GoInt));
                            Go.cfor(_exp < ((150 : GoInt)), _exp = _exp + (_einc), {
                                var _num:Ref<Int_> = newInt(_b), _den:Ref<Int_> = newInt(((1 : GoInt64)));
                                if (_exp > ((0 : GoInt))) {
                                    _num.lsh(_num, ((_exp : GoUInt)));
                                } else {
                                    _den.lsh(_den, ((-_exp : GoUInt)));
                                };
                                var _r:Ref<Rat> = new Rat().setFrac(_num, _den);
                                var __tmp__ = _r.float32(), _f:GoFloat32 = __tmp__._0, _2:Bool = __tmp__._1;
                                if (!_checkIsBestApprox32(_t, _f, _r)) {
                                    _t.errorf(((("(input was mantissa %#x, exp %d; f = %g (%b); f ~ %g; r = %v)" : GoString))), Go.toInterface(_b), Go.toInterface(_exp), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(stdgo.math.Math.ldexp(((_b : GoFloat64)), _exp)), Go.toInterface(_r));
                                };
                                _checkNonLossyRoundtrip32(_t, _f);
                            });
                        };
                    });
                };
            };
        };
    }
function testFloat64Distribution(_t:stdgo.testing.Testing.T_):Void {
        var _add:Slice<GoInt64> = ((new Slice<GoInt64>(((0 : GoInt64)), ((1 : GoInt64)), ((3 : GoInt64)), ((5 : GoInt64)), ((7 : GoInt64)), ((9 : GoInt64)), ((11 : GoInt64))) : Slice<GoInt64>));
        var _winc:GoUInt64 = ((((10 : GoUInt64)) : GoUInt64)), _einc:GoInt = ((500 : GoInt));
        if (_long.value) {
            {
                final __tmp__0 = ((((1 : GoUInt64)) : GoUInt64));
                final __tmp__1 = ((1 : GoInt));
                _winc = __tmp__0;
                _einc = __tmp__1;
            };
        };
        for (_0 => _sign in ((("+-" : GoString)))) {
            for (_1 => _a in _add) {
                {
                    var _wid:GoUInt64 = ((((0 : GoUInt64)) : GoUInt64));
                    Go.cfor(_wid < ((60 : GoUInt64)), _wid = _wid + (_winc), {
                        var _b:GoInt64 = (((1 : GoInt64)) << _wid) + _a;
                        if (_sign == ((((("-" : GoString))).code : GoRune))) {
                            _b = -_b;
                        };
                        {
                            var _exp:GoInt = ((-1100 : GoInt));
                            Go.cfor(_exp < ((1100 : GoInt)), _exp = _exp + (_einc), {
                                var _num:Ref<Int_> = newInt(_b), _den:Ref<Int_> = newInt(((1 : GoInt64)));
                                if (_exp > ((0 : GoInt))) {
                                    _num.lsh(_num, ((_exp : GoUInt)));
                                } else {
                                    _den.lsh(_den, ((-_exp : GoUInt)));
                                };
                                var _r:Ref<Rat> = new Rat().setFrac(_num, _den);
                                var __tmp__ = _r.float64(), _f:GoFloat64 = __tmp__._0, _2:Bool = __tmp__._1;
                                if (!_checkIsBestApprox64(_t, _f, _r)) {
                                    _t.errorf(((("(input was mantissa %#x, exp %d; f = %g (%b); f ~ %g; r = %v)" : GoString))), Go.toInterface(_b), Go.toInterface(_exp), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(stdgo.math.Math.ldexp(((_b : GoFloat64)), _exp)), Go.toInterface(_r));
                                };
                                _checkNonLossyRoundtrip64(_t, _f);
                            });
                        };
                    });
                };
            };
        };
    }
function testSetFloat64NonFinite(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _f in ((new Slice<GoFloat64>(stdgo.math.Math.naN(), stdgo.math.Math.inf(((1 : GoInt))), stdgo.math.Math.inf(((-1 : GoInt)))) : Slice<GoFloat64>))) {
            var _r:Rat = new Rat();
            {
                var _r2:Ref<Rat> = _r.setFloat64(_f);
                if (_r2 != null) {
                    _t.errorf(((("SetFloat64(%g) was %v, want nil" : GoString))), Go.toInterface(_f), Go.toInterface(_r2));
                };
            };
        };
    }
function _checkNonLossyRoundtrip32(_t:stdgo.testing.Testing.T_, _f:GoFloat32):Void {
        if (!_isFinite(((_f : GoFloat64)))) {
            return;
        };
        var _r:Ref<Rat> = new Rat().setFloat64(((_f : GoFloat64)));
        if (_r == null) {
            _t.errorf(((("Rat.SetFloat64(float64(%g) (%b)) == nil" : GoString))), Go.toInterface(_f), Go.toInterface(_f));
            return;
        };
        var __tmp__ = _r.float32(), _f2:GoFloat32 = __tmp__._0, _exact:Bool = __tmp__._1;
        if ((_f != _f2) || !_exact) {
            _t.errorf(((("Rat.SetFloat64(float64(%g)).Float32() = %g (%b), %v, want %g (%b), %v; delta = %b" : GoString))), Go.toInterface(_f), Go.toInterface(_f2), Go.toInterface(_f2), Go.toInterface(_exact), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(true), Go.toInterface(_f2 - _f));
        };
    }
function _checkNonLossyRoundtrip64(_t:stdgo.testing.Testing.T_, _f:GoFloat64):Void {
        if (!_isFinite(_f)) {
            return;
        };
        var _r:Ref<Rat> = new Rat().setFloat64(_f);
        if (_r == null) {
            _t.errorf(((("Rat.SetFloat64(%g (%b)) == nil" : GoString))), Go.toInterface(_f), Go.toInterface(_f));
            return;
        };
        var __tmp__ = _r.float64(), _f2:GoFloat64 = __tmp__._0, _exact:Bool = __tmp__._1;
        if ((_f != _f2) || !_exact) {
            _t.errorf(((("Rat.SetFloat64(%g).Float64() = %g (%b), %v, want %g (%b), %v; delta = %b" : GoString))), Go.toInterface(_f), Go.toInterface(_f2), Go.toInterface(_f2), Go.toInterface(_exact), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(true), Go.toInterface(_f2 - _f));
        };
    }
function _delta(_r:Rat, _f:GoFloat64):Rat {
        var _d:Ref<Rat> = new Rat().sub(_r, new Rat().setFloat64(_f));
        return _d.abs(_d);
    }
function _checkIsBestApprox32(_t:stdgo.testing.Testing.T_, _f:GoFloat32, _r:Rat):Bool {
        if (stdgo.math.Math.abs(((_f : GoFloat64))) >= ((3.4028234663852886e+38 : GoFloat64))) {
            return true;
        };
        var _f0:GoFloat32 = stdgo.math.Math.nextafter32(_f, ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)));
        var _f1:GoFloat32 = stdgo.math.Math.nextafter32(_f, ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)));
        var _df:Ref<Rat> = _delta(_r, ((_f : GoFloat64)));
        var _df0:Ref<Rat> = _delta(_r, ((_f0 : GoFloat64)));
        var _df1:Ref<Rat> = _delta(_r, ((_f1 : GoFloat64)));
        if (_df.cmp(_df0) > ((0 : GoInt))) {
            _t.errorf(((("Rat(%v).Float32() = %g (%b), but previous float32 %g (%b) is closer" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if (_df.cmp(_df1) > ((0 : GoInt))) {
            _t.errorf(((("Rat(%v).Float32() = %g (%b), but next float32 %g (%b) is closer" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        if ((_df.cmp(_df0) == ((0 : GoInt))) && !_isEven32(_f)) {
            _t.errorf(((("Rat(%v).Float32() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if ((_df.cmp(_df1) == ((0 : GoInt))) && !_isEven32(_f)) {
            _t.errorf(((("Rat(%v).Float32() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        return true;
    }
function _checkIsBestApprox64(_t:stdgo.testing.Testing.T_, _f:GoFloat64, _r:Rat):Bool {
        if (stdgo.math.Math.abs(_f) >= ((1.7976931348623157e+308 : GoFloat64))) {
            return true;
        };
        var _f0:GoFloat64 = stdgo.math.Math.nextafter(_f, stdgo.math.Math.inf(((-1 : GoInt))));
        var _f1:GoFloat64 = stdgo.math.Math.nextafter(_f, stdgo.math.Math.inf(((1 : GoInt))));
        var _df:Ref<Rat> = _delta(_r, _f);
        var _df0:Ref<Rat> = _delta(_r, _f0);
        var _df1:Ref<Rat> = _delta(_r, _f1);
        if (_df.cmp(_df0) > ((0 : GoInt))) {
            _t.errorf(((("Rat(%v).Float64() = %g (%b), but previous float64 %g (%b) is closer" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if (_df.cmp(_df1) > ((0 : GoInt))) {
            _t.errorf(((("Rat(%v).Float64() = %g (%b), but next float64 %g (%b) is closer" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        if ((_df.cmp(_df0) == ((0 : GoInt))) && !_isEven64(_f)) {
            _t.errorf(((("Rat(%v).Float64() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f0), Go.toInterface(_f0));
            return false;
        };
        if ((_df.cmp(_df1) == ((0 : GoInt))) && !_isEven64(_f)) {
            _t.errorf(((("Rat(%v).Float64() = %g (%b); halfway should have rounded to %g (%b) instead" : GoString))), Go.toInterface(_r), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f1), Go.toInterface(_f1));
            return false;
        };
        return true;
    }
function _isEven32(_f:GoFloat32):Bool {
        return (stdgo.math.Math.float32bits(_f) & ((1 : GoUInt32))) == ((0 : GoUInt32));
    }
function _isEven64(_f:GoFloat64):Bool {
        return (stdgo.math.Math.float64bits(_f) & ((1 : GoUInt64))) == ((0 : GoUInt64));
    }
function testIsFinite(_t:stdgo.testing.Testing.T_):Void {
        var _finites:Slice<GoFloat64> = ((new Slice<GoFloat64>(((0.3333333333333333 : GoFloat64)), ((4.8915598712767145e+243 : GoFloat64)), ((1.7976931348623157e+308 : GoFloat64)), ((5e-324 : GoFloat64)), ((-1.7976931348623157e+308 : GoFloat64)), ((-5e-324 : GoFloat64))) : Slice<GoFloat64>));
        for (_0 => _f in _finites) {
            if (!_isFinite(_f)) {
                _t.errorf(((("!IsFinite(%g (%b))" : GoString))), Go.toInterface(_f), Go.toInterface(_f));
            };
        };
        var _nonfinites:Slice<GoFloat64> = ((new Slice<GoFloat64>(stdgo.math.Math.naN(), stdgo.math.Math.inf(((-1 : GoInt))), stdgo.math.Math.inf(((1 : GoInt)))) : Slice<GoFloat64>));
        for (_1 => _f in _nonfinites) {
            if (_isFinite(_f)) {
                _t.errorf(((("IsFinite(%g, (%b))" : GoString))), Go.toInterface(_f), Go.toInterface(_f));
            };
        };
    }
function testRatSetInt64(_t:stdgo.testing.Testing.T_):Void {
        var _testCases:Slice<GoInt64> = ((new Slice<GoInt64>(((0 : GoInt64)), ((1 : GoInt64)), ((-1 : GoInt64)), ((12345 : GoInt64)), ((-98765 : GoInt64)), (("9223372036854775807" : GoInt64)), (("-9223372036854775808" : GoInt64))) : Slice<GoInt64>));
        var _r:Ref<Rat> = new Rat();
        for (_i => _want in _testCases) {
            _r.setInt64(_want);
            if (!_r.isInt()) {
                _t.errorf(((("#%d: Rat.SetInt64(%d) is not an integer" : GoString))), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _num:Ref<Int_> = _r.num();
            if (!_num.isInt64()) {
                _t.errorf(((("#%d: Rat.SetInt64(%d) numerator is not an int64" : GoString))), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _got:GoInt64 = _num.int64();
            if (_got != _want) {
                _t.errorf(((("#%d: Rat.SetInt64(%d) = %d, but expected %d" : GoString))), Go.toInterface(_i), Go.toInterface(_want), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testRatSetUint64(_t:stdgo.testing.Testing.T_):Void {
        var _testCases:Slice<GoUInt64> = ((new Slice<GoUInt64>(((0 : GoUInt64)), ((1 : GoUInt64)), ((12345 : GoUInt64)), (("18446744073709551615" : GoUInt64))) : Slice<GoUInt64>));
        var _r:Ref<Rat> = new Rat();
        for (_i => _want in _testCases) {
            _r.setUint64(_want);
            if (!_r.isInt()) {
                _t.errorf(((("#%d: Rat.SetUint64(%d) is not an integer" : GoString))), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _num:Ref<Int_> = _r.num();
            if (!_num.isUint64()) {
                _t.errorf(((("#%d: Rat.SetUint64(%d) numerator is not a uint64" : GoString))), Go.toInterface(_i), Go.toInterface(_want));
            };
            var _got:GoUInt64 = _num.uint64();
            if (_got != _want) {
                _t.errorf(((("#%d: Rat.SetUint64(%d) = %d, but expected %d" : GoString))), Go.toInterface(_i), Go.toInterface(_want), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function benchmarkRatCmp(_b:stdgo.testing.Testing.B):Void {
        var _x:Ref<Rat> = newRat(((4 : GoInt64)), ((1 : GoInt64))), _y:Ref<Rat> = newRat(((7 : GoInt64)), ((2 : GoInt64)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _b.n, _i++, {
                _x.cmp(_y);
            });
        };
    }
function testIssue34919(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _acc in ((new Slice<T__struct_58>(((new T__struct_58(((("Float32" : GoString))), function(_x:Rat):Void {
            _x.float32();
        }) : T__struct_58)), ((new T__struct_58(((("Float64" : GoString))), function(_x:Rat):Void {
            _x.float64();
        }) : T__struct_58)), ((new T__struct_58(((("Inv" : GoString))), function(_x:Rat):Void {
            new Rat().inv(_x);
        }) : T__struct_58)), ((new T__struct_58(((("Sign" : GoString))), function(_x:Rat):Void {
            _x.sign();
        }) : T__struct_58)), ((new T__struct_58(((("IsInt" : GoString))), function(_x:Rat):Void {
            _x.isInt();
        }) : T__struct_58)), ((new T__struct_58(((("Num" : GoString))), function(_x:Rat):Void {
            _x.num();
        }) : T__struct_58))) : Slice<T__struct_58>))) {
            var _r:Ref<Rat> = ((new Rat(((({ _abs : ((new Slice<Word>(((991 : GoUInt))) : T_nat)), _neg : false } : Int_)) == null ? null : (({ _abs : ((new Slice<Word>(((991 : GoUInt))) : T_nat)), _neg : false } : Int_)).__copy__()), ((({ _abs : (new Slice<Word>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) new Word()]).__setCap__(((((1 : GoInt)) : GoInt)).toBasic()) == null ? null : new Slice<Word>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) new Word()]).__setCap__(((((1 : GoInt)) : GoInt)).toBasic()).__copy__()), _neg : false } : Int_)) == null ? null : (({ _abs : (new Slice<Word>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) new Word()]).__setCap__(((((1 : GoInt)) : GoInt)).toBasic()) == null ? null : new Slice<Word>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) new Word()]).__setCap__(((((1 : GoInt)) : GoInt)).toBasic()).__copy__()), _neg : false } : Int_)).__copy__())) : Rat));
            _acc._f(_r);
            {
                var _d:Word = (((_r._b._abs.__slice__(0, ((1 : GoInt))) : T_nat)) != null ? ((_r._b._abs.__slice__(0, ((1 : GoInt))) : T_nat))[((0 : GoInt))] : new Word());
                if (_d != ((0 : GoUInt))) {
                    _t.errorf(((("%s modified denominator: got %d, want 0" : GoString))), Go.toInterface(_acc._name), Go.toInterface(_d));
                };
            };
        };
    }
function testDenomRace(_t:stdgo.testing.Testing.T_):Void {
        var _x:Ref<Rat> = newRat(((1 : GoInt64)), ((2 : GoInt64)));
        {};
        var _c:Chan<Bool> = new Chan<Bool>(((((3 : GoInt)) : GoInt)).toBasic(), () -> false);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((3 : GoInt)), _i++, {
                Go.routine(() -> {
                    var a = function():Void {
                        _x.denom();
                        new Float_().setRat(_x);
                        _c.__send__(true);
                    };
                    a();
                });
            });
        };
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((3 : GoInt)), _i++, {
                _c.__get__();
            });
        };
    }
function _ratTok(_ch:GoRune):Bool {
        return stdgo.strings.Strings.containsRune(((("+-/0123456789.eE" : GoString))), _ch);
    }
function _scanExponent(_r:stdgo.io.Io.ByteScanner, _base2ok:Bool, _sepOk:Bool):{ var _0 : GoInt64; var _1 : GoInt; var _2 : Error; } {
        var _exp:GoInt64 = ((0 : GoInt64)), _base:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            if (_err == stdgo.io.Io.eof) {
                _err = ((null : stdgo.Error));
            };
            return { _0 : ((0 : GoInt64)), _1 : ((10 : GoInt)), _2 : _err };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ch == ((((("e" : GoString))).code : GoRune)) || _ch == ((((("E" : GoString))).code : GoRune)))) {
                    _base = ((10 : GoInt));
                    break;
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ch == ((((("p" : GoString))).code : GoRune)) || _ch == ((((("P" : GoString))).code : GoRune)))) {
                    if (_base2ok) {
                        _base = ((2 : GoInt));
                        break;
                    };
                    @:fallthrough {
                        __switchIndex__ = 2;
                        continue;
                    };
                    break;
                } else {
                    _r.unreadByte();
                    return { _0 : ((0 : GoInt64)), _1 : ((10 : GoInt)), _2 : ((null : stdgo.Error)) };
                    break;
                };
                break;
            };
        };
        var _digits:Slice<GoByte> = ((null : Slice<GoUInt8>));
        {
            var __tmp__ = _r.readByte();
            _ch = __tmp__._0;
            _err = __tmp__._1;
        };
        if ((_err == null) && ((_ch == ((((("+" : GoString))).code : GoRune))) || (_ch == ((((("-" : GoString))).code : GoRune))))) {
            if (_ch == ((((("-" : GoString))).code : GoRune))) {
                _digits = (_digits != null ? _digits.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        var _prev:GoInt32 = ((((("." : GoString))).code : GoRune));
        var _invalSep:Bool = false;
        var _hasDigits:Bool = false;
        while (_err == null) {
            if ((((((("0" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("9" : GoString))).code : GoRune)))) {
                _digits = (_digits != null ? _digits.__append__(_ch) : new Slice<GoUInt8>(_ch));
                _prev = ((((("0" : GoString))).code : GoRune));
                _hasDigits = true;
            } else if ((_ch == ((((("_" : GoString))).code : GoRune))) && _sepOk) {
                if (_prev != ((((("0" : GoString))).code : GoRune))) {
                    _invalSep = true;
                };
                _prev = ((((("_" : GoString))).code : GoRune));
            } else {
                _r.unreadByte();
                break;
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if (_err == stdgo.io.Io.eof) {
            _err = ((null : stdgo.Error));
        };
        if ((_err == null) && !_hasDigits) {
            _err = _errNoDigits;
        };
        if (_err == null) {
            {
                var __tmp__ = stdgo.strconv.Strconv.parseInt(((_digits : GoString)), ((10 : GoInt)), ((64 : GoInt)));
                _exp = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if ((_err == null) && (_invalSep || (_prev == ((((("_" : GoString))).code : GoRune))))) {
            _err = _errInvalSep;
        };
        return { _0 : _exp, _1 : _base, _2 : _err };
    }
function testScanExponent(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _a in _exponentTests) {
            var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_a._s);
            var __tmp__ = _scanExponent(_r, _a._base2ok, _a._sepOk), _x:GoInt64 = __tmp__._0, _b:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err != _a._err) {
                _t.errorf(((("scanExponent%+v\n\tgot error = %v; want %v" : GoString))), Go.toInterface(_a), Go.toInterface(_err), Go.toInterface(_a._err));
            };
            if (_x != _a._x) {
                _t.errorf(((("scanExponent%+v\n\tgot z = %v; want %v" : GoString))), Go.toInterface(_a), Go.toInterface(_x), Go.toInterface(_a._x));
            };
            if (_b != _a._b) {
                _t.errorf(((("scanExponent%+v\n\tgot b = %d; want %d" : GoString))), Go.toInterface(_a), Go.toInterface(_b), Go.toInterface(_a._b));
            };
            var __tmp__ = _r.readRune(), _next:GoInt32 = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err == stdgo.io.Io.eof) {
                _next = ((0 : GoInt32));
                _err = ((null : stdgo.Error));
            };
            if ((_err == null) && (_next != _a._next)) {
                _t.errorf(((("scanExponent%+v\n\tgot next = %q; want %q" : GoString))), Go.toInterface(_a), Go.toInterface(_next), Go.toInterface(_a._next));
            };
        };
    }
function testRatSetString(_t:stdgo.testing.Testing.T_):Void {
        var _tests:Slice<StringTest> = ((null : Slice<StringTest>));
        _tests = (_tests != null ? _tests.__append__(..._setStringTests.__toArray__()) : new Slice<StringTest>(..._setStringTests.__toArray__()));
        _tests = (_tests != null ? _tests.__append__(..._setStringTests2.__toArray__()) : new Slice<StringTest>(..._setStringTests2.__toArray__()));
        for (_i => _test in _tests) {
            var __tmp__ = new Rat().setString(_test._in), _x:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (_ok) {
                if (!_test._ok) {
                    _t.errorf(((("#%d SetString(%q) expected failure" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in));
                } else if (_x.ratString() != _test._out) {
                    _t.errorf(((("#%d SetString(%q) got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_x.ratString()), Go.toInterface(_test._out));
                };
            } else {
                if (_test._ok) {
                    _t.errorf(((("#%d SetString(%q) expected success" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in));
                } else if (_x != null) {
                    _t.errorf(((("#%d SetString(%q) got %p want nil" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_x));
                };
            };
        };
    }
function testRatScan(_t:stdgo.testing.Testing.T_):Void {
        var _buf:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        for (_i => _test in _setStringTests) {
            var _x:Ref<Rat> = new Rat();
            _buf.reset();
            _buf.writeString(_test._in);
            var __tmp__ = stdgo.fmt.Fmt.fscanf(_buf, ((("%v" : GoString))), Go.toInterface(_x)), _0:GoInt = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if ((_err == null) != _test._ok) {
                if (_test._ok) {
                    _t.errorf(((("#%d (%s) error: %s" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in), Go.toInterface(_err));
                } else {
                    _t.errorf(((("#%d (%s) expected error" : GoString))), Go.toInterface(_i), Go.toInterface(_test._in));
                };
                continue;
            };
            if ((_err == null) && (_x.ratString() != _test._out)) {
                _t.errorf(((("#%d got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_x.ratString()), Go.toInterface(_test._out));
            };
        };
    }
function testFloatString(_t:stdgo.testing.Testing.T_):Void {
        for (_i => _test in _floatStringTests) {
            var __tmp__ = new Rat().setString(_test._in), _x:Ref<Rat> = __tmp__._0, _0:Bool = __tmp__._1;
            if (_x.floatString(_test._prec) != _test._out) {
                _t.errorf(((("#%d got %s want %s" : GoString))), Go.toInterface(_i), Go.toInterface(_x.floatString(_test._prec)), Go.toInterface(_test._out));
            };
        };
    }
function _isFinite(_f:GoFloat64):Bool {
        return stdgo.math.Math.abs(_f) <= ((1.7976931348623157e+308 : GoFloat64));
    }
function testFloat32SpecialCases(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _input in _float64inputs) {
            if (stdgo.strings.Strings.hasPrefix(_input, ((("long:" : GoString))))) {
                if (!_long.value) {
                    continue;
                };
                _input = ((_input.__slice__((((("long:" : GoString))) != null ? ((("long:" : GoString))).length : ((0 : GoInt)))) : GoString));
            };
            var __tmp__ = new Rat().setString(_input), _r:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("Rat.SetString(%q) failed" : GoString))), Go.toInterface(_input));
                continue;
            };
            var __tmp__ = _r.float32(), _f:GoFloat32 = __tmp__._0, _exact:Bool = __tmp__._1;
            if (!stdgo.strings.Strings.contains(_input, ((("/" : GoString))))) {
                var __tmp__ = stdgo.strconv.Strconv.parseFloat(_input, ((32 : GoInt))), _e64:GoFloat64 = __tmp__._0, _1:stdgo.Error = __tmp__._1;
                var _e:GoFloat32 = ((_e64 : GoFloat32));
                if (stdgo.math.Math.float32bits(_e) == stdgo.math.Math.float32bits(_f)) {} else if ((_f == ((0 : GoFloat32))) && (_r.num().bitLen() == ((0 : GoInt)))) {} else {
                    _t.errorf(((("strconv.ParseFloat(%q) = %g (%b), want %g (%b); delta = %g" : GoString))), Go.toInterface(_input), Go.toInterface(_e), Go.toInterface(_e), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f - _e));
                };
            };
            if (!_isFinite(((_f : GoFloat64)))) {
                continue;
            };
            if (!_checkIsBestApprox32(_t, _f, _r)) {
                _t.errorf(((("(input was %q)" : GoString))), Go.toInterface(_input));
            };
            _checkNonLossyRoundtrip32(_t, _f);
            {
                var _wasExact:Bool = new Rat().setFloat64(((_f : GoFloat64))).cmp(_r) == ((0 : GoInt));
                if (_wasExact != _exact) {
                    _t.errorf(((("Rat.SetString(%q).Float32().exact = %t, want %t" : GoString))), Go.toInterface(_input), Go.toInterface(_exact), Go.toInterface(_wasExact));
                };
            };
        };
    }
function testFloat64SpecialCases(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _input in _float64inputs) {
            if (stdgo.strings.Strings.hasPrefix(_input, ((("long:" : GoString))))) {
                if (!_long.value) {
                    continue;
                };
                _input = ((_input.__slice__((((("long:" : GoString))) != null ? ((("long:" : GoString))).length : ((0 : GoInt)))) : GoString));
            };
            var __tmp__ = new Rat().setString(_input), _r:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                _t.errorf(((("Rat.SetString(%q) failed" : GoString))), Go.toInterface(_input));
                continue;
            };
            var __tmp__ = _r.float64(), _f:GoFloat64 = __tmp__._0, _exact:Bool = __tmp__._1;
            if (!stdgo.strings.Strings.contains(_input, ((("/" : GoString))))) {
                var __tmp__ = stdgo.strconv.Strconv.parseFloat(_input, ((64 : GoInt))), _e:GoFloat64 = __tmp__._0, _1:stdgo.Error = __tmp__._1;
                if (stdgo.math.Math.float64bits(_e) == stdgo.math.Math.float64bits(_f)) {} else if ((_f == ((0 : GoFloat64))) && (_r.num().bitLen() == ((0 : GoInt)))) {} else {
                    _t.errorf(((("strconv.ParseFloat(%q) = %g (%b), want %g (%b); delta = %g" : GoString))), Go.toInterface(_input), Go.toInterface(_e), Go.toInterface(_e), Go.toInterface(_f), Go.toInterface(_f), Go.toInterface(_f - _e));
                };
            };
            if (!_isFinite(_f)) {
                continue;
            };
            if (!_checkIsBestApprox64(_t, _f, _r)) {
                _t.errorf(((("(input was %q)" : GoString))), Go.toInterface(_input));
            };
            _checkNonLossyRoundtrip64(_t, _f);
            {
                var _wasExact:Bool = new Rat().setFloat64(_f).cmp(_r) == ((0 : GoInt));
                if (_wasExact != _exact) {
                    _t.errorf(((("Rat.SetString(%q).Float64().exact = %t, want %t" : GoString))), Go.toInterface(_input), Go.toInterface(_exact), Go.toInterface(_wasExact));
                };
            };
        };
    }
function testIssue31184(_t:stdgo.testing.Testing.T_):Void {
        var _x:Rat = new Rat();
        for (_0 => _want in ((new Slice<GoString>(((("-213.090" : GoString))), ((("8.192" : GoString))), ((("16.000" : GoString)))) : Slice<GoString>))) {
            _x.setString(_want);
            var _got:GoString = _x.floatString(((3 : GoInt)));
            if (_got != _want) {
                _t.errorf(((("got %s, want %s" : GoString))), Go.toInterface(_got), Go.toInterface(_want));
            };
        };
    }
function testIssue45910(_t:stdgo.testing.Testing.T_):Void {
        var _x:Rat = new Rat();
        for (_0 => _test in ((new Slice<T__struct_61>(((new T__struct_61(((("1e-1000001" : GoString))), false) : T__struct_61)), ((new T__struct_61(((("1e-1000000" : GoString))), true) : T__struct_61)), ((new T__struct_61(((("1e+1000000" : GoString))), true) : T__struct_61)), ((new T__struct_61(((("1e+1000001" : GoString))), false) : T__struct_61)), ((new T__struct_61(((("0p1000000000000" : GoString))), true) : T__struct_61)), ((new T__struct_61(((("1p-10000001" : GoString))), false) : T__struct_61)), ((new T__struct_61(((("1p-10000000" : GoString))), true) : T__struct_61)), ((new T__struct_61(((("1p+10000000" : GoString))), true) : T__struct_61)), ((new T__struct_61(((("1p+10000001" : GoString))), false) : T__struct_61)), ((new T__struct_61(((("1.770p02041010010011001001" : GoString))), false) : T__struct_61))) : Slice<T__struct_61>))) {
            var __tmp__ = _x.setString(_test._input), _1:Ref<Rat> = __tmp__._0, _got:Bool = __tmp__._1;
            if (_got != _test._want) {
                _t.errorf(((("SetString(%s) got ok = %v; want %v" : GoString))), Go.toInterface(_test._input), Go.toInterface(_got), Go.toInterface(_test._want));
            };
        };
    }
function testRatGobEncoding(_t:stdgo.testing.Testing.T_):Void {
        var _medium:stdgo.bytes.Bytes.Buffer = new stdgo.bytes.Bytes.Buffer();
        var _enc:Ref<stdgo.encoding.gob.Gob.Encoder> = stdgo.encoding.gob.Gob.newEncoder(_medium);
        var _dec:Ref<stdgo.encoding.gob.Gob.Decoder> = stdgo.encoding.gob.Gob.newDecoder(_medium);
        for (_0 => _test in _encodingTests) {
            _medium.reset();
            var _tx:Rat = new Rat();
            _tx.setString(_test + (((".14159265" : GoString))));
            {
                var _err:stdgo.Error = _enc.encode(Go.toInterface(_tx));
                if (_err != null) {
                    _t.errorf(((("encoding of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                    continue;
                };
            };
            var _rx:Rat = new Rat();
            {
                var _err:stdgo.Error = _dec.decode(Go.toInterface(_rx));
                if (_err != null) {
                    _t.errorf(((("decoding of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                    continue;
                };
            };
            if (_rx.cmp(_tx) != ((0 : GoInt))) {
                _t.errorf(((("transmission of %s failed: got %s want %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_rx), Go.toInterface(_tx));
            };
        };
    }
function testGobEncodingNilRatInSlice(_t:stdgo.testing.Testing.T_):Void {
        var _buf:Ref<stdgo.bytes.Bytes.Buffer> = new stdgo.bytes.Bytes.Buffer();
        var _enc:Ref<stdgo.encoding.gob.Gob.Encoder> = stdgo.encoding.gob.Gob.newEncoder(_buf);
        var _dec:Ref<stdgo.encoding.gob.Gob.Decoder> = stdgo.encoding.gob.Gob.newDecoder(_buf);
        var _in:Slice<Ref<Rat>> = new Slice<Ref<Rat>>(...[for (i in 0 ... ((((1 : GoInt)) : GoInt)).toBasic()) ((null : Ref<Rat>))]);
        var _err:stdgo.Error = _enc.encode(Go.toInterface(_in));
        if (_err != null) {
            _t.errorf(((("gob encode failed: %q" : GoString))), Go.toInterface(_err));
        };
        var _out:Slice<Rat> = ((null : Slice<Ref<Rat>>));
        _err = _dec.decode(Go.toInterface(_out));
        if (_err != null) {
            _t.fatalf(((("gob decode failed: %q" : GoString))), Go.toInterface(_err));
        };
        if ((_out != null ? _out.length : ((0 : GoInt))) != ((1 : GoInt))) {
            _t.fatalf(((("wrong len; want 1 got %d" : GoString))), Go.toInterface((_out != null ? _out.length : ((0 : GoInt)))));
        };
        var _zero:Rat = new Rat();
        if ((_out != null ? _out[((0 : GoInt))] : ((null : Ref<Rat>))).cmp(_zero) != ((0 : GoInt))) {
            _t.fatalf(((("transmission of (*Int)(nil) failed: got %s want 0" : GoString))), Go.toInterface(_out));
        };
    }
function testRatJSONEncoding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _num in _ratNums) {
            for (_1 => _denom in _ratDenoms) {
                var _tx:Rat = new Rat();
                _tx.setString((_num + ((("/" : GoString)))) + _denom);
                var __tmp__ = stdgo.encoding.json.Json.marshal(Go.toInterface(_tx)), _b:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(((("marshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                    continue;
                };
                var _rx:Rat = new Rat();
                {
                    var _err:stdgo.Error = stdgo.encoding.json.Json.unmarshal(_b, Go.toInterface(_rx));
                    if (_err != null) {
                        _t.errorf(((("unmarshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp(_tx) != ((0 : GoInt))) {
                    _t.errorf(((("JSON encoding of %s failed: got %s want %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_rx), Go.toInterface(_tx));
                };
            };
        };
    }
function testRatXMLEncoding(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _num in _ratNums) {
            for (_1 => _denom in _ratDenoms) {
                var _tx:Rat = new Rat();
                _tx.setString((_num + ((("/" : GoString)))) + _denom);
                var __tmp__ = stdgo.encoding.xml.Xml_.marshal(Go.toInterface(_tx)), _b:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
                if (_err != null) {
                    _t.errorf(((("marshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                    continue;
                };
                var _rx:Rat = new Rat();
                {
                    var _err:stdgo.Error = stdgo.encoding.xml.Xml_.unmarshal(_b, Go.toInterface(_rx));
                    if (_err != null) {
                        _t.errorf(((("unmarshaling of %s failed: %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_err));
                        continue;
                    };
                };
                if (_rx.cmp(_tx) != ((0 : GoInt))) {
                    _t.errorf(((("XML encoding of %s failed: got %s want %s" : GoString))), Go.toInterface(_tx), Go.toInterface(_rx), Go.toInterface(_tx));
                };
            };
        };
    }
function _three():Float_ {
        _threeOnce.do_(function():Void {
            _threeOnce._v = newFloat(((3 : GoFloat64)));
        });
        return _threeOnce._v;
    }
function _newFloat(_prec2:GoUInt32):Float_ {
        var _z:Ref<Float_> = new Float_();
        _z._mant = (_z._mant._make((((_prec2 / ((32 : GoUInt32))) : GoInt)) * ((2 : GoInt))) == null ? null : _z._mant._make((((_prec2 / ((32 : GoUInt32))) : GoInt)) * ((2 : GoInt))).__copy__());
        return _z;
    }
function testFloatSqrt64(_t:stdgo.testing.Testing.T_):Void {
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((100000 : GoInt)), _i++, {
                if ((_i == ((100 : GoInt))) && stdgo.testing.Testing.short()) {
                    break;
                };
                var _r:GoFloat64 = stdgo.math.rand.Rand.float64();
                var _got:Ref<Float_> = new Float_().setPrec(((53 : GoUInt)));
                _got.sqrt(newFloat(_r));
                var _want:Ref<Float_> = newFloat(stdgo.math.Math.sqrt(_r));
                if (_got.cmp(_want) != ((0 : GoInt))) {
                    _t.fatalf(((("Sqrt(%g) =\n got %g;\nwant %g" : GoString))), Go.toInterface(_r), Go.toInterface(_got), Go.toInterface(_want));
                };
            });
        };
    }
function testFloatSqrt(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_63>(
((new T__struct_63(((("0.03125" : GoString))), ((("0.17677669529663688110021109052621225982120898442211850914708496724884155980776337985629844179095519659187673077886403712811560450698134215158051518713749197892665283324093819909447499381264409775757143376369499645074628431682460775184106467733011114982619404115381053858929018135497032545349940642599871090667456829147610370507757690729404938184321879" : GoString)))) : T__struct_63)),
((new T__struct_63(((("0.125" : GoString))), ((("0.35355339059327376220042218105242451964241796884423701829416993449768311961552675971259688358191039318375346155772807425623120901396268430316103037427498395785330566648187639818894998762528819551514286752738999290149256863364921550368212935466022229965238808230762107717858036270994065090699881285199742181334913658295220741015515381458809876368643757" : GoString)))) : T__struct_63)),
((new T__struct_63(((("0.5" : GoString))), ((("0.70710678118654752440084436210484903928483593768847403658833986899536623923105351942519376716382078636750692311545614851246241802792536860632206074854996791570661133296375279637789997525057639103028573505477998580298513726729843100736425870932044459930477616461524215435716072541988130181399762570399484362669827316590441482031030762917619752737287514" : GoString)))) : T__struct_63)),
((new T__struct_63(((("2.0" : GoString))), ((("1.4142135623730950488016887242096980785696718753769480731766797379907324784621070388503875343276415727350138462309122970249248360558507372126441214970999358314132226659275055927557999505011527820605714701095599716059702745345968620147285174186408891986095523292304843087143214508397626036279952514079896872533965463318088296406206152583523950547457503" : GoString)))) : T__struct_63)),
((new T__struct_63(((("3.0" : GoString))), ((("1.7320508075688772935274463415058723669428052538103806280558069794519330169088000370811461867572485756756261414154067030299699450949989524788116555120943736485280932319023055820679748201010846749232650153123432669033228866506722546689218379712270471316603678615880190499865373798593894676503475065760507566183481296061009476021871903250831458295239598" : GoString)))) : T__struct_63)),
((new T__struct_63(((("4.0" : GoString))), ((("2.0" : GoString)))) : T__struct_63)),
((new T__struct_63(((("1p512" : GoString))), ((("1p256" : GoString)))) : T__struct_63)),
((new T__struct_63(((("4p1024" : GoString))), ((("2p512" : GoString)))) : T__struct_63)),
((new T__struct_63(((("9p2048" : GoString))), ((("3p1024" : GoString)))) : T__struct_63)),
((new T__struct_63(((("1p-1024" : GoString))), ((("1p-512" : GoString)))) : T__struct_63)),
((new T__struct_63(((("4p-2048" : GoString))), ((("2p-1024" : GoString)))) : T__struct_63)),
((new T__struct_63(((("9p-4096" : GoString))), ((("3p-2048" : GoString)))) : T__struct_63))) : Slice<T__struct_63>))) {
            for (_1 => _prec in ((new Slice<GoUInt>(
((24 : GoUInt)),
((53 : GoUInt)),
((64 : GoUInt)),
((65 : GoUInt)),
((100 : GoUInt)),
((128 : GoUInt)),
((129 : GoUInt)),
((200 : GoUInt)),
((256 : GoUInt)),
((400 : GoUInt)),
((600 : GoUInt)),
((800 : GoUInt)),
((1000 : GoUInt))) : Slice<GoUInt>))) {
                var _x:Ref<Float_> = new Float_().setPrec(_prec);
                _x.parse(_test._x, ((10 : GoInt)));
                var _got:Ref<Float_> = new Float_().setPrec(_prec).sqrt(_x);
                var _want:Ref<Float_> = new Float_().setPrec(_prec);
                _want.parse(_test._want, ((10 : GoInt)));
                if (_got.cmp(_want) != ((0 : GoInt))) {
                    _t.errorf(((("prec = %d, Sqrt(%v) =\ngot  %g;\nwant %g" : GoString))), Go.toInterface(_prec), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_want));
                };
                var _sq:Ref<Float_> = new Float_().setPrec(_prec + ((32 : GoUInt))).mul(_got, _got);
                var _diff:Ref<Float_> = new Float_().sub(_sq, _x);
                var _err:Ref<Float_> = _diff.abs(_diff).setPrec(_prec);
                var _one:Ref<Float_> = new Float_().setPrec(_prec).setInt64(((1 : GoInt64)));
                var _maxErr:Ref<Float_> = new Float_().mul(new Float_().setMantExp(_one, -((_prec : GoInt)) + ((1 : GoInt))), _got);
                if (_err.cmp(_maxErr) >= ((0 : GoInt))) {
                    _t.errorf(((("prec = %d, Sqrt(%v) =\ngot err  %g;\nwant maxErr %g" : GoString))), Go.toInterface(_prec), Go.toInterface(_test._x), Go.toInterface(_err), Go.toInterface(_maxErr));
                };
            };
        };
    }
function testFloatSqrtSpecial(_t:stdgo.testing.Testing.T_):Void {
        for (_0 => _test in ((new Slice<T__struct_64>(((new T__struct_64(newFloat(((0 : GoFloat64))), newFloat(((0 : GoFloat64)))) : T__struct_64)), ((new T__struct_64(newFloat(((0 : GoFloat64))), newFloat(((0 : GoFloat64)))) : T__struct_64)), ((new T__struct_64(newFloat(stdgo.math.Math.inf(((1 : GoInt)))), newFloat(stdgo.math.Math.inf(((1 : GoInt))))) : T__struct_64))) : Slice<T__struct_64>))) {
            var _got:Ref<Float_> = new Float_().sqrt(_test._x);
            if ((_got._neg != _test._want._neg) || (_got._form != _test._want._form)) {
                _t.errorf(((("Sqrt(%v) = %v (neg: %v); want %v (neg: %v)" : GoString))), Go.toInterface(_test._x), Go.toInterface(_got), Go.toInterface(_got._neg), Go.toInterface(_test._want), Go.toInterface(_test._want._neg));
            };
        };
    }
function benchmarkFloatSqrt(_b:stdgo.testing.Testing.B):Void {
        for (_0 => _prec in ((new Slice<GoUInt>(((64 : GoUInt)), ((128 : GoUInt)), ((256 : GoUInt)), ((1000 : GoUInt)), ((10000 : GoUInt)), ((100000 : GoUInt)), ((1e+06 : GoUInt))) : Slice<GoUInt>))) {
            var _x:Ref<Float_> = newFloat(((2 : GoFloat64)));
            var _z:Ref<Float_> = new Float_().setPrec(_prec);
            _b.run(stdgo.fmt.Fmt.sprintf(((("%v" : GoString))), Go.toInterface(_prec)), function(_b:stdgo.testing.Testing.B):Void {
                _b.reportAllocs();
                {
                    var _n:GoInt = ((0 : GoInt));
                    Go.cfor(_n < _b.n, _n++, {
                        _z.sqrt(_x);
                    });
                };
            });
        };
    }
class T_argVV_wrapper {
    public var __t__ : T_argVV;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_argVW_wrapper {
    public var __t__ : T_argVW;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_argVU_wrapper {
    public var __t__ : T_argVU;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_argVWW_wrapper {
    public var __t__ : T_argVWW;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_argWVW_wrapper {
    public var __t__ : T_argWVW;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_decimal_wrapper {
    @:keep
    public function _roundDown(_n:GoInt):Void {
        var _x = __t__;
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        _x._mant = ((_x._mant.__slice__(0, _n) : Slice<GoUInt8>));
        _trim(_x);
    }
    @:keep
    public function _roundUp(_n:GoInt):Void {
        var _x = __t__;
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        while ((_n > ((0 : GoInt))) && ((_x._mant != null ? _x._mant[_n - ((1 : GoInt))] : ((0 : GoUInt8))) >= ((((("9" : GoString))).code : GoRune)))) {
            _n--;
        };
        if (_n == ((0 : GoInt))) {
            if (_x._mant != null) _x._mant[((0 : GoInt))] = ((((("1" : GoString))).code : GoRune));
            _x._mant = ((_x._mant.__slice__(0, ((1 : GoInt))) : Slice<GoUInt8>));
            _x._exp++;
            return;
        };
        if (_x._mant != null) _x._mant[_n - ((1 : GoInt))]++;
        _x._mant = ((_x._mant.__slice__(0, _n) : Slice<GoUInt8>));
    }
    @:keep
    public function _round(_n:GoInt):Void {
        var _x = __t__;
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        if (_shouldRoundUp(_x, _n)) {
            _x._roundUp(_n);
        } else {
            _x._roundDown(_n);
        };
    }
    @:keep
    public function toString():GoString {
        var _x = __t__;
        _x;
        if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((("0" : GoString)));
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        if (_x._exp <= ((0 : GoInt))) {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__((((((2 : GoInt)) + (-_x._exp)) + (_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(...((("0." : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0." : GoString))).__toArray__()));
            _buf = _appendZeros(_buf, -_x._exp);
            _buf = (_buf != null ? _buf.__append__(..._x._mant.__toArray__()) : new Slice<GoUInt8>(..._x._mant.__toArray__()));
        } else if (_x._exp < (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((((1 : GoInt)) + (_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(...((_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>)).__toArray__()));
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            _buf = (_buf != null ? _buf.__append__(...((_x._mant.__slice__(_x._exp) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_x._mant.__slice__(_x._exp) : Slice<GoUInt8>)).__toArray__()));
        } else {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((_x._exp : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(..._x._mant.__toArray__()) : new Slice<GoUInt8>(..._x._mant.__toArray__()));
            _buf = _appendZeros(_buf, _x._exp - (_x._mant != null ? _x._mant.length : ((0 : GoInt))));
        };
        return ((_buf : GoString));
    }
    @:keep
    public function _init(_m:T_nat, _shift:GoInt):Void {
        var _x = __t__;
        _x;
        if ((_m != null ? _m.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _x._mant = ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>));
            _x._exp = ((0 : GoInt));
            return;
        };
        if (_shift < ((0 : GoInt))) {
            var _ntz:GoUInt = _m._trailingZeroBits();
            var _s:GoUInt = ((-_shift : GoUInt));
            if (_s >= _ntz) {
                _s = _ntz;
            };
            _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _s) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _s).__copy__());
            _shift = _shift + (((_s : GoInt)));
        };
        if (_shift > ((0 : GoInt))) {
            _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), ((_shift : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), ((_shift : GoUInt))).__copy__());
            _shift = ((0 : GoInt));
        };
        var _s:Slice<GoUInt8> = _m._utoa(((10 : GoInt)));
        var _n:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        _x._exp = _n;
        while ((_n > ((0 : GoInt))) && ((_s != null ? _s[_n - ((1 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) {
            _n--;
        };
        _x._mant = (((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>)) != null ? ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>)).__append__(...((_s.__slice__(0, _n) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_s.__slice__(0, _n) : Slice<GoUInt8>)).__toArray__()));
        if (_shift < ((0 : GoInt))) {
            while (_shift < ((-28 : GoInt))) {
                _shr(_x, ((28 : GoUInt)));
                _shift = _shift + (((28 : GoInt)));
            };
            _shr(_x, ((-_shift : GoUInt)));
        };
    }
    @:keep
    public function _at(_i:GoInt):GoByte {
        var _d = __t__;
        _d;
        if ((((0 : GoInt)) <= _i) && (_i < (_d._mant != null ? _d._mant.length : ((0 : GoInt))))) {
            return (_d._mant != null ? _d._mant[_i] : ((0 : GoUInt8)));
        };
        return ((((("0" : GoString))).code : GoRune));
    }
    public var __t__ : T_decimal;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class T_decimal_static_extension {
    @:keep
    public static function _roundDown(_x:Ref<T_decimal>, _n:GoInt):Void {
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        _x._mant = ((_x._mant.__slice__(0, _n) : Slice<GoUInt8>));
        _trim(_x);
    }
    @:keep
    public static function _roundUp(_x:Ref<T_decimal>, _n:GoInt):Void {
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        while ((_n > ((0 : GoInt))) && ((_x._mant != null ? _x._mant[_n - ((1 : GoInt))] : ((0 : GoUInt8))) >= ((((("9" : GoString))).code : GoRune)))) {
            _n--;
        };
        if (_n == ((0 : GoInt))) {
            if (_x._mant != null) _x._mant[((0 : GoInt))] = ((((("1" : GoString))).code : GoRune));
            _x._mant = ((_x._mant.__slice__(0, ((1 : GoInt))) : Slice<GoUInt8>));
            _x._exp++;
            return;
        };
        if (_x._mant != null) _x._mant[_n - ((1 : GoInt))]++;
        _x._mant = ((_x._mant.__slice__(0, _n) : Slice<GoUInt8>));
    }
    @:keep
    public static function _round(_x:Ref<T_decimal>, _n:GoInt):Void {
        _x;
        if ((_n < ((0 : GoInt))) || (_n >= (_x._mant != null ? _x._mant.length : ((0 : GoInt))))) {
            return;
        };
        if (_shouldRoundUp(_x, _n)) {
            _x._roundUp(_n);
        } else {
            _x._roundDown(_n);
        };
    }
    @:keep
    public static function toString(_x:Ref<T_decimal>):GoString {
        _x;
        if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((("0" : GoString)));
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        if (_x._exp <= ((0 : GoInt))) {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__((((((2 : GoInt)) + (-_x._exp)) + (_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(...((("0." : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0." : GoString))).__toArray__()));
            _buf = _appendZeros(_buf, -_x._exp);
            _buf = (_buf != null ? _buf.__append__(..._x._mant.__toArray__()) : new Slice<GoUInt8>(..._x._mant.__toArray__()));
        } else if (_x._exp < (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((((1 : GoInt)) + (_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(...((_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_x._mant.__slice__(0, _x._exp) : Slice<GoUInt8>)).__toArray__()));
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            _buf = (_buf != null ? _buf.__append__(...((_x._mant.__slice__(_x._exp) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_x._mant.__slice__(_x._exp) : Slice<GoUInt8>)).__toArray__()));
        } else {
            _buf = new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((_x._exp : GoInt)).toBasic());
            _buf = (_buf != null ? _buf.__append__(..._x._mant.__toArray__()) : new Slice<GoUInt8>(..._x._mant.__toArray__()));
            _buf = _appendZeros(_buf, _x._exp - (_x._mant != null ? _x._mant.length : ((0 : GoInt))));
        };
        return ((_buf : GoString));
    }
    @:keep
    public static function _init(_x:Ref<T_decimal>, _m:T_nat, _shift:GoInt):Void {
        _x;
        if ((_m != null ? _m.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _x._mant = ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>));
            _x._exp = ((0 : GoInt));
            return;
        };
        if (_shift < ((0 : GoInt))) {
            var _ntz:GoUInt = _m._trailingZeroBits();
            var _s:GoUInt = ((-_shift : GoUInt));
            if (_s >= _ntz) {
                _s = _ntz;
            };
            _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _s) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _s).__copy__());
            _shift = _shift + (((_s : GoInt)));
        };
        if (_shift > ((0 : GoInt))) {
            _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), ((_shift : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), ((_shift : GoUInt))).__copy__());
            _shift = ((0 : GoInt));
        };
        var _s:Slice<GoUInt8> = _m._utoa(((10 : GoInt)));
        var _n:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        _x._exp = _n;
        while ((_n > ((0 : GoInt))) && ((_s != null ? _s[_n - ((1 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) {
            _n--;
        };
        _x._mant = (((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>)) != null ? ((_x._mant.__slice__(0, ((0 : GoInt))) : Slice<GoUInt8>)).__append__(...((_s.__slice__(0, _n) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_s.__slice__(0, _n) : Slice<GoUInt8>)).__toArray__()));
        if (_shift < ((0 : GoInt))) {
            while (_shift < ((-28 : GoInt))) {
                _shr(_x, ((28 : GoUInt)));
                _shift = _shift + (((28 : GoInt)));
            };
            _shr(_x, ((-_shift : GoUInt)));
        };
    }
    @:keep
    public static function _at(_d:Ref<T_decimal>, _i:GoInt):GoByte {
        _d;
        if ((((0 : GoInt)) <= _i) && (_i < (_d._mant != null ? _d._mant.length : ((0 : GoInt))))) {
            return (_d._mant != null ? _d._mant[_i] : ((0 : GoUInt8)));
        };
        return ((((("0" : GoString))).code : GoRune));
    }
}
class Float__wrapper {
    @:keep
    public function _sqrtInverse(_x:Float_):Void {
        var _z = __t__;
        _z;
        var _u:Ref<Float_> = _newFloat(_z._prec);
        var _v:Ref<Float_> = _newFloat(_z._prec);
        var _three:Ref<Float_> = _three();
        var _ng:Ref<Float_> -> Ref<Float_> = function(_t:Float_):Float_ {
            _u._prec = _t._prec;
            _v._prec = _t._prec;
            _u.mul(_t, _t);
            _u.mul(_x, _u);
            _v.sub(_three, _u);
            _u.mul(_t, _v);
            _u._exp--;
            return _t.set(_u);
        };
        var __tmp__ = _x.float64(), _xf:GoFloat64 = __tmp__._0, _0:Accuracy = __tmp__._1;
        var _sqi:Ref<Float_> = _newFloat(_z._prec);
        _sqi.setFloat64(((1 : GoFloat64)) / stdgo.math.Math.sqrt(_xf));
        {
            var _prec:GoUInt32 = _z._prec + ((32 : GoUInt32));
            while (_sqi._prec < _prec) {
                _sqi._prec = _sqi._prec * (((2 : GoUInt32)));
                _sqi = _ng(_sqi);
            };
        };
        _z.mul(_x, _sqi);
    }
    @:keep
    public function sqrt(_x:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _x._prec;
        };
        if (_x.sign() == ((-1 : GoInt))) {
            throw Go.toInterface(((new ErrNaN(((("square root of negative operand" : GoString)))) : ErrNaN)));
        };
        if (_x._form != ((1 : GoUInt8))) {
            _z._acc = ((0 : GoInt8));
            _z._form = _x._form;
            _z._neg = _x._neg;
            return _z;
        };
        var _prec:GoUInt32 = _z._prec;
        var _b:GoInt = _x.mantExp(_z);
        _z._prec = _prec;
        if (_b % ((2 : GoInt)) == ((0 : GoInt))) {} else if (_b % ((2 : GoInt)) == ((1 : GoInt))) {
            _z._exp++;
        } else if (_b % ((2 : GoInt)) == ((-1 : GoInt))) {
            _z._exp--;
        };
        _z._sqrtInverse(_z);
        return _z.setMantExp(_z, _b / ((2 : GoInt)));
    }
    @:keep
    public function format(_s:stdgo.fmt.Fmt.State, _format:GoRune):Void {
        var _x = __t__;
        _x;
        var __tmp__ = _s.precision(), _prec:GoInt = __tmp__._0, _hasPrec:Bool = __tmp__._1;
        if (!_hasPrec) {
            _prec = ((6 : GoInt));
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _format == ((((("e" : GoString))).code : GoRune)) || _format == ((((("E" : GoString))).code : GoRune)) || _format == ((((("f" : GoString))).code : GoRune)) || _format == ((((("b" : GoString))).code : GoRune)) || _format == ((((("p" : GoString))).code : GoRune)) || _format == ((((("x" : GoString))).code : GoRune)))) {
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _format == ((((("F" : GoString))).code : GoRune)))) {
                    _format = ((((("f" : GoString))).code : GoRune));
                    break;
                    break;
                } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _format == ((((("v" : GoString))).code : GoRune)))) {
                    _format = ((((("g" : GoString))).code : GoRune));
                    @:fallthrough {
                        __switchIndex__ = 3;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _format == ((((("g" : GoString))).code : GoRune)) || _format == ((((("G" : GoString))).code : GoRune)))) {
                    if (!_hasPrec) {
                        _prec = ((-1 : GoInt));
                    };
                    break;
                    break;
                } else {
                    stdgo.fmt.Fmt.fprintf(_s, ((("%%!%c(*big.Float=%s)" : GoString))), Go.toInterface(_format), Go.toInterface(((_x.toString() : GoString))));
                    return;
                    break;
                };
                break;
            };
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        _buf = _x.append(_buf, ((_format : GoByte)), _prec);
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _buf = ((((("?" : GoString))) : Slice<GoByte>));
        };
        var _sign:GoString = (("" : GoString));
        if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))) {
            _sign = ((("-" : GoString)));
            _buf = ((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        } else if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("+" : GoString))).code : GoRune))) {
            _sign = ((("+" : GoString)));
            if (_s.flag((((((" " : GoString))).code : GoRune)))) {
                _sign = (((" " : GoString)));
            };
            _buf = ((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        } else if (_s.flag(((((("+" : GoString))).code : GoRune)))) {
            _sign = ((("+" : GoString)));
        } else if (_s.flag((((((" " : GoString))).code : GoRune)))) {
            _sign = (((" " : GoString)));
        };
        var _padding:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _hasWidth:Bool = __tmp__._1;
            if (_hasWidth && (_width > ((_sign != null ? _sign.length : ((0 : GoInt))) + (_buf != null ? _buf.length : ((0 : GoInt)))))) {
                _padding = (_width - (_sign != null ? _sign.length : ((0 : GoInt)))) - (_buf != null ? _buf.length : ((0 : GoInt)));
            };
        };
        if (_s.flag(((((("0" : GoString))).code : GoRune))) && !_x.isInf()) {
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _writeMultiple(_s, ((("0" : GoString))), _padding);
            _s.write(_buf);
        } else if (_s.flag(((((("-" : GoString))).code : GoRune)))) {
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _s.write(_buf);
            _writeMultiple(_s, (((" " : GoString))), _padding);
        } else {
            _writeMultiple(_s, (((" " : GoString))), _padding);
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _s.write(_buf);
        };
    }
    @:keep
    public function _fmtP(_buf:Slice<GoByte>):Slice<GoByte> {
        var _x = __t__;
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            return (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        var _i:GoInt = ((0 : GoInt));
        while ((_i < (_m != null ? _m.length : ((0 : GoInt)))) && ((_m != null ? _m[_i] : new Word()) == ((0 : GoUInt)))) {
            _i++;
        };
        _m = (((_m.__slice__(_i) : T_nat)) == null ? null : ((_m.__slice__(_i) : T_nat)).__copy__());
        _buf = (_buf != null ? _buf.__append__(...((("0x." : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x." : GoString))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(...stdgo.bytes.Bytes.trimRight(_m._utoa(((16 : GoInt))), ((("0" : GoString)))).__toArray__()) : new Slice<GoUInt8>(...stdgo.bytes.Bytes.trimRight(_m._utoa(((16 : GoInt))), ((("0" : GoString)))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        if (_x._exp >= ((0 : GoInt32))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, ((_x._exp : GoInt64)), ((10 : GoInt)));
    }
    @:keep
    public function _fmtX(_buf:Slice<GoByte>, _prec:GoInt):Slice<GoByte> {
        var _x = __t__;
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            _buf = (_buf != null ? _buf.__append__(...((("0x0" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x0" : GoString))).__toArray__()));
            if (_prec > ((0 : GoInt))) {
                _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _prec, _i++, {
                        _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                    });
                };
            };
            _buf = (_buf != null ? _buf.__append__(...((("p+00" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("p+00" : GoString))).__toArray__()));
            return _buf;
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _n:GoUInt = ((0 : GoUInt));
        if (_prec < ((0 : GoInt))) {
            _n = ((1 : GoUInt)) + ((((_x.minPrec() - ((1 : GoUInt))) + ((3 : GoUInt))) / ((4 : GoUInt))) * ((4 : GoUInt)));
        } else {
            _n = ((1 : GoUInt)) + (((4 : GoUInt)) * ((_prec : GoUInt)));
        };
        _x = new Float_().setPrec(_n).setMode(_x._mode).set(_x);
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _w:GoUInt = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt));
            if (_w < _n) {
                _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), _n - _w) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), _n - _w).__copy__());
            } else if (_w > _n) {
                _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _w - _n) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _w - _n).__copy__());
            };
        };
        var _exp64:GoInt64 = ((_x._exp : GoInt64)) - ((1 : GoInt64));
        var _hm:Slice<GoUInt8> = _m._utoa(((16 : GoInt)));
        if (false && ((_hm != null ? _hm[((0 : GoInt))] : ((0 : GoUInt8))) != ((((("1" : GoString))).code : GoRune)))) {
            throw Go.toInterface(((("incorrect mantissa: " : GoString))) + ((_hm : GoString)));
        };
        _buf = (_buf != null ? _buf.__append__(...((("0x1" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x1" : GoString))).__toArray__()));
        if ((_hm != null ? _hm.length : ((0 : GoInt))) > ((1 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            _buf = (_buf != null ? _buf.__append__(...((_hm.__slice__(((1 : GoInt))) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_hm.__slice__(((1 : GoInt))) : Slice<GoUInt8>)).__toArray__()));
        };
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        if (_exp64 >= ((0 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        } else {
            _exp64 = -_exp64;
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        if (_exp64 < ((10 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _exp64, ((10 : GoInt)));
    }
    @:keep
    public function _fmtB(_buf:Slice<GoByte>):Slice<GoByte> {
        var _x = __t__;
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            return (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _w:GoUInt32 = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt32)) * ((32 : GoUInt32));
            if (_w < _x._prec) {
                _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), (((_x._prec - _w) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), (((_x._prec - _w) : GoUInt))).__copy__());
            } else if (_w > _x._prec) {
                _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), (((_w - _x._prec) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), (((_w - _x._prec) : GoUInt))).__copy__());
            };
        };
        _buf = (_buf != null ? _buf.__append__(..._m._utoa(((10 : GoInt))).__toArray__()) : new Slice<GoUInt8>(..._m._utoa(((10 : GoInt))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        var _e:GoInt64 = ((_x._exp : GoInt64)) - ((_x._prec : GoInt64));
        if (_e >= ((0 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _e, ((10 : GoInt)));
    }
    @:keep
    public function append(_buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt):Slice<GoByte> {
        var _x = __t__;
        _x;
        if (_x._neg) {
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        if (_x._form == ((2 : GoUInt8))) {
            if (!_x._neg) {
                _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
            };
            return (_buf != null ? _buf.__append__(...((("Inf" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("Inf" : GoString))).__toArray__()));
        };
        if (_fmt == ((((("b" : GoString))).code : GoRune))) {
            return _x._fmtB(_buf);
        } else if (_fmt == ((((("p" : GoString))).code : GoRune))) {
            return _x._fmtP(_buf);
        } else if (_fmt == ((((("x" : GoString))).code : GoRune))) {
            return _x._fmtX(_buf, _prec);
        };
        var _d:T_decimal = new T_decimal();
        if (_x._form == ((1 : GoUInt8))) {
            _d._init((_x._mant == null ? null : _x._mant.__copy__()), ((_x._exp : GoInt)) - _x._mant._bitLen());
        };
        var _shortest:Bool = false;
        if (_prec < ((0 : GoInt))) {
            _shortest = true;
            _roundShortest(_d, _x);
            if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt))) - ((1 : GoInt));
            } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
                _prec = _max((_d._mant != null ? _d._mant.length : ((0 : GoInt))) - _d._exp, ((0 : GoInt)));
            } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
        } else {
            if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
                _d._round(((1 : GoInt)) + _prec);
            } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
                _d._round(_d._exp + _prec);
            } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
                if (_prec == ((0 : GoInt))) {
                    _prec = ((1 : GoInt));
                };
                _d._round(_prec);
            };
        };
        if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
            return _fmtE(_buf, _fmt, _prec, (_d == null ? null : _d.__copy__()));
        } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
            return _fmtF(_buf, _prec, (_d == null ? null : _d.__copy__()));
        } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
            var _eprec:GoInt = _prec;
            if ((_eprec > (_d._mant != null ? _d._mant.length : ((0 : GoInt)))) && ((_d._mant != null ? _d._mant.length : ((0 : GoInt))) >= _d._exp)) {
                _eprec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
            if (_shortest) {
                _eprec = ((6 : GoInt));
            };
            var _exp:GoInt = _d._exp - ((1 : GoInt));
            if ((_exp < ((-4 : GoInt))) || (_exp >= _eprec)) {
                if (_prec > (_d._mant != null ? _d._mant.length : ((0 : GoInt)))) {
                    _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
                };
                return _fmtE(_buf, (_fmt + ((((("e" : GoString))).code : GoRune))) - ((((("g" : GoString))).code : GoRune)), _prec - ((1 : GoInt)), (_d == null ? null : _d.__copy__()));
            };
            if (_prec > _d._exp) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
            return _fmtF(_buf, _max(_prec - _d._exp, ((0 : GoInt))), (_d == null ? null : _d.__copy__()));
        };
        if (_x._neg) {
            _buf = ((_buf.__slice__(0, (_buf != null ? _buf.length : ((0 : GoInt))) - ((1 : GoInt))) : Slice<GoUInt8>));
        };
        return (_buf != null ? _buf.__append__(((((("%" : GoString))).code : GoRune)), _fmt) : new Slice<GoUInt8>(((((("%" : GoString))).code : GoRune)), _fmt));
    }
    @:keep
    public function toString():GoString {
        var _x = __t__;
        _x;
        return _x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)));
    }
    @:keep
    public function text(_format:GoByte, _prec:GoInt):GoString {
        var _x = __t__;
        _x;
        var _cap:GoInt = ((10 : GoInt));
        if (_prec > ((0 : GoInt))) {
            _cap = _cap + (_prec);
        };
        return ((_x.append(new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((_cap : GoInt)).toBasic()), _format, _prec) : GoString));
    }
    @:keep
    public function unmarshalText(_text:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        var __tmp__ = _z.parse(((_text : GoString)), ((0 : GoInt))), _0:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if (_err != null) {
            _err = stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Float (%v)" : GoString))), Go.toInterface(_text), Go.toInterface(_err));
        };
        return _err;
    }
    @:keep
    public function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x == null) {
            return { _0 : ((((("<nil>" : GoString))) : Slice<GoByte>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        return { _0 : _x.append(_buf, ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt))), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function gobDecode(_buf:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Float_() : Float_));
                _z._prec = __tmp__._prec;
                _z._mode = __tmp__._mode;
                _z._acc = __tmp__._acc;
                _z._form = __tmp__._form;
                _z._neg = __tmp__._neg;
                _z._mant = __tmp__._mant;
                _z._exp = __tmp__._exp;
            };
            return ((null : stdgo.Error));
        };
        if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Float.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)))));
        };
        var _oldPrec:GoUInt32 = _z._prec;
        var _oldMode:RoundingMode = _z._mode;
        var _b:GoUInt8 = (_buf != null ? _buf[((1 : GoInt))] : ((0 : GoUInt8)));
        _z._mode = ((((_b >> ((5 : GoUnTypedInt))) & ((7 : GoUInt8))) : RoundingMode));
        _z._acc = ((((_b >> ((3 : GoUnTypedInt))) & ((3 : GoUInt8))) : Accuracy)) - ((1 : GoInt8));
        _z._form = ((((_b >> ((1 : GoUnTypedInt))) & ((3 : GoUInt8))) : T_form));
        _z._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._prec = stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((2 : GoInt))) : Slice<GoUInt8>)));
        if (_z._form == ((1 : GoUInt8))) {
            _z._exp = ((stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((6 : GoInt))) : Slice<GoUInt8>))) : GoInt32));
            _z._mant = (_z._mant._setBytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>))) == null ? null : _z._mant._setBytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>))).__copy__());
        };
        if (_oldPrec != ((0 : GoUInt32))) {
            _z._mode = _oldMode;
            _z.setPrec(((_oldPrec : GoUInt)));
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _sz:GoInt = ((6 : GoInt));
        var _n:GoInt = ((0 : GoInt));
        if (_x._form == ((1 : GoUInt8))) {
            _n = ((((_x._prec + ((31 : GoUInt32))) / ((32 : GoUInt32))) : GoInt));
            if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) < _n) {
                _n = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
            };
            _sz = _sz + (((4 : GoInt)) + (_n * ((4 : GoInt))));
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_sz : GoInt)).toBasic()) ((0 : GoUInt8))]);
        if (_buf != null) _buf[((0 : GoInt))] = ((1 : GoUInt8));
        var _b:GoUInt8 = (((((_x._mode & ((7 : GoUInt8))) : GoByte)) << ((5 : GoUnTypedInt))) | (((((_x._acc + ((1 : GoInt8))) & ((3 : GoInt8))) : GoByte)) << ((3 : GoUnTypedInt)))) | ((((_x._form & ((3 : GoUInt8))) : GoByte)) << ((1 : GoUnTypedInt)));
        if (_x._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[((1 : GoInt))] = _b;
        stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(((2 : GoInt))) : Slice<GoUInt8>)), _x._prec);
        if (_x._form == ((1 : GoUInt8))) {
            stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(((6 : GoInt))) : Slice<GoUInt8>)), ((_x._exp : GoUInt32)));
            ((_x._mant.__slice__((_x._mant != null ? _x._mant.length : ((0 : GoInt))) - _n) : T_nat))._bytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>)));
        };
        return { _0 : _buf, _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var _z = __t__;
        _z;
        _s.skipSpace();
        var __tmp__ = _z._scan(((new T_byteReader(_s) : T_byteReader)), ((0 : GoInt))), _0:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        return _err;
    }
    @:keep
    public function parse(_s:GoString, _base:GoInt):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        var _z = __t__;
        _z;
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        if (((_s != null ? _s.length : ((0 : GoInt))) == ((3 : GoInt))) && ((_s == ((("Inf" : GoString)))) || (_s == ((("inf" : GoString)))))) {
            _f = _z.setInf(false);
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((((_s != null ? _s.length : ((0 : GoInt))) == ((4 : GoInt))) && (((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("+" : GoString))).code : GoRune))) || ((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))))) && ((((_s.__slice__(((1 : GoInt))) : GoString)) == ((("Inf" : GoString)))) || (((_s.__slice__(((1 : GoInt))) : GoString)) == ((("inf" : GoString)))))) {
            _f = _z.setInf((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_s);
        {
            {
                var __tmp__ = _z._scan(_r, _base);
                _f = __tmp__._0;
                _b = __tmp__._1;
                _err = __tmp__._2;
            };
            if (_err != null) {
                return { _0 : _f, _1 : _b, _2 : _err };
            };
        };
        {
            var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err2:stdgo.Error = __tmp__._1;
            if (_err2 == null) {
                _err = stdgo.fmt.Fmt.errorf(((("expected end of string, found %q" : GoString))), Go.toInterface(_ch));
            } else if (_err2 != stdgo.io.Io.eof) {
                _err = _err2;
            };
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    @:keep
    public function _pow5(_n:GoUInt64):Float_ {
        var _z = __t__;
        _z;
        {};
        if (_n <= ((27 : GoUInt64))) {
            return _z.setUint64((_pow5tab != null ? _pow5tab[_n] : ((0 : GoUInt64))));
        };
        _z.setUint64((_pow5tab != null ? _pow5tab[((27 : GoUInt64))] : ((0 : GoUInt64))));
        _n = _n - (((27 : GoUInt64)));
        var _f:Ref<Float_> = new Float_().setPrec(_z.prec() + ((64 : GoUInt))).setUint64(((5 : GoUInt64)));
        while (_n > ((0 : GoUInt64))) {
            if ((_n & ((1 : GoUInt64))) != ((0 : GoUInt64))) {
                _z.mul(_z, _f);
            };
            _f.mul(_f, _f);
            _n = _n >> (((1 : GoUnTypedInt)));
        };
        return _z;
    }
    @:keep
    public function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        var _z = __t__;
        _z;
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        var _prec:GoUInt32 = _z._prec;
        if (_prec == ((0 : GoUInt32))) {
            _prec = ((64 : GoUInt32));
        };
        _z._form = ((0 : GoUInt8));
        {
            var __tmp__ = _scanSign(_r);
            _z._neg = __tmp__._0;
            _err = __tmp__._1;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _fcount:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _z._mant._scan(_r, _base, true);
            _z._mant = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _b = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp:GoInt64 = ((0 : GoInt64));
        var _ebase:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _scanExponent(_r, true, _base == ((0 : GoInt)));
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((_z._mant != null ? _z._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._prec = _prec;
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _f = _z;
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp2:GoInt64 = ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__()));
        var _exp5:GoInt64 = ((((0 : GoInt64)) : GoInt64));
        if (_fcount < ((0 : GoInt))) {
            var _d:GoInt64 = ((_fcount : GoInt64));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _b == ((10 : GoInt)))) {
                        _exp5 = _d;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _b == ((2 : GoInt)))) {
                        _exp2 = _exp2 + (_d);
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _b == ((8 : GoInt)))) {
                        _exp2 = _exp2 + (_d * ((3 : GoInt64)));
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _b == ((16 : GoInt)))) {
                        _exp2 = _exp2 + (_d * ((4 : GoInt64)));
                        break;
                        break;
                    } else {
                        throw Go.toInterface(((("unexpected mantissa base" : GoString))));
                        break;
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ebase == ((10 : GoInt)))) {
                    _exp5 = _exp5 + (_exp);
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ebase == ((2 : GoInt)))) {
                    _exp2 = _exp2 + (_exp);
                    break;
                    break;
                } else {
                    throw Go.toInterface(((("unexpected exponent base" : GoString))));
                    break;
                };
                break;
            };
        };
        if ((((-2147483648 : GoInt64)) <= _exp2) && (_exp2 <= ((2147483647 : GoInt64)))) {
            _z._prec = _prec;
            _z._form = ((1 : GoUInt8));
            _z._exp = ((_exp2 : GoInt32));
            _f = _z;
        } else {
            _err = stdgo.fmt.Fmt.errorf(((("exponent overflow" : GoString))));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if (_exp5 == ((0 : GoInt64))) {
            _z._round(((0 : GoUInt)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _p:Ref<Float_> = new Float_().setPrec(_z.prec() + ((64 : GoUInt)));
        if (_exp5 < ((0 : GoInt64))) {
            _z.quo(_z, _p._pow5(((-_exp5 : GoUInt64))));
        } else {
            _z.mul(_z, _p._pow5(((_exp5 : GoUInt64))));
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    @:keep
    public function setString(_s:GoString):{ var _0 : Float_; var _1 : Bool; } {
        var _z = __t__;
        _z;
        {
            var __tmp__ = _z.parse(_s, ((0 : GoInt))), _f:Ref<Float_> = __tmp__._0, _0:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err == null) {
                return { _0 : _f, _1 : true };
            };
        };
        return { _0 : null, _1 : false };
    }
    @:keep
    public function _int64():GoInt64 {
        var _x = __t__;
        _x;
        var __tmp__ = _x.int64(), _i:GoInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
        if (_acc != ((0 : GoInt8))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("%s is not an int64" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt))))));
        };
        return _i;
    }
    @:keep
    public function _uint64():GoUInt64 {
        var _x = __t__;
        _x;
        var __tmp__ = _x.uint64(), _u:GoUInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
        if (_acc != ((0 : GoInt8))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("%s is not a uint64" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt))))));
        };
        return _u;
    }
    @:keep
    public function _ord():GoInt {
        var _x = __t__;
        _x;
        var _m:GoInt = ((0 : GoInt));
        if (_x._form == ((1 : GoUInt8))) {
            _m = ((1 : GoInt));
        } else if (_x._form == ((0 : GoUInt8))) {
            return ((0 : GoInt));
        } else if (_x._form == ((2 : GoUInt8))) {
            _m = ((2 : GoInt));
        };
        if (_x._neg) {
            _m = -_m;
        };
        return _m;
    }
    @:keep
    public function cmp(_y:Float_):GoInt {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
            _y._validate();
        };
        var _mx:GoInt = _x._ord();
        var _my:GoInt = _y._ord();
        if (_mx < _my) {
            return ((-1 : GoInt));
        } else if (_mx > _my) {
            return ((1 : GoInt));
        };
        if (_mx == ((-1 : GoInt))) {
            return _y._ucmp(_x);
        } else if (_mx == ((1 : GoInt))) {
            return _x._ucmp(_y);
        };
        return ((0 : GoInt));
    }
    @:keep
    public function quo(_x:Float_, _y:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != _y._neg;
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            _z._uquo(_x, _y);
            return _z;
        };
        _z._acc = ((0 : GoInt8));
        if (((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) || ((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8))))) {
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("division of zero by zero or infinity by infinity" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) || (_y._form == ((2 : GoUInt8)))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._form = ((2 : GoUInt8));
        return _z;
    }
    @:keep
    public function mul(_x:Float_, _y:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != _y._neg;
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            _z._umul(_x, _y);
            return _z;
        };
        _z._acc = ((0 : GoInt8));
        if (((_x._form == ((0 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) || ((_x._form == ((2 : GoUInt8))) && (_y._form == ((0 : GoUInt8))))) {
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("multiplication of zero with infinity" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((2 : GoUInt8)))) {
            _z._form = ((2 : GoUInt8));
            return _z;
        };
        _z._form = ((0 : GoUInt8));
        return _z;
    }
    @:keep
    public function sub(_x:Float_, _y:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg != _yneg) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > ((0 : GoInt))) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == ((0 : GoUInt8))) && (_z._mode == ((4 : GoUInt8)))) && (_z._acc == ((0 : GoInt8)))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) && (_x._neg == _y._neg)) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("subtraction of infinities with equal signs" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = _x._neg && !_y._neg;
            return _z;
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((0 : GoUInt8)))) {
            return _z.set(_x);
        };
        return _z.neg(_y);
    }
    @:keep
    public function add(_x:Float_, _y:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg == _yneg) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > ((0 : GoInt))) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == ((0 : GoUInt8))) && (_z._mode == ((4 : GoUInt8)))) && (_z._acc == ((0 : GoInt8)))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) && (_x._neg != _y._neg)) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("addition of infinities with opposite signs" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = _x._neg && _y._neg;
            return _z;
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((0 : GoUInt8)))) {
            return _z.set(_x);
        };
        return _z.set(_y);
    }
    @:keep
    public function _ucmp(_y:Float_):GoInt {
        var _x = __t__;
        _x;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        if (_x._exp < _y._exp) {
            return ((-1 : GoInt));
        } else if (_x._exp > _y._exp) {
            return ((1 : GoInt));
        };
        var _i:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        var _j:GoInt = (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) || (_j > ((0 : GoInt)))) {
            var _xm:Word = new Word(), _ym:Word = new Word();
            if (_i > ((0 : GoInt))) {
                _i--;
                _xm = (_x._mant != null ? _x._mant[_i] : new Word());
            };
            if (_j > ((0 : GoInt))) {
                _j--;
                _ym = (_y._mant != null ? _y._mant[_j] : new Word());
            };
            if (_xm < _ym) {
                return ((-1 : GoInt));
            } else if (_xm > _ym) {
                return ((1 : GoInt));
            };
        };
        return ((0 : GoInt));
    }
    @:keep
    public function _uquo(_x:Float_, _y:Float_):Void {
        var _z = __t__;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _n:GoInt = (((_z._prec / ((32 : GoUInt32))) : GoInt)) + ((1 : GoInt));
        var _xadj:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _d:GoInt = (_n - (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) + (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
            if (_d > ((0 : GoInt))) {
                _xadj = new Slice<Word>(...[for (i in 0 ... (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) + _d : GoInt)).toBasic()) new Word()]);
                Go.copySlice(((_xadj.__slice__(_d) : T_nat)), _x._mant);
            };
        };
        var _d:GoInt = (_xadj != null ? _xadj.length : ((0 : GoInt))) - (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
        var _r:T_nat = new T_nat();
        {
            var __tmp__ = _z._mant._div(null, (_xadj == null ? null : _xadj.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
            _z._mant = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        var _e:GoInt64 = (((_x._exp : GoInt64)) - ((_y._exp : GoInt64))) - ((((_d - (_z._mant != null ? _z._mant.length : ((0 : GoInt)))) : GoInt64)) * ((32 : GoInt64)));
        var _sbit:GoUInt = ((0 : GoUInt));
        if ((_r != null ? _r.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _sbit = ((1 : GoUInt));
        };
        _z._setExpAndRound(_e - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), _sbit);
    }
    @:keep
    public function _umul(_x:Float_, _y:Float_):Void {
        var _z = __t__;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _e:GoInt64 = ((_x._exp : GoInt64)) + ((_y._exp : GoInt64));
        if (_x == _y) {
            _z._mant = (_z._mant._sqr((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._sqr((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
        } else {
            _z._mant = (_z._mant._mul((_x._mant == null ? null : _x._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._mul((_x._mant == null ? null : _x._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
        };
        _z._setExpAndRound(_e - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public function _usub(_x:Float_, _y:Float_):Void {
        var _z = __t__;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = ((_x._exp : GoInt64)) - ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _ey:GoInt64 = ((_y._exp : GoInt64)) - ((((_y._mant != null ? _y._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _al:Bool = _alias((_z._mant == null ? null : _z._mant.__copy__()), (_x._mant == null ? null : _x._mant.__copy__())) || _alias((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
        if (_ex < _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_t._sub((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())) == null ? null : _t._sub((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : _z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._sub((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())) == null ? null : _z._mant._sub((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())).__copy__());
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_t._sub((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _t._sub((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : _z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._sub((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._sub((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            };
            _ex = _ey;
        };
        if ((_z._mant != null ? _z._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            return;
        };
        _z._setExpAndRound((_ex + ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public function _uadd(_x:Float_, _y:Float_):Void {
        var _z = __t__;
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = ((_x._exp : GoInt64)) - ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _ey:GoInt64 = ((_y._exp : GoInt64)) - ((((_y._mant != null ? _y._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _al:Bool = _alias((_z._mant == null ? null : _z._mant.__copy__()), (_x._mant == null ? null : _x._mant.__copy__())) || _alias((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
        if (_ex < _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())) == null ? null : _z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : _z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())) == null ? null : _z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())).__copy__());
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._add((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : _z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._add((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            };
            _ex = _ey;
        };
        _z._setExpAndRound((_ex + ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public function neg(_x:Float_):Float_ {
        var _z = __t__;
        _z;
        _z.set(_x);
        _z._neg = !_z._neg;
        return _z;
    }
    @:keep
    public function abs(_x:Float_):Float_ {
        var _z = __t__;
        _z;
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    @:keep
    public function rat(_z:Rat):{ var _0 : Rat; var _1 : Accuracy; } {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if ((_z == null) && (_x._form <= ((1 : GoUInt8)))) {
            _z = new Rat();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _allBits:GoInt32 = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt32)) * ((32 : GoInt32));
            _z._a._neg = _x._neg;
            if (_x._exp > _allBits) {
                _z._a._abs = (_z._a._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_x._exp - _allBits) : GoUInt))) == null ? null : _z._a._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_x._exp - _allBits) : GoUInt))).__copy__());
                _z._b._abs = (((_z._b._abs.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z._b._abs.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            } else if (_x._exp < _allBits) {
                _z._a._abs = (_z._a._abs._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._a._abs._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
                var _t:T_nat = (_z._b._abs._setUint64(((1 : GoUInt64))) == null ? null : _z._b._abs._setUint64(((1 : GoUInt64))).__copy__());
                _z._b._abs = (_t._shl((_t == null ? null : _t.__copy__()), (((_allBits - _x._exp) : GoUInt))) == null ? null : _t._shl((_t == null ? null : _t.__copy__()), (((_allBits - _x._exp) : GoUInt))).__copy__());
                _z._norm();
            };
            return { _0 : _z, _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : _z.setInt64(((0 : GoInt64))), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            return { _0 : null, _1 : _makeAcc(_x._neg) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function int(_z:Int_):{ var _0 : Int_; var _1 : Accuracy; } {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if ((_z == null) && (_x._form <= ((1 : GoUInt8)))) {
            _z = new Int_();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _acc:Accuracy = _makeAcc(_x._neg);
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : _z.setInt64(((0 : GoInt64))), _1 : _acc };
            };
            var _allBits:GoUInt = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt));
            var _exp:GoUInt = ((_x._exp : GoUInt));
            if (_x.minPrec() <= _exp) {
                _acc = ((0 : GoInt8));
            };
            if (_z == null) {
                _z = new Int_();
            };
            _z._neg = _x._neg;
            if (_exp > _allBits) {
                _z._abs = (_z._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), _exp - _allBits) == null ? null : _z._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), _exp - _allBits).__copy__());
            } else if (_exp < _allBits) {
                _z._abs = (_z._abs._shr((_x._mant == null ? null : _x._mant.__copy__()), _allBits - _exp) == null ? null : _z._abs._shr((_x._mant == null ? null : _x._mant.__copy__()), _allBits - _exp).__copy__());
            };
            return { _0 : _z, _1 : _acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : _z.setInt64(((0 : GoInt64))), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            return { _0 : null, _1 : _makeAcc(_x._neg) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function float64():{ var _0 : GoFloat64; var _1 : Accuracy; } {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            {};
            var _e:GoInt32 = _x._exp - ((1 : GoInt32));
            var _p:GoInt = ((53 : GoInt));
            if (_e < ((-1022 : GoInt32))) {
                _p = ((1075 : GoInt)) + ((_e : GoInt));
                if ((_p < ((0 : GoInt))) || ((_p == ((0 : GoInt))) && (_x._mant._sticky(((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - ((1 : GoUInt))) == ((0 : GoUInt))))) {
                    if (_x._neg) {
                        var _z:GoFloat64 = ((0 : GoFloat64));
                        return { _0 : -_z, _1 : ((1 : GoInt8)) };
                    };
                    return { _0 : ((0 : GoFloat64)), _1 : ((-1 : GoInt8)) };
                };
                if (_p == ((0 : GoInt))) {
                    if (_x._neg) {
                        return { _0 : ((-5e-324 : GoFloat64)), _1 : ((-1 : GoInt8)) };
                    };
                    return { _0 : ((5e-324 : GoFloat64)), _1 : ((1 : GoInt8)) };
                };
            };
            var _r:Float_ = new Float_();
            _r._prec = ((_p : GoUInt32));
            _r.set(_x);
            _e = _r._exp - ((1 : GoInt32));
            if ((_r._form == ((2 : GoUInt8))) || (_e > ((1023 : GoInt32)))) {
                if (_x._neg) {
                    return { _0 : stdgo.math.Math.inf(((-1 : GoInt))), _1 : ((-1 : GoInt8)) };
                };
                return { _0 : stdgo.math.Math.inf(((1 : GoInt))), _1 : ((1 : GoInt8)) };
            };
            var _sign:GoUInt64 = ((0 : GoUInt64)), _bexp:GoUInt64 = ((0 : GoUInt64)), _mant:GoUInt64 = ((0 : GoUInt64));
            if (_x._neg) {
                _sign = (("9223372036854775808" : GoUInt64));
            };
            if (_e < ((-1022 : GoInt32))) {
                _p = ((1075 : GoInt)) + ((_e : GoInt));
                _mant = _msb64((_r._mant == null ? null : _r._mant.__copy__())) >> (((((64 : GoInt)) - _p) : GoUInt));
            } else {
                _bexp = (((_e + ((1023 : GoInt32))) : GoUInt64)) << ((52 : GoUnTypedInt));
                _mant = (_msb64((_r._mant == null ? null : _r._mant.__copy__())) >> ((11 : GoUnTypedInt))) & (("4503599627370495" : GoUInt64));
            };
            return { _0 : stdgo.math.Math.float64frombits((_sign | _bexp) | _mant), _1 : _r._acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            if (_x._neg) {
                var _z:GoFloat64 = ((0 : GoFloat64));
                return { _0 : -_z, _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((0 : GoFloat64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : stdgo.math.Math.inf(((-1 : GoInt))), _1 : ((0 : GoInt8)) };
            };
            return { _0 : stdgo.math.Math.inf(((1 : GoInt))), _1 : ((0 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function float32():{ var _0 : GoFloat32; var _1 : Accuracy; } {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            {};
            var _e:GoInt32 = _x._exp - ((1 : GoInt32));
            var _p:GoInt = ((24 : GoInt));
            if (_e < ((-126 : GoInt32))) {
                _p = ((150 : GoInt)) + ((_e : GoInt));
                if ((_p < ((0 : GoInt))) || ((_p == ((0 : GoInt))) && (_x._mant._sticky(((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - ((1 : GoUInt))) == ((0 : GoUInt))))) {
                    if (_x._neg) {
                        var _z:GoFloat32 = ((0 : GoFloat32));
                        return { _0 : -_z, _1 : ((1 : GoInt8)) };
                    };
                    return { _0 : ((0 : GoFloat32)), _1 : ((-1 : GoInt8)) };
                };
                if (_p == ((0 : GoInt))) {
                    if (_x._neg) {
                        return { _0 : ((-1.401298464324817e-45 : GoFloat32)), _1 : ((-1 : GoInt8)) };
                    };
                    return { _0 : ((1.401298464324817e-45 : GoFloat32)), _1 : ((1 : GoInt8)) };
                };
            };
            var _r:Float_ = new Float_();
            _r._prec = ((_p : GoUInt32));
            _r.set(_x);
            _e = _r._exp - ((1 : GoInt32));
            if ((_r._form == ((2 : GoUInt8))) || (_e > ((127 : GoInt32)))) {
                if (_x._neg) {
                    return { _0 : ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)), _1 : ((-1 : GoInt8)) };
                };
                return { _0 : ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), _1 : ((1 : GoInt8)) };
            };
            var _sign:GoUInt32 = ((0 : GoUInt32)), _bexp:GoUInt32 = ((0 : GoUInt32)), _mant:GoUInt32 = ((0 : GoUInt32));
            if (_x._neg) {
                _sign = (("2147483648" : GoUInt32));
            };
            if (_e < ((-126 : GoInt32))) {
                _p = ((150 : GoInt)) + ((_e : GoInt));
                _mant = _msb32((_r._mant == null ? null : _r._mant.__copy__())) >> (((((32 : GoInt)) - _p) : GoUInt));
            } else {
                _bexp = (((_e + ((127 : GoInt32))) : GoUInt32)) << ((23 : GoUnTypedInt));
                _mant = (_msb32((_r._mant == null ? null : _r._mant.__copy__())) >> ((8 : GoUnTypedInt))) & ((8388607 : GoUInt32));
            };
            return { _0 : stdgo.math.Math.float32frombits((_sign | _bexp) | _mant), _1 : _r._acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            if (_x._neg) {
                var _z:GoFloat32 = ((0 : GoFloat32));
                return { _0 : -_z, _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((0 : GoFloat32)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)), _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), _1 : ((0 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function int64():{ var _0 : GoInt64; var _1 : Accuracy; } {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _acc:Accuracy = _makeAcc(_x._neg);
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : ((0 : GoInt64)), _1 : _acc };
            };
            if (_x._exp <= ((63 : GoInt32))) {
                var _i:GoInt64 = (((_msb64((_x._mant == null ? null : _x._mant.__copy__())) >> (((64 : GoUInt32)) - ((_x._exp : GoUInt32)))) : GoInt64));
                if (_x._neg) {
                    _i = -_i;
                };
                if (_x.minPrec() <= ((_x._exp : GoUInt))) {
                    return { _0 : _i, _1 : ((0 : GoInt8)) };
                };
                return { _0 : _i, _1 : _acc };
            };
            if (_x._neg) {
                if ((_x._exp == ((64 : GoInt32))) && (_x.minPrec() == ((1 : GoUInt)))) {
                    _acc = ((0 : GoInt8));
                };
                return { _0 : (("-9223372036854775808" : GoInt64)), _1 : _acc };
            };
            return { _0 : (("9223372036854775807" : GoInt64)), _1 : ((-1 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : ((0 : GoInt64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : (("-9223372036854775808" : GoInt64)), _1 : ((1 : GoInt8)) };
            };
            return { _0 : (("9223372036854775807" : GoInt64)), _1 : ((-1 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function uint64():{ var _0 : GoUInt64; var _1 : Accuracy; } {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((0 : GoUInt64)), _1 : ((1 : GoInt8)) };
            };
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : ((0 : GoUInt64)), _1 : ((-1 : GoInt8)) };
            };
            if (_x._exp <= ((64 : GoInt32))) {
                var _u:GoUInt64 = _msb64((_x._mant == null ? null : _x._mant.__copy__())) >> (((64 : GoUInt32)) - ((_x._exp : GoUInt32)));
                if (_x.minPrec() <= ((64 : GoUInt))) {
                    return { _0 : _u, _1 : ((0 : GoInt8)) };
                };
                return { _0 : _u, _1 : ((-1 : GoInt8)) };
            };
            return { _0 : (("18446744073709551615" : GoUInt64)), _1 : ((-1 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : ((0 : GoUInt64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((0 : GoUInt64)), _1 : ((1 : GoInt8)) };
            };
            return { _0 : (("18446744073709551615" : GoUInt64)), _1 : ((-1 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public function copy(_x:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
        };
        if (_z != _x) {
            _z._prec = _x._prec;
            _z._mode = _x._mode;
            _z._acc = _x._acc;
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_z._form == ((1 : GoUInt8))) {
                _z._mant = (_z._mant._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
                _z._exp = _x._exp;
            };
        };
        return _z;
    }
    @:keep
    public function set(_x:Float_):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _x._validate();
        };
        _z._acc = ((0 : GoInt8));
        if (_z != _x) {
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_x._form == ((1 : GoUInt8))) {
                _z._exp = _x._exp;
                _z._mant = (_z._mant._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
            };
            if (_z._prec == ((0 : GoUInt32))) {
                _z._prec = _x._prec;
            } else if (_z._prec < _x._prec) {
                _z._round(((0 : GoUInt)));
            };
        };
        return _z;
    }
    @:keep
    public function setInf(_signbit:Bool):Float_ {
        var _z = __t__;
        _z;
        _z._acc = ((0 : GoInt8));
        _z._form = ((2 : GoUInt8));
        _z._neg = _signbit;
        return _z;
    }
    @:keep
    public function setRat(_x:Rat):Float_ {
        var _z = __t__;
        _z;
        if (_x.isInt()) {
            return _z.setInt(_x.num());
        };
        var _a:Float_ = new Float_(), _b:Float_ = new Float_();
        _a.setInt(_x.num());
        _b.setInt(_x.denom());
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_a._prec, _b._prec);
        };
        return _z.quo(_a, _b);
    }
    @:keep
    public function setInt(_x:Int_):Float_ {
        var _z = __t__;
        _z;
        var _bits:GoUInt32 = ((_x.bitLen() : GoUInt32));
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_bits, ((64 : GoUInt32)));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = _x._neg;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._mant = (_z._mant._set((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._mant._set((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
        _fnorm((_z._mant == null ? null : _z._mant.__copy__()));
        _z._setExpAndRound(((_bits : GoInt64)), ((0 : GoUInt)));
        return _z;
    }
    @:keep
    public function setFloat64(_x:GoFloat64):Float_ {
        var _z = __t__;
        _z;
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = ((53 : GoUInt32));
        };
        if (stdgo.math.Math.isNaN(_x)) {
            throw Go.toInterface(((new ErrNaN(((("Float.SetFloat64(NaN)" : GoString)))) : ErrNaN)));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = stdgo.math.Math.signbit(_x);
        if (_x == ((0 : GoFloat64))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        if (stdgo.math.Math.isInf(_x, ((0 : GoInt)))) {
            _z._form = ((2 : GoUInt8));
            return _z;
        };
        _z._form = ((1 : GoUInt8));
        var __tmp__ = stdgo.math.Math.frexp(_x), _fmant:GoFloat64 = __tmp__._0, _exp:GoInt = __tmp__._1;
        _z._mant = (_z._mant._setUint64((("9223372036854775808" : GoUInt64)) | (stdgo.math.Math.float64bits(_fmant) << ((11 : GoUnTypedInt)))) == null ? null : _z._mant._setUint64((("9223372036854775808" : GoUInt64)) | (stdgo.math.Math.float64bits(_fmant) << ((11 : GoUnTypedInt)))).__copy__());
        _z._exp = ((_exp : GoInt32));
        if (_z._prec < ((53 : GoUInt32))) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public function setInt64(_x:GoInt64):Float_ {
        var _z = __t__;
        _z;
        var _u:GoInt64 = _x;
        if (_u < ((0 : GoInt64))) {
            _u = -_u;
        };
        return _z._setBits64(_x < ((0 : GoInt64)), ((_u : GoUInt64)));
    }
    @:keep
    public function setUint64(_x:GoUInt64):Float_ {
        var _z = __t__;
        _z;
        return _z._setBits64(false, _x);
    }
    @:keep
    public function _setBits64(_neg:Bool, _x:GoUInt64):Float_ {
        var _z = __t__;
        _z;
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = ((64 : GoUInt32));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = _neg;
        if (_x == ((0 : GoUInt64))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._form = ((1 : GoUInt8));
        var _s:GoInt = stdgo.math.bits.Bits.leadingZeros64(_x);
        _z._mant = (_z._mant._setUint64(_x << ((_s : GoUInt))) == null ? null : _z._mant._setUint64(_x << ((_s : GoUInt))).__copy__());
        _z._exp = (((((64 : GoInt)) - _s) : GoInt32));
        if (_z._prec < ((64 : GoUInt32))) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public function _round(_sbit:GoUInt):Void {
        var _z = __t__;
        _z;
        if (false) {
            _z._validate();
        };
        _z._acc = ((0 : GoInt8));
        if (_z._form != ((1 : GoUInt8))) {
            return;
        };
        var _m:GoUInt32 = (((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoUInt32));
        var _bits:GoUInt32 = _m * ((32 : GoUInt32));
        if (_bits <= _z._prec) {
            return;
        };
        var _r:GoUInt = ((((_bits - _z._prec) - ((1 : GoUInt32))) : GoUInt));
        var _rbit:GoUInt = _z._mant._bit(_r) & ((1 : GoUInt));
        if ((_sbit == ((0 : GoUInt))) && ((_rbit == ((0 : GoUInt))) || (_z._mode == ((0 : GoUInt8))))) {
            _sbit = _z._mant._sticky(_r);
        };
        _sbit = _sbit & (((1 : GoUInt)));
        var _n:GoUInt32 = (_z._prec + ((31 : GoUInt32))) / ((32 : GoUInt32));
        if (_m > _n) {
            Go.copySlice(_z._mant, ((_z._mant.__slice__(_m - _n) : T_nat)));
            _z._mant = (((_z._mant.__slice__(0, _n) : T_nat)) == null ? null : ((_z._mant.__slice__(0, _n) : T_nat)).__copy__());
        };
        var _ntz:GoUInt32 = (_n * ((32 : GoUInt32))) - _z._prec;
        var _lsb:Word = ((((1 : GoUInt)) : Word)) << _ntz;
        if ((_rbit | _sbit) != ((0 : GoUInt))) {
            var _inc:Bool = false;
            if (_z._mode == ((4 : GoUInt8))) {
                _inc = _z._neg;
            } else if (_z._mode == ((2 : GoUInt8))) {} else if (_z._mode == ((0 : GoUInt8))) {
                _inc = (_rbit != ((0 : GoUInt))) && ((_sbit != ((0 : GoUInt))) || (((_z._mant != null ? _z._mant[((0 : GoInt))] : new Word()) & _lsb) != ((0 : GoUInt))));
            } else if (_z._mode == ((1 : GoUInt8))) {
                _inc = _rbit != ((0 : GoUInt));
            } else if (_z._mode == ((3 : GoUInt8))) {
                _inc = true;
            } else if (_z._mode == ((5 : GoUInt8))) {
                _inc = !_z._neg;
            } else {
                throw Go.toInterface(((("unreachable" : GoString))));
            };
            _z._acc = _makeAcc(_inc != _z._neg);
            if (_inc) {
                if (_addVW(_z._mant, _z._mant, _lsb) != ((0 : GoUInt))) {
                    if (_z._exp >= ((2147483647 : GoInt32))) {
                        _z._form = ((2 : GoUInt8));
                        return;
                    };
                    _z._exp++;
                    _shrVU(_z._mant, _z._mant, ((1 : GoUInt)));
                    {};
                    if (_z._mant != null) (_z._mant != null ? _z._mant[_n - ((1 : GoUInt32))] : new Word()) | ((("2147483648" : GoUInt)));
                };
            };
        };
        if (_z._mant != null) (_z._mant != null ? _z._mant[((0 : GoInt))] : new Word()) & ((_lsb - ((1 : GoUInt))) ^ ((-1 : GoUnTypedInt)));
        if (false) {
            _z._validate();
        };
    }
    @:keep
    public function _validate():Void {
        var _x = __t__;
        _x;
        if (true) {
            throw Go.toInterface(((("validate called but debugFloat is not set" : GoString))));
        };
        if (_x._form != ((1 : GoUInt8))) {
            return;
        };
        var _m:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        if (_m == ((0 : GoInt))) {
            throw Go.toInterface(((("nonzero finite number with empty mantissa" : GoString))));
        };
        {};
        if (((_x._mant != null ? _x._mant[_m - ((1 : GoInt))] : new Word()) & (("2147483648" : GoUInt))) == ((0 : GoUInt))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("msb not set in last word %#x of %s" : GoString))), Go.toInterface((_x._mant != null ? _x._mant[_m - ((1 : GoInt))] : new Word())), Go.toInterface(_x.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt))))));
        };
        if (_x._prec == ((0 : GoUInt32))) {
            throw Go.toInterface(((("zero precision finite number" : GoString))));
        };
    }
    @:keep
    public function isInt():Bool {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form != ((1 : GoUInt8))) {
            return _x._form == ((0 : GoUInt8));
        };
        if (_x._exp <= ((0 : GoInt32))) {
            return false;
        };
        return (_x._prec <= ((_x._exp : GoUInt32))) || (_x.minPrec() <= ((_x._exp : GoUInt)));
    }
    @:keep
    public function isInf():Bool {
        var _x = __t__;
        _x;
        return _x._form == ((2 : GoUInt8));
    }
    @:keep
    public function signbit():Bool {
        var _x = __t__;
        _x;
        return _x._neg;
    }
    @:keep
    public function setMantExp(_mant:Float_, _exp:GoInt):Float_ {
        var _z = __t__;
        _z;
        if (false) {
            _z._validate();
            _mant._validate();
        };
        _z.copy(_mant);
        if (_z._form == ((1 : GoUInt8))) {
            _z._setExpAndRound(((_z._exp : GoInt64)) + ((_exp : GoInt64)), ((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public function _setExpAndRound(_exp:GoInt64, _sbit:GoUInt):Void {
        var _z = __t__;
        _z;
        if (_exp < ((-2147483648 : GoInt64))) {
            _z._acc = _makeAcc(_z._neg);
            _z._form = ((0 : GoUInt8));
            return;
        };
        if (_exp > ((2147483647 : GoInt64))) {
            _z._acc = _makeAcc(!_z._neg);
            _z._form = ((2 : GoUInt8));
            return;
        };
        _z._form = ((1 : GoUInt8));
        _z._exp = ((_exp : GoInt32));
        _z._round(_sbit);
    }
    @:keep
    public function mantExp(_mant:Float_):GoInt {
        var _x = __t__;
        _x;
        var _exp:GoInt = ((0 : GoInt));
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            _exp = ((_x._exp : GoInt));
        };
        if (_mant != null) {
            _mant.copy(_x);
            if (_mant._form == ((1 : GoUInt8))) {
                _mant._exp = ((0 : GoInt32));
            };
        };
        return _exp;
    }
    @:keep
    public function sign():GoInt {
        var _x = __t__;
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((0 : GoUInt8))) {
            return ((0 : GoInt));
        };
        if (_x._neg) {
            return ((-1 : GoInt));
        };
        return ((1 : GoInt));
    }
    @:keep
    public function acc():Accuracy {
        var _x = __t__;
        _x;
        return _x._acc;
    }
    @:keep
    public function mode():RoundingMode {
        var _x = __t__;
        _x;
        return _x._mode;
    }
    @:keep
    public function minPrec():GoUInt {
        var _x = __t__;
        _x;
        if (_x._form != ((1 : GoUInt8))) {
            return ((0 : GoUInt));
        };
        return ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - _x._mant._trailingZeroBits();
    }
    @:keep
    public function prec():GoUInt {
        var _x = __t__;
        _x;
        return ((_x._prec : GoUInt));
    }
    @:keep
    public function setMode(_mode:RoundingMode):Float_ {
        var _z = __t__;
        _z;
        _z._mode = _mode;
        _z._acc = ((0 : GoInt8));
        return _z;
    }
    @:keep
    public function setPrec(_prec:GoUInt):Float_ {
        var _z = __t__;
        _z;
        _z._acc = ((0 : GoInt8));
        if (_prec == ((0 : GoUInt))) {
            _z._prec = ((0 : GoUInt32));
            if (_z._form == ((1 : GoUInt8))) {
                _z._acc = _makeAcc(_z._neg);
                _z._form = ((0 : GoUInt8));
            };
            return _z;
        };
        if (_prec > (("4294967295" : GoUInt))) {
            _prec = (("4294967295" : GoUInt));
        };
        var _old:GoUInt32 = _z._prec;
        _z._prec = ((_prec : GoUInt32));
        if (_z._prec < _old) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    public var __t__ : Float_;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class Float__static_extension {
    @:keep
    public static function _sqrtInverse(_z:Ref<Float_>, _x:Float_):Void {
        _z;
        var _u:Ref<Float_> = _newFloat(_z._prec);
        var _v:Ref<Float_> = _newFloat(_z._prec);
        var _three:Ref<Float_> = _three();
        var _ng:Ref<Float_> -> Ref<Float_> = function(_t:Float_):Float_ {
            _u._prec = _t._prec;
            _v._prec = _t._prec;
            _u.mul(_t, _t);
            _u.mul(_x, _u);
            _v.sub(_three, _u);
            _u.mul(_t, _v);
            _u._exp--;
            return _t.set(_u);
        };
        var __tmp__ = _x.float64(), _xf:GoFloat64 = __tmp__._0, _0:Accuracy = __tmp__._1;
        var _sqi:Ref<Float_> = _newFloat(_z._prec);
        _sqi.setFloat64(((1 : GoFloat64)) / stdgo.math.Math.sqrt(_xf));
        {
            var _prec:GoUInt32 = _z._prec + ((32 : GoUInt32));
            while (_sqi._prec < _prec) {
                _sqi._prec = _sqi._prec * (((2 : GoUInt32)));
                _sqi = _ng(_sqi);
            };
        };
        _z.mul(_x, _sqi);
    }
    @:keep
    public static function sqrt(_z:Ref<Float_>, _x:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _x._prec;
        };
        if (_x.sign() == ((-1 : GoInt))) {
            throw Go.toInterface(((new ErrNaN(((("square root of negative operand" : GoString)))) : ErrNaN)));
        };
        if (_x._form != ((1 : GoUInt8))) {
            _z._acc = ((0 : GoInt8));
            _z._form = _x._form;
            _z._neg = _x._neg;
            return _z;
        };
        var _prec:GoUInt32 = _z._prec;
        var _b:GoInt = _x.mantExp(_z);
        _z._prec = _prec;
        if (_b % ((2 : GoInt)) == ((0 : GoInt))) {} else if (_b % ((2 : GoInt)) == ((1 : GoInt))) {
            _z._exp++;
        } else if (_b % ((2 : GoInt)) == ((-1 : GoInt))) {
            _z._exp--;
        };
        _z._sqrtInverse(_z);
        return _z.setMantExp(_z, _b / ((2 : GoInt)));
    }
    @:keep
    public static function format(_x:Ref<Float_>, _s:stdgo.fmt.Fmt.State, _format:GoRune):Void {
        _x;
        var __tmp__ = _s.precision(), _prec:GoInt = __tmp__._0, _hasPrec:Bool = __tmp__._1;
        if (!_hasPrec) {
            _prec = ((6 : GoInt));
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _format == ((((("e" : GoString))).code : GoRune)) || _format == ((((("E" : GoString))).code : GoRune)) || _format == ((((("f" : GoString))).code : GoRune)) || _format == ((((("b" : GoString))).code : GoRune)) || _format == ((((("p" : GoString))).code : GoRune)) || _format == ((((("x" : GoString))).code : GoRune)))) {
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _format == ((((("F" : GoString))).code : GoRune)))) {
                    _format = ((((("f" : GoString))).code : GoRune));
                    break;
                    break;
                } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _format == ((((("v" : GoString))).code : GoRune)))) {
                    _format = ((((("g" : GoString))).code : GoRune));
                    @:fallthrough {
                        __switchIndex__ = 3;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _format == ((((("g" : GoString))).code : GoRune)) || _format == ((((("G" : GoString))).code : GoRune)))) {
                    if (!_hasPrec) {
                        _prec = ((-1 : GoInt));
                    };
                    break;
                    break;
                } else {
                    stdgo.fmt.Fmt.fprintf(_s, ((("%%!%c(*big.Float=%s)" : GoString))), Go.toInterface(_format), Go.toInterface(((_x.toString() : GoString))));
                    return;
                    break;
                };
                break;
            };
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        _buf = _x.append(_buf, ((_format : GoByte)), _prec);
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _buf = ((((("?" : GoString))) : Slice<GoByte>));
        };
        var _sign:GoString = (("" : GoString));
        if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))) {
            _sign = ((("-" : GoString)));
            _buf = ((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        } else if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("+" : GoString))).code : GoRune))) {
            _sign = ((("+" : GoString)));
            if (_s.flag((((((" " : GoString))).code : GoRune)))) {
                _sign = (((" " : GoString)));
            };
            _buf = ((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>));
        } else if (_s.flag(((((("+" : GoString))).code : GoRune)))) {
            _sign = ((("+" : GoString)));
        } else if (_s.flag((((((" " : GoString))).code : GoRune)))) {
            _sign = (((" " : GoString)));
        };
        var _padding:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _hasWidth:Bool = __tmp__._1;
            if (_hasWidth && (_width > ((_sign != null ? _sign.length : ((0 : GoInt))) + (_buf != null ? _buf.length : ((0 : GoInt)))))) {
                _padding = (_width - (_sign != null ? _sign.length : ((0 : GoInt)))) - (_buf != null ? _buf.length : ((0 : GoInt)));
            };
        };
        if (_s.flag(((((("0" : GoString))).code : GoRune))) && !_x.isInf()) {
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _writeMultiple(_s, ((("0" : GoString))), _padding);
            _s.write(_buf);
        } else if (_s.flag(((((("-" : GoString))).code : GoRune)))) {
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _s.write(_buf);
            _writeMultiple(_s, (((" " : GoString))), _padding);
        } else {
            _writeMultiple(_s, (((" " : GoString))), _padding);
            _writeMultiple(_s, _sign, ((1 : GoInt)));
            _s.write(_buf);
        };
    }
    @:keep
    public static function _fmtP(_x:Ref<Float_>, _buf:Slice<GoByte>):Slice<GoByte> {
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            return (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        var _i:GoInt = ((0 : GoInt));
        while ((_i < (_m != null ? _m.length : ((0 : GoInt)))) && ((_m != null ? _m[_i] : new Word()) == ((0 : GoUInt)))) {
            _i++;
        };
        _m = (((_m.__slice__(_i) : T_nat)) == null ? null : ((_m.__slice__(_i) : T_nat)).__copy__());
        _buf = (_buf != null ? _buf.__append__(...((("0x." : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x." : GoString))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(...stdgo.bytes.Bytes.trimRight(_m._utoa(((16 : GoInt))), ((("0" : GoString)))).__toArray__()) : new Slice<GoUInt8>(...stdgo.bytes.Bytes.trimRight(_m._utoa(((16 : GoInt))), ((("0" : GoString)))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        if (_x._exp >= ((0 : GoInt32))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, ((_x._exp : GoInt64)), ((10 : GoInt)));
    }
    @:keep
    public static function _fmtX(_x:Ref<Float_>, _buf:Slice<GoByte>, _prec:GoInt):Slice<GoByte> {
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            _buf = (_buf != null ? _buf.__append__(...((("0x0" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x0" : GoString))).__toArray__()));
            if (_prec > ((0 : GoInt))) {
                _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
                {
                    var _i:GoInt = ((0 : GoInt));
                    Go.cfor(_i < _prec, _i++, {
                        _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                    });
                };
            };
            _buf = (_buf != null ? _buf.__append__(...((("p+00" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("p+00" : GoString))).__toArray__()));
            return _buf;
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _n:GoUInt = ((0 : GoUInt));
        if (_prec < ((0 : GoInt))) {
            _n = ((1 : GoUInt)) + ((((_x.minPrec() - ((1 : GoUInt))) + ((3 : GoUInt))) / ((4 : GoUInt))) * ((4 : GoUInt)));
        } else {
            _n = ((1 : GoUInt)) + (((4 : GoUInt)) * ((_prec : GoUInt)));
        };
        _x = new Float_().setPrec(_n).setMode(_x._mode).set(_x);
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _w:GoUInt = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt));
            if (_w < _n) {
                _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), _n - _w) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), _n - _w).__copy__());
            } else if (_w > _n) {
                _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _w - _n) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), _w - _n).__copy__());
            };
        };
        var _exp64:GoInt64 = ((_x._exp : GoInt64)) - ((1 : GoInt64));
        var _hm:Slice<GoUInt8> = _m._utoa(((16 : GoInt)));
        if (false && ((_hm != null ? _hm[((0 : GoInt))] : ((0 : GoUInt8))) != ((((("1" : GoString))).code : GoRune)))) {
            throw Go.toInterface(((("incorrect mantissa: " : GoString))) + ((_hm : GoString)));
        };
        _buf = (_buf != null ? _buf.__append__(...((("0x1" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("0x1" : GoString))).__toArray__()));
        if ((_hm != null ? _hm.length : ((0 : GoInt))) > ((1 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            _buf = (_buf != null ? _buf.__append__(...((_hm.__slice__(((1 : GoInt))) : Slice<GoUInt8>)).__toArray__()) : new Slice<GoUInt8>(...((_hm.__slice__(((1 : GoInt))) : Slice<GoUInt8>)).__toArray__()));
        };
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        if (_exp64 >= ((0 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        } else {
            _exp64 = -_exp64;
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        if (_exp64 < ((10 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _exp64, ((10 : GoInt)));
    }
    @:keep
    public static function _fmtB(_x:Ref<Float_>, _buf:Slice<GoByte>):Slice<GoByte> {
        _x;
        if (_x._form == ((0 : GoUInt8))) {
            return (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
        };
        if (false && (_x._form != ((1 : GoUInt8)))) {
            throw Go.toInterface(((("non-finite float" : GoString))));
        };
        var _m:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _w:GoUInt32 = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt32)) * ((32 : GoUInt32));
            if (_w < _x._prec) {
                _m = (((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), (((_x._prec - _w) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_m == null ? null : _m.__copy__()), (((_x._prec - _w) : GoUInt))).__copy__());
            } else if (_w > _x._prec) {
                _m = (((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), (((_w - _x._prec) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shr((_m == null ? null : _m.__copy__()), (((_w - _x._prec) : GoUInt))).__copy__());
            };
        };
        _buf = (_buf != null ? _buf.__append__(..._m._utoa(((10 : GoInt))).__toArray__()) : new Slice<GoUInt8>(..._m._utoa(((10 : GoInt))).__toArray__()));
        _buf = (_buf != null ? _buf.__append__(((((("p" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("p" : GoString))).code : GoRune))));
        var _e:GoInt64 = ((_x._exp : GoInt64)) - ((_x._prec : GoInt64));
        if (_e >= ((0 : GoInt64))) {
            _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
        };
        return stdgo.strconv.Strconv.appendInt(_buf, _e, ((10 : GoInt)));
    }
    @:keep
    public static function append(_x:Ref<Float_>, _buf:Slice<GoByte>, _fmt:GoByte, _prec:GoInt):Slice<GoByte> {
        _x;
        if (_x._neg) {
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        if (_x._form == ((2 : GoUInt8))) {
            if (!_x._neg) {
                _buf = (_buf != null ? _buf.__append__(((((("+" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("+" : GoString))).code : GoRune))));
            };
            return (_buf != null ? _buf.__append__(...((("Inf" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("Inf" : GoString))).__toArray__()));
        };
        if (_fmt == ((((("b" : GoString))).code : GoRune))) {
            return _x._fmtB(_buf);
        } else if (_fmt == ((((("p" : GoString))).code : GoRune))) {
            return _x._fmtP(_buf);
        } else if (_fmt == ((((("x" : GoString))).code : GoRune))) {
            return _x._fmtX(_buf, _prec);
        };
        var _d:T_decimal = new T_decimal();
        if (_x._form == ((1 : GoUInt8))) {
            _d._init((_x._mant == null ? null : _x._mant.__copy__()), ((_x._exp : GoInt)) - _x._mant._bitLen());
        };
        var _shortest:Bool = false;
        if (_prec < ((0 : GoInt))) {
            _shortest = true;
            _roundShortest(_d, _x);
            if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt))) - ((1 : GoInt));
            } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
                _prec = _max((_d._mant != null ? _d._mant.length : ((0 : GoInt))) - _d._exp, ((0 : GoInt)));
            } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
        } else {
            if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
                _d._round(((1 : GoInt)) + _prec);
            } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
                _d._round(_d._exp + _prec);
            } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
                if (_prec == ((0 : GoInt))) {
                    _prec = ((1 : GoInt));
                };
                _d._round(_prec);
            };
        };
        if (_fmt == ((((("e" : GoString))).code : GoRune)) || _fmt == ((((("E" : GoString))).code : GoRune))) {
            return _fmtE(_buf, _fmt, _prec, (_d == null ? null : _d.__copy__()));
        } else if (_fmt == ((((("f" : GoString))).code : GoRune))) {
            return _fmtF(_buf, _prec, (_d == null ? null : _d.__copy__()));
        } else if (_fmt == ((((("g" : GoString))).code : GoRune)) || _fmt == ((((("G" : GoString))).code : GoRune))) {
            var _eprec:GoInt = _prec;
            if ((_eprec > (_d._mant != null ? _d._mant.length : ((0 : GoInt)))) && ((_d._mant != null ? _d._mant.length : ((0 : GoInt))) >= _d._exp)) {
                _eprec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
            if (_shortest) {
                _eprec = ((6 : GoInt));
            };
            var _exp:GoInt = _d._exp - ((1 : GoInt));
            if ((_exp < ((-4 : GoInt))) || (_exp >= _eprec)) {
                if (_prec > (_d._mant != null ? _d._mant.length : ((0 : GoInt)))) {
                    _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
                };
                return _fmtE(_buf, (_fmt + ((((("e" : GoString))).code : GoRune))) - ((((("g" : GoString))).code : GoRune)), _prec - ((1 : GoInt)), (_d == null ? null : _d.__copy__()));
            };
            if (_prec > _d._exp) {
                _prec = (_d._mant != null ? _d._mant.length : ((0 : GoInt)));
            };
            return _fmtF(_buf, _max(_prec - _d._exp, ((0 : GoInt))), (_d == null ? null : _d.__copy__()));
        };
        if (_x._neg) {
            _buf = ((_buf.__slice__(0, (_buf != null ? _buf.length : ((0 : GoInt))) - ((1 : GoInt))) : Slice<GoUInt8>));
        };
        return (_buf != null ? _buf.__append__(((((("%" : GoString))).code : GoRune)), _fmt) : new Slice<GoUInt8>(((((("%" : GoString))).code : GoRune)), _fmt));
    }
    @:keep
    public static function toString(_x:Ref<Float_>):GoString {
        _x;
        return _x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt)));
    }
    @:keep
    public static function text(_x:Ref<Float_>, _format:GoByte, _prec:GoInt):GoString {
        _x;
        var _cap:GoInt = ((10 : GoInt));
        if (_prec > ((0 : GoInt))) {
            _cap = _cap + (_prec);
        };
        return ((_x.append(new Slice<GoUInt8>(...[for (i in 0 ... ((((0 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]).__setCap__(((_cap : GoInt)).toBasic()), _format, _prec) : GoString));
    }
    @:keep
    public static function unmarshalText(_z:Ref<Float_>, _text:Slice<GoByte>):Error {
        _z;
        var __tmp__ = _z.parse(((_text : GoString)), ((0 : GoInt))), _0:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if (_err != null) {
            _err = stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Float (%v)" : GoString))), Go.toInterface(_text), Go.toInterface(_err));
        };
        return _err;
    }
    @:keep
    public static function marshalText(_x:Ref<Float_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x == null) {
            return { _0 : ((((("<nil>" : GoString))) : Slice<GoByte>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        return { _0 : _x.append(_buf, ((((("g" : GoString))).code : GoRune)), ((-1 : GoInt))), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function gobDecode(_z:Ref<Float_>, _buf:Slice<GoByte>):Error {
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Float_() : Float_));
                _z._prec = __tmp__._prec;
                _z._mode = __tmp__._mode;
                _z._acc = __tmp__._acc;
                _z._form = __tmp__._form;
                _z._neg = __tmp__._neg;
                _z._mant = __tmp__._mant;
                _z._exp = __tmp__._exp;
            };
            return ((null : stdgo.Error));
        };
        if ((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Float.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface((_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)))));
        };
        var _oldPrec:GoUInt32 = _z._prec;
        var _oldMode:RoundingMode = _z._mode;
        var _b:GoUInt8 = (_buf != null ? _buf[((1 : GoInt))] : ((0 : GoUInt8)));
        _z._mode = ((((_b >> ((5 : GoUnTypedInt))) & ((7 : GoUInt8))) : RoundingMode));
        _z._acc = ((((_b >> ((3 : GoUnTypedInt))) & ((3 : GoUInt8))) : Accuracy)) - ((1 : GoInt8));
        _z._form = ((((_b >> ((1 : GoUnTypedInt))) & ((3 : GoUInt8))) : T_form));
        _z._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._prec = stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((2 : GoInt))) : Slice<GoUInt8>)));
        if (_z._form == ((1 : GoUInt8))) {
            _z._exp = ((stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((6 : GoInt))) : Slice<GoUInt8>))) : GoInt32));
            _z._mant = (_z._mant._setBytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>))) == null ? null : _z._mant._setBytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>))).__copy__());
        };
        if (_oldPrec != ((0 : GoUInt32))) {
            _z._mode = _oldMode;
            _z.setPrec(((_oldPrec : GoUInt)));
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public static function gobEncode(_x:Ref<Float_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _sz:GoInt = ((6 : GoInt));
        var _n:GoInt = ((0 : GoInt));
        if (_x._form == ((1 : GoUInt8))) {
            _n = ((((_x._prec + ((31 : GoUInt32))) / ((32 : GoUInt32))) : GoInt));
            if ((_x._mant != null ? _x._mant.length : ((0 : GoInt))) < _n) {
                _n = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
            };
            _sz = _sz + (((4 : GoInt)) + (_n * ((4 : GoInt))));
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_sz : GoInt)).toBasic()) ((0 : GoUInt8))]);
        if (_buf != null) _buf[((0 : GoInt))] = ((1 : GoUInt8));
        var _b:GoUInt8 = (((((_x._mode & ((7 : GoUInt8))) : GoByte)) << ((5 : GoUnTypedInt))) | (((((_x._acc + ((1 : GoInt8))) & ((3 : GoInt8))) : GoByte)) << ((3 : GoUnTypedInt)))) | ((((_x._form & ((3 : GoUInt8))) : GoByte)) << ((1 : GoUnTypedInt)));
        if (_x._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[((1 : GoInt))] = _b;
        stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(((2 : GoInt))) : Slice<GoUInt8>)), _x._prec);
        if (_x._form == ((1 : GoUInt8))) {
            stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(((6 : GoInt))) : Slice<GoUInt8>)), ((_x._exp : GoUInt32)));
            ((_x._mant.__slice__((_x._mant != null ? _x._mant.length : ((0 : GoInt))) - _n) : T_nat))._bytes(((_buf.__slice__(((10 : GoInt))) : Slice<GoUInt8>)));
        };
        return { _0 : _buf, _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function scan(_z:Ref<Float_>, _s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        _z;
        _s.skipSpace();
        var __tmp__ = _z._scan(((new T_byteReader(_s) : T_byteReader)), ((0 : GoInt))), _0:Ref<Float_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        return _err;
    }
    @:keep
    public static function parse(_z:Ref<Float_>, _s:GoString, _base:GoInt):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        _z;
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        if (((_s != null ? _s.length : ((0 : GoInt))) == ((3 : GoInt))) && ((_s == ((("Inf" : GoString)))) || (_s == ((("inf" : GoString)))))) {
            _f = _z.setInf(false);
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((((_s != null ? _s.length : ((0 : GoInt))) == ((4 : GoInt))) && (((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("+" : GoString))).code : GoRune))) || ((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune))))) && ((((_s.__slice__(((1 : GoInt))) : GoString)) == ((("Inf" : GoString)))) || (((_s.__slice__(((1 : GoInt))) : GoString)) == ((("inf" : GoString)))))) {
            _f = _z.setInf((_s != null ? _s[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("-" : GoString))).code : GoRune)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_s);
        {
            {
                var __tmp__ = _z._scan(_r, _base);
                _f = __tmp__._0;
                _b = __tmp__._1;
                _err = __tmp__._2;
            };
            if (_err != null) {
                return { _0 : _f, _1 : _b, _2 : _err };
            };
        };
        {
            var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err2:stdgo.Error = __tmp__._1;
            if (_err2 == null) {
                _err = stdgo.fmt.Fmt.errorf(((("expected end of string, found %q" : GoString))), Go.toInterface(_ch));
            } else if (_err2 != stdgo.io.Io.eof) {
                _err = _err2;
            };
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    @:keep
    public static function _pow5(_z:Ref<Float_>, _n:GoUInt64):Float_ {
        _z;
        {};
        if (_n <= ((27 : GoUInt64))) {
            return _z.setUint64((_pow5tab != null ? _pow5tab[_n] : ((0 : GoUInt64))));
        };
        _z.setUint64((_pow5tab != null ? _pow5tab[((27 : GoUInt64))] : ((0 : GoUInt64))));
        _n = _n - (((27 : GoUInt64)));
        var _f:Ref<Float_> = new Float_().setPrec(_z.prec() + ((64 : GoUInt))).setUint64(((5 : GoUInt64)));
        while (_n > ((0 : GoUInt64))) {
            if ((_n & ((1 : GoUInt64))) != ((0 : GoUInt64))) {
                _z.mul(_z, _f);
            };
            _f.mul(_f, _f);
            _n = _n >> (((1 : GoUnTypedInt)));
        };
        return _z;
    }
    @:keep
    public static function _scan(_z:Ref<Float_>, _r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Float_; var _1 : GoInt; var _2 : Error; } {
        _z;
        var _f:Float_ = ((null : Ref<Float_>)), _b:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        var _prec:GoUInt32 = _z._prec;
        if (_prec == ((0 : GoUInt32))) {
            _prec = ((64 : GoUInt32));
        };
        _z._form = ((0 : GoUInt8));
        {
            var __tmp__ = _scanSign(_r);
            _z._neg = __tmp__._0;
            _err = __tmp__._1;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _fcount:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _z._mant._scan(_r, _base, true);
            _z._mant = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _b = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp:GoInt64 = ((0 : GoInt64));
        var _ebase:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _scanExponent(_r, true, _base == ((0 : GoInt)));
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if ((_z._mant != null ? _z._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._prec = _prec;
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _f = _z;
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _exp2:GoInt64 = ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__()));
        var _exp5:GoInt64 = ((((0 : GoInt64)) : GoInt64));
        if (_fcount < ((0 : GoInt))) {
            var _d:GoInt64 = ((_fcount : GoInt64));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _b == ((10 : GoInt)))) {
                        _exp5 = _d;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _b == ((2 : GoInt)))) {
                        _exp2 = _exp2 + (_d);
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _b == ((8 : GoInt)))) {
                        _exp2 = _exp2 + (_d * ((3 : GoInt64)));
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _b == ((16 : GoInt)))) {
                        _exp2 = _exp2 + (_d * ((4 : GoInt64)));
                        break;
                        break;
                    } else {
                        throw Go.toInterface(((("unexpected mantissa base" : GoString))));
                        break;
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ebase == ((10 : GoInt)))) {
                    _exp5 = _exp5 + (_exp);
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ebase == ((2 : GoInt)))) {
                    _exp2 = _exp2 + (_exp);
                    break;
                    break;
                } else {
                    throw Go.toInterface(((("unexpected exponent base" : GoString))));
                    break;
                };
                break;
            };
        };
        if ((((-2147483648 : GoInt64)) <= _exp2) && (_exp2 <= ((2147483647 : GoInt64)))) {
            _z._prec = _prec;
            _z._form = ((1 : GoUInt8));
            _z._exp = ((_exp2 : GoInt32));
            _f = _z;
        } else {
            _err = stdgo.fmt.Fmt.errorf(((("exponent overflow" : GoString))));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        if (_exp5 == ((0 : GoInt64))) {
            _z._round(((0 : GoUInt)));
            return { _0 : _f, _1 : _b, _2 : _err };
        };
        var _p:Ref<Float_> = new Float_().setPrec(_z.prec() + ((64 : GoUInt)));
        if (_exp5 < ((0 : GoInt64))) {
            _z.quo(_z, _p._pow5(((-_exp5 : GoUInt64))));
        } else {
            _z.mul(_z, _p._pow5(((_exp5 : GoUInt64))));
        };
        return { _0 : _f, _1 : _b, _2 : _err };
    }
    @:keep
    public static function setString(_z:Ref<Float_>, _s:GoString):{ var _0 : Float_; var _1 : Bool; } {
        _z;
        {
            var __tmp__ = _z.parse(_s, ((0 : GoInt))), _f:Ref<Float_> = __tmp__._0, _0:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err == null) {
                return { _0 : _f, _1 : true };
            };
        };
        return { _0 : null, _1 : false };
    }
    @:keep
    public static function _int64(_x:Ref<Float_>):GoInt64 {
        _x;
        var __tmp__ = _x.int64(), _i:GoInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
        if (_acc != ((0 : GoInt8))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("%s is not an int64" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt))))));
        };
        return _i;
    }
    @:keep
    public static function _uint64(_x:Ref<Float_>):GoUInt64 {
        _x;
        var __tmp__ = _x.uint64(), _u:GoUInt64 = __tmp__._0, _acc:Accuracy = __tmp__._1;
        if (_acc != ((0 : GoInt8))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("%s is not a uint64" : GoString))), Go.toInterface(_x.text(((((("g" : GoString))).code : GoRune)), ((10 : GoInt))))));
        };
        return _u;
    }
    @:keep
    public static function _ord(_x:Ref<Float_>):GoInt {
        _x;
        var _m:GoInt = ((0 : GoInt));
        if (_x._form == ((1 : GoUInt8))) {
            _m = ((1 : GoInt));
        } else if (_x._form == ((0 : GoUInt8))) {
            return ((0 : GoInt));
        } else if (_x._form == ((2 : GoUInt8))) {
            _m = ((2 : GoInt));
        };
        if (_x._neg) {
            _m = -_m;
        };
        return _m;
    }
    @:keep
    public static function cmp(_x:Ref<Float_>, _y:Float_):GoInt {
        _x;
        if (false) {
            _x._validate();
            _y._validate();
        };
        var _mx:GoInt = _x._ord();
        var _my:GoInt = _y._ord();
        if (_mx < _my) {
            return ((-1 : GoInt));
        } else if (_mx > _my) {
            return ((1 : GoInt));
        };
        if (_mx == ((-1 : GoInt))) {
            return _y._ucmp(_x);
        } else if (_mx == ((1 : GoInt))) {
            return _x._ucmp(_y);
        };
        return ((0 : GoInt));
    }
    @:keep
    public static function quo(_z:Ref<Float_>, _x:Float_, _y:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != _y._neg;
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            _z._uquo(_x, _y);
            return _z;
        };
        _z._acc = ((0 : GoInt8));
        if (((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) || ((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8))))) {
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("division of zero by zero or infinity by infinity" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) || (_y._form == ((2 : GoUInt8)))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._form = ((2 : GoUInt8));
        return _z;
    }
    @:keep
    public static function mul(_z:Ref<Float_>, _x:Float_, _y:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        _z._neg = _x._neg != _y._neg;
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            _z._umul(_x, _y);
            return _z;
        };
        _z._acc = ((0 : GoInt8));
        if (((_x._form == ((0 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) || ((_x._form == ((2 : GoUInt8))) && (_y._form == ((0 : GoUInt8))))) {
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("multiplication of zero with infinity" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((2 : GoUInt8)))) {
            _z._form = ((2 : GoUInt8));
            return _z;
        };
        _z._form = ((0 : GoUInt8));
        return _z;
    }
    @:keep
    public static function sub(_z:Ref<Float_>, _x:Float_, _y:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg != _yneg) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > ((0 : GoInt))) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == ((0 : GoUInt8))) && (_z._mode == ((4 : GoUInt8)))) && (_z._acc == ((0 : GoInt8)))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) && (_x._neg == _y._neg)) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("subtraction of infinities with equal signs" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = _x._neg && !_y._neg;
            return _z;
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((0 : GoUInt8)))) {
            return _z.set(_x);
        };
        return _z.neg(_y);
    }
    @:keep
    public static function add(_z:Ref<Float_>, _x:Float_, _y:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
            _y._validate();
        };
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_x._prec, _y._prec);
        };
        if ((_x._form == ((1 : GoUInt8))) && (_y._form == ((1 : GoUInt8)))) {
            var _yneg:Bool = _y._neg;
            _z._neg = _x._neg;
            if (_x._neg == _yneg) {
                _z._uadd(_x, _y);
            } else {
                if (_x._ucmp(_y) > ((0 : GoInt))) {
                    _z._usub(_x, _y);
                } else {
                    _z._neg = !_z._neg;
                    _z._usub(_y, _x);
                };
            };
            if (((_z._form == ((0 : GoUInt8))) && (_z._mode == ((4 : GoUInt8)))) && (_z._acc == ((0 : GoInt8)))) {
                _z._neg = true;
            };
            return _z;
        };
        if (((_x._form == ((2 : GoUInt8))) && (_y._form == ((2 : GoUInt8)))) && (_x._neg != _y._neg)) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            throw Go.toInterface(((new ErrNaN(((("addition of infinities with opposite signs" : GoString)))) : ErrNaN)));
        };
        if ((_x._form == ((0 : GoUInt8))) && (_y._form == ((0 : GoUInt8)))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = _x._neg && _y._neg;
            return _z;
        };
        if ((_x._form == ((2 : GoUInt8))) || (_y._form == ((0 : GoUInt8)))) {
            return _z.set(_x);
        };
        return _z.set(_y);
    }
    @:keep
    public static function _ucmp(_x:Ref<Float_>, _y:Float_):GoInt {
        _x;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        if (_x._exp < _y._exp) {
            return ((-1 : GoInt));
        } else if (_x._exp > _y._exp) {
            return ((1 : GoInt));
        };
        var _i:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        var _j:GoInt = (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) || (_j > ((0 : GoInt)))) {
            var _xm:Word = new Word(), _ym:Word = new Word();
            if (_i > ((0 : GoInt))) {
                _i--;
                _xm = (_x._mant != null ? _x._mant[_i] : new Word());
            };
            if (_j > ((0 : GoInt))) {
                _j--;
                _ym = (_y._mant != null ? _y._mant[_j] : new Word());
            };
            if (_xm < _ym) {
                return ((-1 : GoInt));
            } else if (_xm > _ym) {
                return ((1 : GoInt));
            };
        };
        return ((0 : GoInt));
    }
    @:keep
    public static function _uquo(_z:Ref<Float_>, _x:Float_, _y:Float_):Void {
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _n:GoInt = (((_z._prec / ((32 : GoUInt32))) : GoInt)) + ((1 : GoInt));
        var _xadj:T_nat = (_x._mant == null ? null : _x._mant.__copy__());
        {
            var _d:GoInt = (_n - (_x._mant != null ? _x._mant.length : ((0 : GoInt)))) + (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
            if (_d > ((0 : GoInt))) {
                _xadj = new Slice<Word>(...[for (i in 0 ... (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) + _d : GoInt)).toBasic()) new Word()]);
                Go.copySlice(((_xadj.__slice__(_d) : T_nat)), _x._mant);
            };
        };
        var _d:GoInt = (_xadj != null ? _xadj.length : ((0 : GoInt))) - (_y._mant != null ? _y._mant.length : ((0 : GoInt)));
        var _r:T_nat = new T_nat();
        {
            var __tmp__ = _z._mant._div(null, (_xadj == null ? null : _xadj.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
            _z._mant = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        var _e:GoInt64 = (((_x._exp : GoInt64)) - ((_y._exp : GoInt64))) - ((((_d - (_z._mant != null ? _z._mant.length : ((0 : GoInt)))) : GoInt64)) * ((32 : GoInt64)));
        var _sbit:GoUInt = ((0 : GoUInt));
        if ((_r != null ? _r.length : ((0 : GoInt))) > ((0 : GoInt))) {
            _sbit = ((1 : GoUInt));
        };
        _z._setExpAndRound(_e - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), _sbit);
    }
    @:keep
    public static function _umul(_z:Ref<Float_>, _x:Float_, _y:Float_):Void {
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _e:GoInt64 = ((_x._exp : GoInt64)) + ((_y._exp : GoInt64));
        if (_x == _y) {
            _z._mant = (_z._mant._sqr((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._sqr((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
        } else {
            _z._mant = (_z._mant._mul((_x._mant == null ? null : _x._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._mul((_x._mant == null ? null : _x._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
        };
        _z._setExpAndRound(_e - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public static function _usub(_z:Ref<Float_>, _x:Float_, _y:Float_):Void {
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = ((_x._exp : GoInt64)) - ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _ey:GoInt64 = ((_y._exp : GoInt64)) - ((((_y._mant != null ? _y._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _al:Bool = _alias((_z._mant == null ? null : _z._mant.__copy__()), (_x._mant == null ? null : _x._mant.__copy__())) || _alias((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
        if (_ex < _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_t._sub((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())) == null ? null : _t._sub((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : _z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._sub((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())) == null ? null : _z._mant._sub((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())).__copy__());
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_t._sub((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _t._sub((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : _z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._sub((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._sub((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            };
            _ex = _ey;
        };
        if ((_z._mant != null ? _z._mant.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._acc = ((0 : GoInt8));
            _z._form = ((0 : GoUInt8));
            _z._neg = false;
            return;
        };
        _z._setExpAndRound((_ex + ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public static function _uadd(_z:Ref<Float_>, _x:Float_, _y:Float_):Void {
        _z;
        if (false) {
            _validateBinaryOperands(_x, _y);
        };
        var _ex:GoInt64 = ((_x._exp : GoInt64)) - ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _ey:GoInt64 = ((_y._exp : GoInt64)) - ((((_y._mant != null ? _y._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)));
        var _al:Bool = _alias((_z._mant == null ? null : _z._mant.__copy__()), (_x._mant == null ? null : _x._mant.__copy__())) || _alias((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__()));
        if (_ex < _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())) == null ? null : _z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_t == null ? null : _t.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))) == null ? null : _z._mant._shl((_y._mant == null ? null : _y._mant.__copy__()), (((_ey - _ex) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())) == null ? null : _z._mant._add((_x._mant == null ? null : _x._mant.__copy__()), (_z._mant == null ? null : _z._mant.__copy__())).__copy__());
            };
        } else if (_ex > _ey) {
            if (_al) {
                var _t:T_nat = (((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._add((_t == null ? null : _t.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            } else {
                _z._mant = (_z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))) == null ? null : _z._mant._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_ex - _ey) : GoUInt))).__copy__());
                _z._mant = (_z._mant._add((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())) == null ? null : _z._mant._add((_z._mant == null ? null : _z._mant.__copy__()), (_y._mant == null ? null : _y._mant.__copy__())).__copy__());
            };
            _ex = _ey;
        };
        _z._setExpAndRound((_ex + ((((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoInt64)) * ((32 : GoInt64)))) - _fnorm((_z._mant == null ? null : _z._mant.__copy__())), ((0 : GoUInt)));
    }
    @:keep
    public static function neg(_z:Ref<Float_>, _x:Float_):Float_ {
        _z;
        _z.set(_x);
        _z._neg = !_z._neg;
        return _z;
    }
    @:keep
    public static function abs(_z:Ref<Float_>, _x:Float_):Float_ {
        _z;
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function rat(_x:Ref<Float_>, _z:Rat):{ var _0 : Rat; var _1 : Accuracy; } {
        _x;
        if (false) {
            _x._validate();
        };
        if ((_z == null) && (_x._form <= ((1 : GoUInt8)))) {
            _z = new Rat();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _allBits:GoInt32 = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoInt32)) * ((32 : GoInt32));
            _z._a._neg = _x._neg;
            if (_x._exp > _allBits) {
                _z._a._abs = (_z._a._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_x._exp - _allBits) : GoUInt))) == null ? null : _z._a._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), (((_x._exp - _allBits) : GoUInt))).__copy__());
                _z._b._abs = (((_z._b._abs.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z._b._abs.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            } else if (_x._exp < _allBits) {
                _z._a._abs = (_z._a._abs._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._a._abs._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
                var _t:T_nat = (_z._b._abs._setUint64(((1 : GoUInt64))) == null ? null : _z._b._abs._setUint64(((1 : GoUInt64))).__copy__());
                _z._b._abs = (_t._shl((_t == null ? null : _t.__copy__()), (((_allBits - _x._exp) : GoUInt))) == null ? null : _t._shl((_t == null ? null : _t.__copy__()), (((_allBits - _x._exp) : GoUInt))).__copy__());
                _z._norm();
            };
            return { _0 : _z, _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : _z.setInt64(((0 : GoInt64))), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            return { _0 : null, _1 : _makeAcc(_x._neg) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public static function int(_x:Ref<Float_>, _z:Int_):{ var _0 : Int_; var _1 : Accuracy; } {
        _x;
        if (false) {
            _x._validate();
        };
        if ((_z == null) && (_x._form <= ((1 : GoUInt8)))) {
            _z = new Int_();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _acc:Accuracy = _makeAcc(_x._neg);
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : _z.setInt64(((0 : GoInt64))), _1 : _acc };
            };
            var _allBits:GoUInt = (((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt));
            var _exp:GoUInt = ((_x._exp : GoUInt));
            if (_x.minPrec() <= _exp) {
                _acc = ((0 : GoInt8));
            };
            if (_z == null) {
                _z = new Int_();
            };
            _z._neg = _x._neg;
            if (_exp > _allBits) {
                _z._abs = (_z._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), _exp - _allBits) == null ? null : _z._abs._shl((_x._mant == null ? null : _x._mant.__copy__()), _exp - _allBits).__copy__());
            } else if (_exp < _allBits) {
                _z._abs = (_z._abs._shr((_x._mant == null ? null : _x._mant.__copy__()), _allBits - _exp) == null ? null : _z._abs._shr((_x._mant == null ? null : _x._mant.__copy__()), _allBits - _exp).__copy__());
            };
            return { _0 : _z, _1 : _acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : _z.setInt64(((0 : GoInt64))), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            return { _0 : null, _1 : _makeAcc(_x._neg) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public static function float64(_x:Ref<Float_>):{ var _0 : GoFloat64; var _1 : Accuracy; } {
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            {};
            var _e:GoInt32 = _x._exp - ((1 : GoInt32));
            var _p:GoInt = ((53 : GoInt));
            if (_e < ((-1022 : GoInt32))) {
                _p = ((1075 : GoInt)) + ((_e : GoInt));
                if ((_p < ((0 : GoInt))) || ((_p == ((0 : GoInt))) && (_x._mant._sticky(((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - ((1 : GoUInt))) == ((0 : GoUInt))))) {
                    if (_x._neg) {
                        var _z:GoFloat64 = ((0 : GoFloat64));
                        return { _0 : -_z, _1 : ((1 : GoInt8)) };
                    };
                    return { _0 : ((0 : GoFloat64)), _1 : ((-1 : GoInt8)) };
                };
                if (_p == ((0 : GoInt))) {
                    if (_x._neg) {
                        return { _0 : ((-5e-324 : GoFloat64)), _1 : ((-1 : GoInt8)) };
                    };
                    return { _0 : ((5e-324 : GoFloat64)), _1 : ((1 : GoInt8)) };
                };
            };
            var _r:Float_ = new Float_();
            _r._prec = ((_p : GoUInt32));
            _r.set(_x);
            _e = _r._exp - ((1 : GoInt32));
            if ((_r._form == ((2 : GoUInt8))) || (_e > ((1023 : GoInt32)))) {
                if (_x._neg) {
                    return { _0 : stdgo.math.Math.inf(((-1 : GoInt))), _1 : ((-1 : GoInt8)) };
                };
                return { _0 : stdgo.math.Math.inf(((1 : GoInt))), _1 : ((1 : GoInt8)) };
            };
            var _sign:GoUInt64 = ((0 : GoUInt64)), _bexp:GoUInt64 = ((0 : GoUInt64)), _mant:GoUInt64 = ((0 : GoUInt64));
            if (_x._neg) {
                _sign = (("9223372036854775808" : GoUInt64));
            };
            if (_e < ((-1022 : GoInt32))) {
                _p = ((1075 : GoInt)) + ((_e : GoInt));
                _mant = _msb64((_r._mant == null ? null : _r._mant.__copy__())) >> (((((64 : GoInt)) - _p) : GoUInt));
            } else {
                _bexp = (((_e + ((1023 : GoInt32))) : GoUInt64)) << ((52 : GoUnTypedInt));
                _mant = (_msb64((_r._mant == null ? null : _r._mant.__copy__())) >> ((11 : GoUnTypedInt))) & (("4503599627370495" : GoUInt64));
            };
            return { _0 : stdgo.math.Math.float64frombits((_sign | _bexp) | _mant), _1 : _r._acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            if (_x._neg) {
                var _z:GoFloat64 = ((0 : GoFloat64));
                return { _0 : -_z, _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((0 : GoFloat64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : stdgo.math.Math.inf(((-1 : GoInt))), _1 : ((0 : GoInt8)) };
            };
            return { _0 : stdgo.math.Math.inf(((1 : GoInt))), _1 : ((0 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public static function float32(_x:Ref<Float_>):{ var _0 : GoFloat32; var _1 : Accuracy; } {
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            {};
            var _e:GoInt32 = _x._exp - ((1 : GoInt32));
            var _p:GoInt = ((24 : GoInt));
            if (_e < ((-126 : GoInt32))) {
                _p = ((150 : GoInt)) + ((_e : GoInt));
                if ((_p < ((0 : GoInt))) || ((_p == ((0 : GoInt))) && (_x._mant._sticky(((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - ((1 : GoUInt))) == ((0 : GoUInt))))) {
                    if (_x._neg) {
                        var _z:GoFloat32 = ((0 : GoFloat32));
                        return { _0 : -_z, _1 : ((1 : GoInt8)) };
                    };
                    return { _0 : ((0 : GoFloat32)), _1 : ((-1 : GoInt8)) };
                };
                if (_p == ((0 : GoInt))) {
                    if (_x._neg) {
                        return { _0 : ((-1.401298464324817e-45 : GoFloat32)), _1 : ((-1 : GoInt8)) };
                    };
                    return { _0 : ((1.401298464324817e-45 : GoFloat32)), _1 : ((1 : GoInt8)) };
                };
            };
            var _r:Float_ = new Float_();
            _r._prec = ((_p : GoUInt32));
            _r.set(_x);
            _e = _r._exp - ((1 : GoInt32));
            if ((_r._form == ((2 : GoUInt8))) || (_e > ((127 : GoInt32)))) {
                if (_x._neg) {
                    return { _0 : ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)), _1 : ((-1 : GoInt8)) };
                };
                return { _0 : ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), _1 : ((1 : GoInt8)) };
            };
            var _sign:GoUInt32 = ((0 : GoUInt32)), _bexp:GoUInt32 = ((0 : GoUInt32)), _mant:GoUInt32 = ((0 : GoUInt32));
            if (_x._neg) {
                _sign = (("2147483648" : GoUInt32));
            };
            if (_e < ((-126 : GoInt32))) {
                _p = ((150 : GoInt)) + ((_e : GoInt));
                _mant = _msb32((_r._mant == null ? null : _r._mant.__copy__())) >> (((((32 : GoInt)) - _p) : GoUInt));
            } else {
                _bexp = (((_e + ((127 : GoInt32))) : GoUInt32)) << ((23 : GoUnTypedInt));
                _mant = (_msb32((_r._mant == null ? null : _r._mant.__copy__())) >> ((8 : GoUnTypedInt))) & ((8388607 : GoUInt32));
            };
            return { _0 : stdgo.math.Math.float32frombits((_sign | _bexp) | _mant), _1 : _r._acc };
        } else if (_x._form == ((0 : GoUInt8))) {
            if (_x._neg) {
                var _z:GoFloat32 = ((0 : GoFloat32));
                return { _0 : -_z, _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((0 : GoFloat32)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((stdgo.math.Math.inf(((-1 : GoInt))) : GoFloat32)), _1 : ((0 : GoInt8)) };
            };
            return { _0 : ((stdgo.math.Math.inf(((1 : GoInt))) : GoFloat32)), _1 : ((0 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public static function int64(_x:Ref<Float_>):{ var _0 : GoInt64; var _1 : Accuracy; } {
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            var _acc:Accuracy = _makeAcc(_x._neg);
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : ((0 : GoInt64)), _1 : _acc };
            };
            if (_x._exp <= ((63 : GoInt32))) {
                var _i:GoInt64 = (((_msb64((_x._mant == null ? null : _x._mant.__copy__())) >> (((64 : GoUInt32)) - ((_x._exp : GoUInt32)))) : GoInt64));
                if (_x._neg) {
                    _i = -_i;
                };
                if (_x.minPrec() <= ((_x._exp : GoUInt))) {
                    return { _0 : _i, _1 : ((0 : GoInt8)) };
                };
                return { _0 : _i, _1 : _acc };
            };
            if (_x._neg) {
                if ((_x._exp == ((64 : GoInt32))) && (_x.minPrec() == ((1 : GoUInt)))) {
                    _acc = ((0 : GoInt8));
                };
                return { _0 : (("-9223372036854775808" : GoInt64)), _1 : _acc };
            };
            return { _0 : (("9223372036854775807" : GoInt64)), _1 : ((-1 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : ((0 : GoInt64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : (("-9223372036854775808" : GoInt64)), _1 : ((1 : GoInt8)) };
            };
            return { _0 : (("9223372036854775807" : GoInt64)), _1 : ((-1 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public static function uint64(_x:Ref<Float_>):{ var _0 : GoUInt64; var _1 : Accuracy; } {
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((0 : GoUInt64)), _1 : ((1 : GoInt8)) };
            };
            if (_x._exp <= ((0 : GoInt32))) {
                return { _0 : ((0 : GoUInt64)), _1 : ((-1 : GoInt8)) };
            };
            if (_x._exp <= ((64 : GoInt32))) {
                var _u:GoUInt64 = _msb64((_x._mant == null ? null : _x._mant.__copy__())) >> (((64 : GoUInt32)) - ((_x._exp : GoUInt32)));
                if (_x.minPrec() <= ((64 : GoUInt))) {
                    return { _0 : _u, _1 : ((0 : GoInt8)) };
                };
                return { _0 : _u, _1 : ((-1 : GoInt8)) };
            };
            return { _0 : (("18446744073709551615" : GoUInt64)), _1 : ((-1 : GoInt8)) };
        } else if (_x._form == ((0 : GoUInt8))) {
            return { _0 : ((0 : GoUInt64)), _1 : ((0 : GoInt8)) };
        } else if (_x._form == ((2 : GoUInt8))) {
            if (_x._neg) {
                return { _0 : ((0 : GoUInt64)), _1 : ((1 : GoInt8)) };
            };
            return { _0 : (("18446744073709551615" : GoUInt64)), _1 : ((-1 : GoInt8)) };
        };
        throw Go.toInterface(((("unreachable" : GoString))));
    }
    @:keep
    public static function copy(_z:Ref<Float_>, _x:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
        };
        if (_z != _x) {
            _z._prec = _x._prec;
            _z._mode = _x._mode;
            _z._acc = _x._acc;
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_z._form == ((1 : GoUInt8))) {
                _z._mant = (_z._mant._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
                _z._exp = _x._exp;
            };
        };
        return _z;
    }
    @:keep
    public static function set(_z:Ref<Float_>, _x:Float_):Float_ {
        _z;
        if (false) {
            _x._validate();
        };
        _z._acc = ((0 : GoInt8));
        if (_z != _x) {
            _z._form = _x._form;
            _z._neg = _x._neg;
            if (_x._form == ((1 : GoUInt8))) {
                _z._exp = _x._exp;
                _z._mant = (_z._mant._set((_x._mant == null ? null : _x._mant.__copy__())) == null ? null : _z._mant._set((_x._mant == null ? null : _x._mant.__copy__())).__copy__());
            };
            if (_z._prec == ((0 : GoUInt32))) {
                _z._prec = _x._prec;
            } else if (_z._prec < _x._prec) {
                _z._round(((0 : GoUInt)));
            };
        };
        return _z;
    }
    @:keep
    public static function setInf(_z:Ref<Float_>, _signbit:Bool):Float_ {
        _z;
        _z._acc = ((0 : GoInt8));
        _z._form = ((2 : GoUInt8));
        _z._neg = _signbit;
        return _z;
    }
    @:keep
    public static function setRat(_z:Ref<Float_>, _x:Rat):Float_ {
        _z;
        if (_x.isInt()) {
            return _z.setInt(_x.num());
        };
        var _a:Float_ = new Float_(), _b:Float_ = new Float_();
        _a.setInt(_x.num());
        _b.setInt(_x.denom());
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_a._prec, _b._prec);
        };
        return _z.quo(_a, _b);
    }
    @:keep
    public static function setInt(_z:Ref<Float_>, _x:Int_):Float_ {
        _z;
        var _bits:GoUInt32 = ((_x.bitLen() : GoUInt32));
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = _umax32(_bits, ((64 : GoUInt32)));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = _x._neg;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._mant = (_z._mant._set((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._mant._set((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
        _fnorm((_z._mant == null ? null : _z._mant.__copy__()));
        _z._setExpAndRound(((_bits : GoInt64)), ((0 : GoUInt)));
        return _z;
    }
    @:keep
    public static function setFloat64(_z:Ref<Float_>, _x:GoFloat64):Float_ {
        _z;
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = ((53 : GoUInt32));
        };
        if (stdgo.math.Math.isNaN(_x)) {
            throw Go.toInterface(((new ErrNaN(((("Float.SetFloat64(NaN)" : GoString)))) : ErrNaN)));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = stdgo.math.Math.signbit(_x);
        if (_x == ((0 : GoFloat64))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        if (stdgo.math.Math.isInf(_x, ((0 : GoInt)))) {
            _z._form = ((2 : GoUInt8));
            return _z;
        };
        _z._form = ((1 : GoUInt8));
        var __tmp__ = stdgo.math.Math.frexp(_x), _fmant:GoFloat64 = __tmp__._0, _exp:GoInt = __tmp__._1;
        _z._mant = (_z._mant._setUint64((("9223372036854775808" : GoUInt64)) | (stdgo.math.Math.float64bits(_fmant) << ((11 : GoUnTypedInt)))) == null ? null : _z._mant._setUint64((("9223372036854775808" : GoUInt64)) | (stdgo.math.Math.float64bits(_fmant) << ((11 : GoUnTypedInt)))).__copy__());
        _z._exp = ((_exp : GoInt32));
        if (_z._prec < ((53 : GoUInt32))) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public static function setInt64(_z:Ref<Float_>, _x:GoInt64):Float_ {
        _z;
        var _u:GoInt64 = _x;
        if (_u < ((0 : GoInt64))) {
            _u = -_u;
        };
        return _z._setBits64(_x < ((0 : GoInt64)), ((_u : GoUInt64)));
    }
    @:keep
    public static function setUint64(_z:Ref<Float_>, _x:GoUInt64):Float_ {
        _z;
        return _z._setBits64(false, _x);
    }
    @:keep
    public static function _setBits64(_z:Ref<Float_>, _neg:Bool, _x:GoUInt64):Float_ {
        _z;
        if (_z._prec == ((0 : GoUInt32))) {
            _z._prec = ((64 : GoUInt32));
        };
        _z._acc = ((0 : GoInt8));
        _z._neg = _neg;
        if (_x == ((0 : GoUInt64))) {
            _z._form = ((0 : GoUInt8));
            return _z;
        };
        _z._form = ((1 : GoUInt8));
        var _s:GoInt = stdgo.math.bits.Bits.leadingZeros64(_x);
        _z._mant = (_z._mant._setUint64(_x << ((_s : GoUInt))) == null ? null : _z._mant._setUint64(_x << ((_s : GoUInt))).__copy__());
        _z._exp = (((((64 : GoInt)) - _s) : GoInt32));
        if (_z._prec < ((64 : GoUInt32))) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public static function _round(_z:Ref<Float_>, _sbit:GoUInt):Void {
        _z;
        if (false) {
            _z._validate();
        };
        _z._acc = ((0 : GoInt8));
        if (_z._form != ((1 : GoUInt8))) {
            return;
        };
        var _m:GoUInt32 = (((_z._mant != null ? _z._mant.length : ((0 : GoInt))) : GoUInt32));
        var _bits:GoUInt32 = _m * ((32 : GoUInt32));
        if (_bits <= _z._prec) {
            return;
        };
        var _r:GoUInt = ((((_bits - _z._prec) - ((1 : GoUInt32))) : GoUInt));
        var _rbit:GoUInt = _z._mant._bit(_r) & ((1 : GoUInt));
        if ((_sbit == ((0 : GoUInt))) && ((_rbit == ((0 : GoUInt))) || (_z._mode == ((0 : GoUInt8))))) {
            _sbit = _z._mant._sticky(_r);
        };
        _sbit = _sbit & (((1 : GoUInt)));
        var _n:GoUInt32 = (_z._prec + ((31 : GoUInt32))) / ((32 : GoUInt32));
        if (_m > _n) {
            Go.copySlice(_z._mant, ((_z._mant.__slice__(_m - _n) : T_nat)));
            _z._mant = (((_z._mant.__slice__(0, _n) : T_nat)) == null ? null : ((_z._mant.__slice__(0, _n) : T_nat)).__copy__());
        };
        var _ntz:GoUInt32 = (_n * ((32 : GoUInt32))) - _z._prec;
        var _lsb:Word = ((((1 : GoUInt)) : Word)) << _ntz;
        if ((_rbit | _sbit) != ((0 : GoUInt))) {
            var _inc:Bool = false;
            if (_z._mode == ((4 : GoUInt8))) {
                _inc = _z._neg;
            } else if (_z._mode == ((2 : GoUInt8))) {} else if (_z._mode == ((0 : GoUInt8))) {
                _inc = (_rbit != ((0 : GoUInt))) && ((_sbit != ((0 : GoUInt))) || (((_z._mant != null ? _z._mant[((0 : GoInt))] : new Word()) & _lsb) != ((0 : GoUInt))));
            } else if (_z._mode == ((1 : GoUInt8))) {
                _inc = _rbit != ((0 : GoUInt));
            } else if (_z._mode == ((3 : GoUInt8))) {
                _inc = true;
            } else if (_z._mode == ((5 : GoUInt8))) {
                _inc = !_z._neg;
            } else {
                throw Go.toInterface(((("unreachable" : GoString))));
            };
            _z._acc = _makeAcc(_inc != _z._neg);
            if (_inc) {
                if (_addVW(_z._mant, _z._mant, _lsb) != ((0 : GoUInt))) {
                    if (_z._exp >= ((2147483647 : GoInt32))) {
                        _z._form = ((2 : GoUInt8));
                        return;
                    };
                    _z._exp++;
                    _shrVU(_z._mant, _z._mant, ((1 : GoUInt)));
                    {};
                    if (_z._mant != null) (_z._mant != null ? _z._mant[_n - ((1 : GoUInt32))] : new Word()) | ((("2147483648" : GoUInt)));
                };
            };
        };
        if (_z._mant != null) (_z._mant != null ? _z._mant[((0 : GoInt))] : new Word()) & ((_lsb - ((1 : GoUInt))) ^ ((-1 : GoUnTypedInt)));
        if (false) {
            _z._validate();
        };
    }
    @:keep
    public static function _validate(_x:Ref<Float_>):Void {
        _x;
        if (true) {
            throw Go.toInterface(((("validate called but debugFloat is not set" : GoString))));
        };
        if (_x._form != ((1 : GoUInt8))) {
            return;
        };
        var _m:GoInt = (_x._mant != null ? _x._mant.length : ((0 : GoInt)));
        if (_m == ((0 : GoInt))) {
            throw Go.toInterface(((("nonzero finite number with empty mantissa" : GoString))));
        };
        {};
        if (((_x._mant != null ? _x._mant[_m - ((1 : GoInt))] : new Word()) & (("2147483648" : GoUInt))) == ((0 : GoUInt))) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("msb not set in last word %#x of %s" : GoString))), Go.toInterface((_x._mant != null ? _x._mant[_m - ((1 : GoInt))] : new Word())), Go.toInterface(_x.text(((((("p" : GoString))).code : GoRune)), ((0 : GoInt))))));
        };
        if (_x._prec == ((0 : GoUInt32))) {
            throw Go.toInterface(((("zero precision finite number" : GoString))));
        };
    }
    @:keep
    public static function isInt(_x:Ref<Float_>):Bool {
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form != ((1 : GoUInt8))) {
            return _x._form == ((0 : GoUInt8));
        };
        if (_x._exp <= ((0 : GoInt32))) {
            return false;
        };
        return (_x._prec <= ((_x._exp : GoUInt32))) || (_x.minPrec() <= ((_x._exp : GoUInt)));
    }
    @:keep
    public static function isInf(_x:Ref<Float_>):Bool {
        _x;
        return _x._form == ((2 : GoUInt8));
    }
    @:keep
    public static function signbit(_x:Ref<Float_>):Bool {
        _x;
        return _x._neg;
    }
    @:keep
    public static function setMantExp(_z:Ref<Float_>, _mant:Float_, _exp:GoInt):Float_ {
        _z;
        if (false) {
            _z._validate();
            _mant._validate();
        };
        _z.copy(_mant);
        if (_z._form == ((1 : GoUInt8))) {
            _z._setExpAndRound(((_z._exp : GoInt64)) + ((_exp : GoInt64)), ((0 : GoUInt)));
        };
        return _z;
    }
    @:keep
    public static function _setExpAndRound(_z:Ref<Float_>, _exp:GoInt64, _sbit:GoUInt):Void {
        _z;
        if (_exp < ((-2147483648 : GoInt64))) {
            _z._acc = _makeAcc(_z._neg);
            _z._form = ((0 : GoUInt8));
            return;
        };
        if (_exp > ((2147483647 : GoInt64))) {
            _z._acc = _makeAcc(!_z._neg);
            _z._form = ((2 : GoUInt8));
            return;
        };
        _z._form = ((1 : GoUInt8));
        _z._exp = ((_exp : GoInt32));
        _z._round(_sbit);
    }
    @:keep
    public static function mantExp(_x:Ref<Float_>, _mant:Float_):GoInt {
        _x;
        var _exp:GoInt = ((0 : GoInt));
        if (false) {
            _x._validate();
        };
        if (_x._form == ((1 : GoUInt8))) {
            _exp = ((_x._exp : GoInt));
        };
        if (_mant != null) {
            _mant.copy(_x);
            if (_mant._form == ((1 : GoUInt8))) {
                _mant._exp = ((0 : GoInt32));
            };
        };
        return _exp;
    }
    @:keep
    public static function sign(_x:Ref<Float_>):GoInt {
        _x;
        if (false) {
            _x._validate();
        };
        if (_x._form == ((0 : GoUInt8))) {
            return ((0 : GoInt));
        };
        if (_x._neg) {
            return ((-1 : GoInt));
        };
        return ((1 : GoInt));
    }
    @:keep
    public static function acc(_x:Ref<Float_>):Accuracy {
        _x;
        return _x._acc;
    }
    @:keep
    public static function mode(_x:Ref<Float_>):RoundingMode {
        _x;
        return _x._mode;
    }
    @:keep
    public static function minPrec(_x:Ref<Float_>):GoUInt {
        _x;
        if (_x._form != ((1 : GoUInt8))) {
            return ((0 : GoUInt));
        };
        return ((((_x._mant != null ? _x._mant.length : ((0 : GoInt))) : GoUInt)) * ((32 : GoUInt))) - _x._mant._trailingZeroBits();
    }
    @:keep
    public static function prec(_x:Ref<Float_>):GoUInt {
        _x;
        return ((_x._prec : GoUInt));
    }
    @:keep
    public static function setMode(_z:Ref<Float_>, _mode:RoundingMode):Float_ {
        _z;
        _z._mode = _mode;
        _z._acc = ((0 : GoInt8));
        return _z;
    }
    @:keep
    public static function setPrec(_z:Ref<Float_>, _prec:GoUInt):Float_ {
        _z;
        _z._acc = ((0 : GoInt8));
        if (_prec == ((0 : GoUInt))) {
            _z._prec = ((0 : GoUInt32));
            if (_z._form == ((1 : GoUInt8))) {
                _z._acc = _makeAcc(_z._neg);
                _z._form = ((0 : GoUInt8));
            };
            return _z;
        };
        if (_prec > (("4294967295" : GoUInt))) {
            _prec = (("4294967295" : GoUInt));
        };
        var _old:GoUInt32 = _z._prec;
        _z._prec = ((_prec : GoUInt32));
        if (_z._prec < _old) {
            _z._round(((0 : GoUInt)));
        };
        return _z;
    }
}
class ErrNaN_wrapper {
    @:keep
    public function error():GoString {
        var _err = __t__;
        (_err == null ? null : _err.__copy__());
        return _err._msg;
    }
    public var __t__ : ErrNaN;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class ErrNaN_static_extension {
    @:keep
    public static function error(_err:ErrNaN):GoString {
        (_err == null ? null : _err.__copy__());
        return _err._msg;
    }
}
class T_matrix_wrapper {
    @:keep
    public function toString():GoString {
        var _a = __t__;
        _a;
        var _s:GoString = ((("" : GoString)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _a._m, _j++, {
                        _s = _s + (stdgo.fmt.Fmt.sprintf(((("\t%s" : GoString))), Go.toInterface(_a._at(_i, _j))));
                    });
                };
                _s = _s + (((("\n" : GoString))));
            });
        };
        return _s;
    }
    @:keep
    public function _eql(_b:T_matrix):Bool {
        var _a = __t__;
        _a;
        if ((_a._n != _b._n) || (_a._m != _b._m)) {
            return false;
        };
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _a._m, _j++, {
                        if (_a._at(_i, _j).cmp(_b._at(_i, _j)) != ((0 : GoInt))) {
                            return false;
                        };
                    });
                };
            });
        };
        return true;
    }
    @:keep
    public function _mul(_b:T_matrix):T_matrix {
        var _a = __t__;
        _a;
        if (_a._m != _b._n) {
            throw Go.toInterface(((("illegal matrix multiply" : GoString))));
        };
        var _c:Ref<T_matrix> = _newMatrix(_a._n, _b._m);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _c._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _c._m, _j++, {
                        var _x:Ref<Rat> = newRat(((0 : GoInt64)), ((1 : GoInt64)));
                        {
                            var _k:GoInt = ((0 : GoInt));
                            Go.cfor(_k < _a._m, _k++, {
                                _x.add(_x, new Rat().mul(_a._at(_i, _k), _b._at(_k, _j)));
                            });
                        };
                        _c._set(_i, _j, _x);
                    });
                };
            });
        };
        return _c;
    }
    @:keep
    public function _set(_i:GoInt, _j:GoInt, _x:Rat):Void {
        var _a = __t__;
        _a;
        if (!((((((0 : GoInt)) <= _i) && (_i < _a._n)) && (((0 : GoInt)) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(((("index out of range" : GoString))));
        };
        if (_a._a != null) _a._a[(_i * _a._m) + _j] = _x;
    }
    @:keep
    public function _at(_i:GoInt, _j:GoInt):Rat {
        var _a = __t__;
        _a;
        if (!((((((0 : GoInt)) <= _i) && (_i < _a._n)) && (((0 : GoInt)) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(((("index out of range" : GoString))));
        };
        return (_a._a != null ? _a._a[(_i * _a._m) + _j] : ((null : Ref<Rat>)));
    }
    public var __t__ : T_matrix;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class T_matrix_static_extension {
    @:keep
    public static function toString(_a:Ref<T_matrix>):GoString {
        _a;
        var _s:GoString = ((("" : GoString)));
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _a._m, _j++, {
                        _s = _s + (stdgo.fmt.Fmt.sprintf(((("\t%s" : GoString))), Go.toInterface(_a._at(_i, _j))));
                    });
                };
                _s = _s + (((("\n" : GoString))));
            });
        };
        return _s;
    }
    @:keep
    public static function _eql(_a:Ref<T_matrix>, _b:T_matrix):Bool {
        _a;
        if ((_a._n != _b._n) || (_a._m != _b._m)) {
            return false;
        };
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _a._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _a._m, _j++, {
                        if (_a._at(_i, _j).cmp(_b._at(_i, _j)) != ((0 : GoInt))) {
                            return false;
                        };
                    });
                };
            });
        };
        return true;
    }
    @:keep
    public static function _mul(_a:Ref<T_matrix>, _b:T_matrix):T_matrix {
        _a;
        if (_a._m != _b._n) {
            throw Go.toInterface(((("illegal matrix multiply" : GoString))));
        };
        var _c:Ref<T_matrix> = _newMatrix(_a._n, _b._m);
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _c._n, _i++, {
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < _c._m, _j++, {
                        var _x:Ref<Rat> = newRat(((0 : GoInt64)), ((1 : GoInt64)));
                        {
                            var _k:GoInt = ((0 : GoInt));
                            Go.cfor(_k < _a._m, _k++, {
                                _x.add(_x, new Rat().mul(_a._at(_i, _k), _b._at(_k, _j)));
                            });
                        };
                        _c._set(_i, _j, _x);
                    });
                };
            });
        };
        return _c;
    }
    @:keep
    public static function _set(_a:Ref<T_matrix>, _i:GoInt, _j:GoInt, _x:Rat):Void {
        _a;
        if (!((((((0 : GoInt)) <= _i) && (_i < _a._n)) && (((0 : GoInt)) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(((("index out of range" : GoString))));
        };
        if (_a._a != null) _a._a[(_i * _a._m) + _j] = _x;
    }
    @:keep
    public static function _at(_a:Ref<T_matrix>, _i:GoInt, _j:GoInt):Rat {
        _a;
        if (!((((((0 : GoInt)) <= _i) && (_i < _a._n)) && (((0 : GoInt)) <= _j)) && (_j < _a._m))) {
            throw Go.toInterface(((("index out of range" : GoString))));
        };
        return (_a._a != null ? _a._a[(_i * _a._m) + _j] : ((null : Ref<Rat>)));
    }
}
class Int__wrapper {
    @:keep
    public function _scaleDenom(_x:Int_, _f:T_nat):Void {
        var _z = __t__;
        _z;
        if ((_f != null ? _f.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z.set(_x);
            return;
        };
        _z._abs = (_z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_f == null ? null : _f.__copy__())) == null ? null : _z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_f == null ? null : _f.__copy__())).__copy__());
        _z._neg = _x._neg;
    }
    @:keep
    public function probablyPrime(_n:GoInt):Bool {
        var _x = __t__;
        _x;
        if (_n < ((0 : GoInt))) {
            throw Go.toInterface(((("negative n for ProbablyPrime" : GoString))));
        };
        if (_x._neg || ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            return false;
        };
        {};
        var _w:Word = (_x._abs != null ? _x._abs[((0 : GoInt))] : new Word());
        if (((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((1 : GoInt))) && (_w < ((64 : GoUInt)))) {
            return ((("2891462833508853932" : GoUInt64)) & (((1 : GoUInt64)) << _w)) != ((0 : GoUInt64));
        };
        if ((_w & ((1 : GoUInt))) == ((0 : GoUInt))) {
            return false;
        };
        {};
        {};
        var _rA:GoUInt32 = ((0 : GoUInt32)), _rB:GoUInt32 = ((0 : GoUInt32));
        if (((32 : GoInt)) == ((32 : GoInt))) {
            _rA = ((_x._abs._modW((("4127218095" : GoUInt))) : GoUInt32));
            _rB = ((_x._abs._modW((("3948078067" : GoUInt))) : GoUInt32));
        } else if (((32 : GoInt)) == ((64 : GoInt))) {
            var _r:Word = _x._abs._modW(((820596253 : GoUInt)));
            _rA = (((_r % (("4127218095" : GoUInt))) : GoUInt32));
            _rB = (((_r % (("3948078067" : GoUInt))) : GoUInt32));
        } else {
            throw Go.toInterface(((("math/big: invalid word size" : GoString))));
        };
        if ((((((((((((((((_rA % ((3 : GoUInt32))) == ((0 : GoUInt32))) || ((_rA % ((5 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((7 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((11 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((13 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((17 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((19 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((23 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((37 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((29 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((31 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((41 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((43 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((47 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((53 : GoUInt32))) == ((0 : GoUInt32)))) {
            return false;
        };
        return _x._abs._probablyPrimeMillerRabin(_n + ((1 : GoInt)), true) && _x._abs._probablyPrimeLucas();
    }
    @:keep
    public function unmarshalJSON(_text:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        if (((_text : GoString)) == ((("null" : GoString)))) {
            return ((null : stdgo.Error));
        };
        return _z.unmarshalText(_text);
    }
    @:keep
    public function marshalJSON():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        return _x.marshalText();
    }
    @:keep
    public function unmarshalText(_text:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        {
            var __tmp__ = _z._setFromScanner(stdgo.bytes.Bytes.newReader(_text), ((0 : GoInt))), _0:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Int" : GoString))), Go.toInterface(_text));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x == null) {
            return { _0 : ((((("<nil>" : GoString))) : Slice<GoByte>)), _1 : ((null : stdgo.Error)) };
        };
        return { _0 : _x._abs._itoa(_x._neg, ((10 : GoInt))), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function gobDecode(_buf:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Int_() : Int_));
                _z._neg = __tmp__._neg;
                _z._abs = __tmp__._abs;
            };
            return ((null : stdgo.Error));
        };
        var _b:GoUInt8 = (_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)));
        if ((_b >> ((1 : GoUnTypedInt))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Int.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface(_b >> ((1 : GoUnTypedInt))));
        };
        _z._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._abs = (_z._abs._setBytes(((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>))) == null ? null : _z._abs._setBytes(((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>))).__copy__());
        return ((null : stdgo.Error));
    }
    @:keep
    public function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((1 : GoInt)) + ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) * ((4 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _i:GoInt = _x._abs._bytes(_buf) - ((1 : GoInt));
        var _b:GoUInt8 = ((2 : GoUInt8));
        if (_x._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[_i] = _b;
        return { _0 : ((_buf.__slice__(_i) : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var _z = __t__;
        _z;
        _s.skipSpace();
        var _base:GoInt = ((0 : GoInt));
        if (_ch == ((((("b" : GoString))).code : GoRune))) {
            _base = ((2 : GoInt));
        } else if (_ch == ((((("o" : GoString))).code : GoRune))) {
            _base = ((8 : GoInt));
        } else if (_ch == ((((("d" : GoString))).code : GoRune))) {
            _base = ((10 : GoInt));
        } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
            _base = ((16 : GoInt));
        } else if (_ch == ((((("s" : GoString))).code : GoRune)) || _ch == ((((("v" : GoString))).code : GoRune))) {} else {
            return stdgo.errors.Errors.new_(((("Int.Scan: invalid verb" : GoString))));
        };
        var __tmp__ = _z._scan(((new T_byteReader(_s) : T_byteReader)), _base), _0:Ref<Int_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        return _err;
    }
    @:keep
    public function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Int_; var _1 : GoInt; var _2 : Error; } {
        var _z = __t__;
        _z;
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : ((0 : GoInt)), _2 : _err };
        };
        {
            var __tmp__ = _z._abs._scan(_r, _base, false);
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _base = __tmp__._1;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : _base, _2 : _err };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return { _0 : _z, _1 : _base, _2 : ((null : stdgo.Error)) };
    }
    @:keep
    public function format(_s:stdgo.fmt.Fmt.State, _ch:GoRune):Void {
        var _x = __t__;
        _x;
        var _base:GoInt = ((0 : GoInt));
        if (_ch == ((((("b" : GoString))).code : GoRune))) {
            _base = ((2 : GoInt));
        } else if (_ch == ((((("o" : GoString))).code : GoRune)) || _ch == ((((("O" : GoString))).code : GoRune))) {
            _base = ((8 : GoInt));
        } else if (_ch == ((((("d" : GoString))).code : GoRune)) || _ch == ((((("s" : GoString))).code : GoRune)) || _ch == ((((("v" : GoString))).code : GoRune))) {
            _base = ((10 : GoInt));
        } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
            _base = ((16 : GoInt));
        } else {
            stdgo.fmt.Fmt.fprintf(_s, ((("%%!%c(big.Int=%s)" : GoString))), Go.toInterface(_ch), Go.toInterface(((_x.toString() : GoString))));
            return;
        };
        if (_x == null) {
            stdgo.fmt.Fmt.fprint(_s, ((("<nil>" : GoString))));
            return;
        };
        var _sign:GoString = ((("" : GoString)));
        if (_x._neg) {
            _sign = ((("-" : GoString)));
        } else if (_s.flag(((((("+" : GoString))).code : GoRune)))) {
            _sign = ((("+" : GoString)));
        } else if (_s.flag((((((" " : GoString))).code : GoRune)))) {
            _sign = (((" " : GoString)));
        };
        var _prefix:GoString = ((("" : GoString)));
        if (_s.flag(((((("#" : GoString))).code : GoRune)))) {
            if (_ch == ((((("b" : GoString))).code : GoRune))) {
                _prefix = ((("0b" : GoString)));
            } else if (_ch == ((((("o" : GoString))).code : GoRune))) {
                _prefix = ((("0" : GoString)));
            } else if (_ch == ((((("x" : GoString))).code : GoRune))) {
                _prefix = ((("0x" : GoString)));
            } else if (_ch == ((((("X" : GoString))).code : GoRune))) {
                _prefix = ((("0X" : GoString)));
            };
        };
        if (_ch == ((((("O" : GoString))).code : GoRune))) {
            _prefix = ((("0o" : GoString)));
        };
        var _digits:Slice<GoUInt8> = _x._abs._utoa(_base);
        if (_ch == ((((("X" : GoString))).code : GoRune))) {
            for (_i => _d in _digits) {
                if ((((((("a" : GoString))).code : GoRune)) <= _d) && (_d <= ((((("z" : GoString))).code : GoRune)))) {
                    if (_digits != null) _digits[_i] = ((((("A" : GoString))).code : GoRune)) + (_d - ((((("a" : GoString))).code : GoRune)));
                };
            };
        };
        var _left:GoInt = ((0 : GoInt));
        var _zeros:GoInt = ((0 : GoInt));
        var _right:GoInt = ((0 : GoInt));
        var __tmp__ = _s.precision(), _precision:GoInt = __tmp__._0, _precisionSet:Bool = __tmp__._1;
        if (_precisionSet) {
            if ((_digits != null ? _digits.length : ((0 : GoInt))) < _precision) {
                _zeros = _precision - (_digits != null ? _digits.length : ((0 : GoInt)));
            } else if ((((_digits != null ? _digits.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_digits != null ? _digits[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) && (_precision == ((0 : GoInt)))) {
                return;
            };
        };
        var _length:GoInt = (((_sign != null ? _sign.length : ((0 : GoInt))) + (_prefix != null ? _prefix.length : ((0 : GoInt)))) + _zeros) + (_digits != null ? _digits.length : ((0 : GoInt)));
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _widthSet:Bool = __tmp__._1;
            if (_widthSet && (_length < _width)) {
                {
                    var _d:GoInt = _width - _length;
                    if (_s.flag(((((("-" : GoString))).code : GoRune)))) {
                        _right = _d;
                    } else if (_s.flag(((((("0" : GoString))).code : GoRune))) && !_precisionSet) {
                        _zeros = _d;
                    } else {
                        _left = _d;
                    };
                };
            };
        };
        _writeMultiple(_s, (((" " : GoString))), _left);
        _writeMultiple(_s, _sign, ((1 : GoInt)));
        _writeMultiple(_s, _prefix, ((1 : GoInt)));
        _writeMultiple(_s, ((("0" : GoString))), _zeros);
        _s.write(_digits);
        _writeMultiple(_s, (((" " : GoString))), _right);
    }
    @:keep
    public function toString():GoString {
        var _x = __t__;
        _x;
        return _x.text(((10 : GoInt)));
    }
    @:keep
    public function append(_buf:Slice<GoByte>, _base:GoInt):Slice<GoByte> {
        var _x = __t__;
        _x;
        if (_x == null) {
            return (_buf != null ? _buf.__append__(...((("<nil>" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("<nil>" : GoString))).__toArray__()));
        };
        return (_buf != null ? _buf.__append__(..._x._abs._itoa(_x._neg, _base).__toArray__()) : new Slice<GoUInt8>(..._x._abs._itoa(_x._neg, _base).__toArray__()));
    }
    @:keep
    public function text(_base:GoInt):GoString {
        var _x = __t__;
        _x;
        if (_x == null) {
            return ((("<nil>" : GoString)));
        };
        return ((_x._abs._itoa(_x._neg, _base) : GoString));
    }
    @:keep
    public function sqrt(_x:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg) {
            throw Go.toInterface(((("square root of negative number" : GoString))));
        };
        _z._neg = false;
        _z._abs = (_z._abs._sqrt((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sqrt((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
        return _z;
    }
    @:keep
    public function not(_x:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg) {
            _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public function xor(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._xor((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
                _z._neg = false;
                return _z;
            };
            _z._abs = (_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._add((_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public function or(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._add((_z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._neg = true;
                return _z;
            };
            _z._abs = (_z._abs._or((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._add((_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public function andNot(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x1 == null ? null : _x1.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x1 == null ? null : _x1.__copy__())).__copy__());
                _z._neg = false;
                return _z;
            };
            _z._abs = (_z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._abs = (_z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = true;
            return _z;
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function and(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._neg = true;
                return _z;
            };
            _z._abs = (_z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function setBit(_x:Int_, _i:GoInt, _b:GoUInt):Int_ {
        var _z = __t__;
        _z;
        if (_i < ((0 : GoInt))) {
            throw Go.toInterface(((("negative bit index" : GoString))));
        };
        if (_x._neg) {
            var _t:T_nat = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _t = (_t._setBit((_t == null ? null : _t.__copy__()), ((_i : GoUInt)), _b ^ ((1 : GoUInt))) == null ? null : _t._setBit((_t == null ? null : _t.__copy__()), ((_i : GoUInt)), _b ^ ((1 : GoUInt))).__copy__());
            _z._abs = (_t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = (_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt));
            return _z;
        };
        _z._abs = (_z._abs._setBit((_x._abs == null ? null : _x._abs.__copy__()), ((_i : GoUInt)), _b) == null ? null : _z._abs._setBit((_x._abs == null ? null : _x._abs.__copy__()), ((_i : GoUInt)), _b).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function bit(_i:GoInt):GoUInt {
        var _x = __t__;
        _x;
        if (_i == ((0 : GoInt))) {
            if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
                return ((((_x._abs != null ? _x._abs[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) : GoUInt));
            };
            return ((0 : GoUInt));
        };
        if (_i < ((0 : GoInt))) {
            throw Go.toInterface(((("negative bit index" : GoString))));
        };
        if (_x._neg) {
            var _t:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            return _t._bit(((_i : GoUInt))) ^ ((1 : GoUInt));
        };
        return _x._abs._bit(((_i : GoUInt)));
    }
    @:keep
    public function rsh(_x:Int_, _n:GoUInt):Int_ {
        var _z = __t__;
        _z;
        if (_x._neg) {
            var _t:T_nat = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _t = (_t._shr((_t == null ? null : _t.__copy__()), _n) == null ? null : _t._shr((_t == null ? null : _t.__copy__()), _n).__copy__());
            _z._abs = (_t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = true;
            return _z;
        };
        _z._abs = (_z._abs._shr((_x._abs == null ? null : _x._abs.__copy__()), _n) == null ? null : _z._abs._shr((_x._abs == null ? null : _x._abs.__copy__()), _n).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function lsh(_x:Int_, _n:GoUInt):Int_ {
        var _z = __t__;
        _z;
        _z._abs = (_z._abs._shl((_x._abs == null ? null : _x._abs.__copy__()), _n) == null ? null : _z._abs._shl((_x._abs == null ? null : _x._abs.__copy__()), _n).__copy__());
        _z._neg = _x._neg;
        return _z;
    }
    @:keep
    public function modSqrt(_x:Int_, _p:Int_):Int_ {
        var _z = __t__;
        _z;
        {
            var __switchIndex__ = -1;
            while (true) {
                if (jacobi(_x, _p) == ((-1 : GoInt))) {
                    return null;
                    break;
                } else if (jacobi(_x, _p) == ((0 : GoInt))) {
                    return _z.setInt64(((0 : GoInt64)));
                    break;
                } else if (jacobi(_x, _p) == ((1 : GoInt))) {
                    break;
                    break;
                };
                break;
            };
        };
        if (_x._neg || (_x.cmp(_p) >= ((0 : GoInt)))) {
            _x = new Int_().mod(_x, _p);
        };
        if (((_p._abs != null ? _p._abs[((0 : GoInt))] : new Word()) % ((4 : GoUInt))) == ((3 : GoUInt))) {
            return _z._modSqrt3Mod4Prime(_x, _p);
        } else if (((_p._abs != null ? _p._abs[((0 : GoInt))] : new Word()) % ((8 : GoUInt))) == ((5 : GoUInt))) {
            return _z._modSqrt5Mod8Prime(_x, _p);
        } else {
            return _z._modSqrtTonelliShanks(_x, _p);
        };
    }
    @:keep
    public function _modSqrtTonelliShanks(_x:Int_, _p:Int_):Int_ {
        var _z = __t__;
        _z;
        var _s:Int_ = new Int_();
        _s.sub(_p, _intOne);
        var _e:GoUInt = _s._abs._trailingZeroBits();
        _s.rsh(_s, _e);
        var _n:Int_ = new Int_();
        _n.setInt64(((2 : GoInt64)));
        while (jacobi(_n, _p) != ((-1 : GoInt))) {
            _n.add(_n, _intOne);
        };
        var _y:Int_ = new Int_(), _b:Int_ = new Int_(), _g:Int_ = new Int_(), _t:Int_ = new Int_();
        _y.add(_s, _intOne);
        _y.rsh(_y, ((1 : GoUInt)));
        _y.exp(_x, _y, _p);
        _b.exp(_x, _s, _p);
        _g.exp(_n, _s, _p);
        var _r:GoUInt = _e;
        while (true) {
            var _m:GoUInt = ((0 : GoUInt));
            _t.set(_b);
            while (_t.cmp(_intOne) != ((0 : GoInt))) {
                _t.mul(_t, _t).mod(_t, _p);
                _m++;
            };
            if (_m == ((0 : GoUInt))) {
                return _z.set(_y);
            };
            _t.setInt64(((0 : GoInt64))).setBit(_t, ((((_r - _m) - ((1 : GoUInt))) : GoInt)), ((1 : GoUInt))).exp(_g, _t, _p);
            _g.mul(_t, _t).mod(_g, _p);
            _y.mul(_y, _t).mod(_y, _p);
            _b.mul(_b, _g).mod(_b, _p);
            _r = _m;
        };
    }
    @:keep
    public function _modSqrt5Mod8Prime(_x:Int_, _p:Int_):Int_ {
        var _z = __t__;
        _z;
        var _e:Ref<Int_> = new Int_().rsh(_p, ((3 : GoUInt)));
        var _tx:Ref<Int_> = new Int_().lsh(_x, ((1 : GoUInt)));
        var _alpha:Ref<Int_> = new Int_().exp(_tx, _e, _p);
        var _beta:Ref<Int_> = new Int_().mul(_alpha, _alpha);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _tx);
        _beta.mod(_beta, _p);
        _beta.sub(_beta, _intOne);
        _beta.mul(_beta, _x);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _alpha);
        _z.mod(_beta, _p);
        return _z;
    }
    @:keep
    public function _modSqrt3Mod4Prime(_x:Int_, _p:Int_):Int_ {
        var _z = __t__;
        _z;
        var _e:Ref<Int_> = new Int_().add(_p, _intOne);
        _e.rsh(_e, ((2 : GoUInt)));
        _z.exp(_x, _e, _p);
        return _z;
    }
    @:keep
    public function modInverse(_g:Int_, _n:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_n._neg) {
            var _n2:Int_ = new Int_();
            _n = _n2.neg(_n);
        };
        if (_g._neg) {
            var _g2:Int_ = new Int_();
            _g = _g2.mod(_g, _n);
        };
        var _d:Int_ = new Int_(), _x:Int_ = new Int_();
        _d.gcd(_x, null, _g, _n);
        if (_d.cmp(_intOne) != ((0 : GoInt))) {
            return null;
        };
        if (_x._neg) {
            _z.add(_x, _n);
        } else {
            _z.set(_x);
        };
        return _z;
    }
    @:keep
    public function rand(_rnd:stdgo.math.rand.Rand.Rand, _n:Int_):Int_ {
        var _z = __t__;
        _z;
        _z._neg = false;
        if (_n._neg || ((_n._abs != null ? _n._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            _z._abs = null;
            return _z;
        };
        _z._abs = (_z._abs._random(_rnd, (_n._abs == null ? null : _n._abs.__copy__()), _n._abs._bitLen()) == null ? null : _z._abs._random(_rnd, (_n._abs == null ? null : _n._abs.__copy__()), _n._abs._bitLen()).__copy__());
        return _z;
    }
    @:keep
    public function _lehmerGCD(_x:Int_, _y:Int_, _a:Int_, _b:Int_):Int_ {
        var _z = __t__;
        _z;
        var a:Int_ = ((null : Ref<Int_>)), b:Int_ = ((null : Ref<Int_>)), ua:Int_ = ((null : Ref<Int_>)), ub:Int_ = ((null : Ref<Int_>));
        a = new Int_().abs(_a);
        b = new Int_().abs(_b);
        var _extended:Bool = (_x != null) || (_y != null);
        if (_extended) {
            ua = new Int_().setInt64(((1 : GoInt64)));
            ub = new Int_();
        };
        var _q:Ref<Int_> = new Int_();
        var _r:Ref<Int_> = new Int_();
        var _s:Ref<Int_> = new Int_();
        var _t:Ref<Int_> = new Int_();
        if (a._abs._cmp((b._abs == null ? null : b._abs.__copy__())) < ((0 : GoInt))) {
            {
                final __tmp__0 = b;
                final __tmp__1 = a;
                a = __tmp__0;
                b = __tmp__1;
            };
            {
                final __tmp__0 = ua;
                final __tmp__1 = ub;
                ub = __tmp__0;
                ua = __tmp__1;
            };
        };
        while ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((1 : GoInt))) {
            var __tmp__ = _lehmerSimulate(a, b), _u0:Word = __tmp__._0, _u1:Word = __tmp__._1, _v0:Word = __tmp__._2, _v1:Word = __tmp__._3, _even:Bool = __tmp__._4;
            if (_v0 != ((0 : GoUInt))) {
                _lehmerUpdate(a,
b,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                if (_extended) {
                    _lehmerUpdate(ua,
ub,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                };
            } else {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
        };
        if ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
            if ((a._abs != null ? a._abs.length : ((0 : GoInt))) > ((1 : GoInt))) {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
            if ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
                var _aWord:Word = (a._abs != null ? a._abs[((0 : GoInt))] : new Word()), _bWord:Word = (b._abs != null ? b._abs[((0 : GoInt))] : new Word());
                if (_extended) {
                    var _ua:Word = new Word(), _ub:Word = new Word(), _va:Word = new Word(), _vb:Word = new Word();
                    {
                        final __tmp__0 = ((1 : GoUInt));
                        final __tmp__1 = ((0 : GoUInt));
                        _ua = __tmp__0;
                        _ub = __tmp__1;
                    };
                    {
                        final __tmp__0 = ((0 : GoUInt));
                        final __tmp__1 = ((1 : GoUInt));
                        _va = __tmp__0;
                        _vb = __tmp__1;
                    };
                    var _even:Bool = true;
                    while (_bWord != ((0 : GoUInt))) {
                        var _q:Word = _aWord / _bWord, _r:Word = _aWord % _bWord;
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _r;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                        {
                            final __tmp__0 = _ub;
                            final __tmp__1 = _ua + (_q * _ub);
                            _ua = __tmp__0;
                            _ub = __tmp__1;
                        };
                        {
                            final __tmp__0 = _vb;
                            final __tmp__1 = _va + (_q * _vb);
                            _va = __tmp__0;
                            _vb = __tmp__1;
                        };
                        _even = !_even;
                    };
                    _t._abs = (_t._abs._setWord(_ua) == null ? null : _t._abs._setWord(_ua).__copy__());
                    _s._abs = (_s._abs._setWord(_va) == null ? null : _s._abs._setWord(_va).__copy__());
                    _t._neg = !_even;
                    _s._neg = _even;
                    _t.mul(ua, _t);
                    _s.mul(ub, _s);
                    ua.add(_t, _s);
                } else {
                    while (_bWord != ((0 : GoUInt))) {
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _aWord % _bWord;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                    };
                };
                if (a._abs != null) a._abs[((0 : GoInt))] = _aWord;
            };
        };
        var _negA:Bool = _a._neg;
        if (_y != null) {
            if (_y == _b) {
                b.set(_b);
            } else {
                b = _b;
            };
            _y.mul(_a, ua);
            if (_negA) {
                _y._neg = !_y._neg;
            };
            _y.sub(a, _y);
            _y.div(_y, b);
        };
        if (_x != null) {
            {
                var __tmp__ = (ua == null ? null : ua.__copy__());
                _x._neg = __tmp__._neg;
                _x._abs = __tmp__._abs;
            };
            if (_negA) {
                _x._neg = !_x._neg;
            };
        };
        {
            var __tmp__ = (a == null ? null : a.__copy__());
            _z._neg = __tmp__._neg;
            _z._abs = __tmp__._abs;
        };
        return _z;
    }
    @:keep
    public function gcd(_x:Int_, _y:Int_, _a:Int_, _b:Int_):Int_ {
        var _z = __t__;
        _z;
        if (((_a._abs != null ? _a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || ((_b._abs != null ? _b._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            var _lenA:GoInt = (_a._abs != null ? _a._abs.length : ((0 : GoInt))), _lenB:GoInt = (_b._abs != null ? _b._abs.length : ((0 : GoInt))), _negA:Bool = _a._neg, _negB:Bool = _b._neg;
            if (_lenA == ((0 : GoInt))) {
                _z.set(_b);
            } else {
                _z.set(_a);
            };
            _z._neg = false;
            if (_x != null) {
                if (_lenA == ((0 : GoInt))) {
                    _x.setUint64(((0 : GoUInt64)));
                } else {
                    _x.setUint64(((1 : GoUInt64)));
                    _x._neg = _negA;
                };
            };
            if (_y != null) {
                if (_lenB == ((0 : GoInt))) {
                    _y.setUint64(((0 : GoUInt64)));
                } else {
                    _y.setUint64(((1 : GoUInt64)));
                    _y._neg = _negB;
                };
            };
            return _z;
        };
        return _z._lehmerGCD(_x, _y, _a, _b);
    }
    @:keep
    public function exp(_x:Int_, _y:Int_, _m:Int_):Int_ {
        var _z = __t__;
        _z;
        var _xWords:T_nat = (_x._abs == null ? null : _x._abs.__copy__());
        if (_y._neg) {
            if ((_m == null) || ((_m._abs != null ? _m._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                return _z.setInt64(((1 : GoInt64)));
            };
            var _inverse:Ref<Int_> = new Int_().modInverse(_x, _m);
            if (_inverse == null) {
                return null;
            };
            _xWords = (_inverse._abs == null ? null : _inverse._abs.__copy__());
        };
        var _yWords:T_nat = (_y._abs == null ? null : _y._abs.__copy__());
        var _mWords:T_nat = new T_nat();
        if (_m != null) {
            _mWords = (_m._abs == null ? null : _m._abs.__copy__());
        };
        _z._abs = (_z._abs._expNN((_xWords == null ? null : _xWords.__copy__()), (_yWords == null ? null : _yWords.__copy__()), (_mWords == null ? null : _mWords.__copy__())) == null ? null : _z._abs._expNN((_xWords == null ? null : _xWords.__copy__()), (_yWords == null ? null : _yWords.__copy__()), (_mWords == null ? null : _mWords.__copy__())).__copy__());
        _z._neg = ((((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg) && ((_yWords != null ? _yWords.length : ((0 : GoInt))) > ((0 : GoInt)))) && (((_yWords != null ? _yWords[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((1 : GoUInt)));
        if (_z._neg && ((_mWords != null ? _mWords.length : ((0 : GoInt))) > ((0 : GoInt)))) {
            _z._abs = (_z._abs._sub((_mWords == null ? null : _mWords.__copy__()), (_z._abs == null ? null : _z._abs.__copy__())) == null ? null : _z._abs._sub((_mWords == null ? null : _mWords.__copy__()), (_z._abs == null ? null : _z._abs.__copy__())).__copy__());
            _z._neg = false;
        };
        return _z;
    }
    @:keep
    public function trailingZeroBits():GoUInt {
        var _x = __t__;
        _x;
        return _x._abs._trailingZeroBits();
    }
    @:keep
    public function bitLen():GoInt {
        var _x = __t__;
        _x;
        return _x._abs._bitLen();
    }
    @:keep
    public function fillBytes(_buf:Slice<GoByte>):Slice<GoByte> {
        var _x = __t__;
        _x;
        for (_i => _ in _buf) {
            if (_buf != null) _buf[_i] = ((0 : GoUInt8));
        };
        _x._abs._bytes(_buf);
        return _buf;
    }
    @:keep
    public function bytes():Slice<GoByte> {
        var _x = __t__;
        _x;
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... (((_x._abs != null ? _x._abs.length : ((0 : GoInt))) * ((4 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        return ((_buf.__slice__(_x._abs._bytes(_buf)) : Slice<GoUInt8>));
    }
    @:keep
    public function setBytes(_buf:Slice<GoByte>):Int_ {
        var _z = __t__;
        _z;
        _z._abs = (_z._abs._setBytes(_buf) == null ? null : _z._abs._setBytes(_buf).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function _setFromScanner(_r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Int_; var _1 : Bool; } {
        var _z = __t__;
        _z;
        {
            var __tmp__ = _z._scan(_r, _base), _0:Ref<Int_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err != null) {
                return { _0 : null, _1 : false };
            };
        };
        {
            var __tmp__ = _r.readByte(), _2:GoUInt8 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != stdgo.io.Io.eof) {
                return { _0 : null, _1 : false };
            };
        };
        return { _0 : _z, _1 : true };
    }
    @:keep
    public function setString(_s:GoString, _base:GoInt):{ var _0 : Int_; var _1 : Bool; } {
        var _z = __t__;
        _z;
        return _z._setFromScanner(stdgo.strings.Strings.newReader(_s), _base);
    }
    @:keep
    public function isUint64():Bool {
        var _x = __t__;
        _x;
        return !_x._neg && ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) <= ((2 : GoInt)));
    }
    @:keep
    public function isInt64():Bool {
        var _x = __t__;
        _x;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) <= ((2 : GoInt))) {
            var _w:GoInt64 = ((_low64((_x._abs == null ? null : _x._abs.__copy__())) : GoInt64));
            return (_w >= ((0 : GoInt64))) || (_x._neg && (_w == -_w));
        };
        return false;
    }
    @:keep
    public function uint64():GoUInt64 {
        var _x = __t__;
        _x;
        return _low64((_x._abs == null ? null : _x._abs.__copy__()));
    }
    @:keep
    public function int64():GoInt64 {
        var _x = __t__;
        _x;
        var _v:GoInt64 = ((_low64((_x._abs == null ? null : _x._abs.__copy__())) : GoInt64));
        if (_x._neg) {
            _v = -_v;
        };
        return _v;
    }
    @:keep
    public function cmpAbs(_y:Int_):GoInt {
        var _x = __t__;
        _x;
        return _x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__()));
    }
    @:keep
    public function cmp(_y:Int_):GoInt {
        var _x = __t__;
        _x;
        var _r:GoInt = ((0 : GoInt));
        if (_x == _y) {} else if (_x._neg == _y._neg) {
            _r = _x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__()));
            if (_x._neg) {
                _r = -_r;
            };
        } else if (_x._neg) {
            _r = ((-1 : GoInt));
        } else {
            _r = ((1 : GoInt));
        };
        return _r;
    }
    @:keep
    public function divMod(_x:Int_, _y:Int_, _m:Int_):{ var _0 : Int_; var _1 : Int_; } {
        var _z = __t__;
        _z;
        var _y0:Ref<Int_> = _y;
        if ((_z == _y) || _alias((_z._abs == null ? null : _z._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()))) {
            _y0 = new Int_().set(_y);
        };
        _z.quoRem(_x, _y, _m);
        if (_m._neg) {
            if (_y0._neg) {
                _z.add(_z, _intOne);
                _m.sub(_m, _y0);
            } else {
                _z.sub(_z, _intOne);
                _m.add(_m, _y0);
            };
        };
        return { _0 : _z, _1 : _m };
    }
    @:keep
    public function mod(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        var _y0:Ref<Int_> = _y;
        if ((_z == _y) || _alias((_z._abs == null ? null : _z._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()))) {
            _y0 = new Int_().set(_y);
        };
        var _q:Int_ = new Int_();
        _q.quoRem(_x, _y, _z);
        if (_z._neg) {
            if (_y0._neg) {
                _z.sub(_z, _y0);
            } else {
                _z.add(_z, _y0);
            };
        };
        return _z;
    }
    @:keep
    public function div(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        var _y_neg:Bool = _y._neg;
        var _r:Int_ = new Int_();
        _z.quoRem(_x, _y, _r);
        if (_r._neg) {
            if (_y_neg) {
                _z.add(_z, _intOne);
            } else {
                _z.sub(_z, _intOne);
            };
        };
        return _z;
    }
    @:keep
    public function quoRem(_x:Int_, _y:Int_, _r:Int_):{ var _0 : Int_; var _1 : Int_; } {
        var _z = __t__;
        _z;
        {
            var __tmp__ = _z._abs._div((_r._abs == null ? null : _r._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r._abs = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        {
            final __tmp__0 = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
            final __tmp__1 = ((_r._abs != null ? _r._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg;
            _z._neg = __tmp__0;
            _r._neg = __tmp__1;
        };
        return { _0 : _z, _1 : _r };
    }
    @:keep
    public function rem(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        {
            var __tmp__ = ((new T_nat() : T_nat))._div((_z._abs == null ? null : _z._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg;
        return _z;
    }
    @:keep
    public function quo(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        {
            var __tmp__ = _z._abs._div(null, (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
        return _z;
    }
    @:keep
    public function binomial(_n:GoInt64, _k:GoInt64):Int_ {
        var _z = __t__;
        _z;
        if (((_n / ((2 : GoInt64))) < _k) && (_k <= _n)) {
            _k = _n - _k;
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a.mulRange((_n - _k) + ((1 : GoInt64)), _n);
        _b.mulRange(((1 : GoInt64)), _k);
        return _z.quo(_a, _b);
    }
    @:keep
    public function mulRange(_a:GoInt64, _b:GoInt64):Int_ {
        var _z = __t__;
        _z;
        if (_a > _b) {
            return _z.setInt64(((1 : GoInt64)));
        } else if ((_a <= ((0 : GoInt64))) && (_b >= ((0 : GoInt64)))) {
            return _z.setInt64(((0 : GoInt64)));
        };
        var _neg:Bool = false;
        if (_a < ((0 : GoInt64))) {
            _neg = ((_b - _a) & ((1 : GoInt64))) == ((0 : GoInt64));
            {
                final __tmp__0 = -_b;
                final __tmp__1 = -_a;
                _a = __tmp__0;
                _b = __tmp__1;
            };
        };
        _z._abs = (_z._abs._mulRange(((_a : GoUInt64)), ((_b : GoUInt64))) == null ? null : _z._abs._mulRange(((_a : GoUInt64)), ((_b : GoUInt64))).__copy__());
        _z._neg = _neg;
        return _z;
    }
    @:keep
    public function mul(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_x == _y) {
            _z._abs = (_z._abs._sqr((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sqr((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        _z._abs = (_z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
        return _z;
    }
    @:keep
    public function sub(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        var _neg:Bool = _x._neg;
        if (_x._neg != _y._neg) {
            _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        } else {
            if (_x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__())) >= ((0 : GoInt))) {
                _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            } else {
                _neg = !_neg;
                _z._abs = (_z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return _z;
    }
    @:keep
    public function add(_x:Int_, _y:Int_):Int_ {
        var _z = __t__;
        _z;
        var _neg:Bool = _x._neg;
        if (_x._neg == _y._neg) {
            _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        } else {
            if (_x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__())) >= ((0 : GoInt))) {
                _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            } else {
                _neg = !_neg;
                _z._abs = (_z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return _z;
    }
    @:keep
    public function neg(_x:Int_):Int_ {
        var _z = __t__;
        _z;
        _z.set(_x);
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && !_z._neg;
        return _z;
    }
    @:keep
    public function abs(_x:Int_):Int_ {
        var _z = __t__;
        _z;
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    @:keep
    public function setBits(_abs:Slice<Word>):Int_ {
        var _z = __t__;
        _z;
        _z._abs = (((_abs : T_nat))._norm() == null ? null : ((_abs : T_nat))._norm().__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function bits():Slice<Word> {
        var _x = __t__;
        _x;
        return _x._abs;
    }
    @:keep
    public function set(_x:Int_):Int_ {
        var _z = __t__;
        _z;
        if (_z != _x) {
            _z._abs = (_z._abs._set((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._set((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            _z._neg = _x._neg;
        };
        return _z;
    }
    @:keep
    public function setUint64(_x:GoUInt64):Int_ {
        var _z = __t__;
        _z;
        _z._abs = (_z._abs._setUint64(_x) == null ? null : _z._abs._setUint64(_x).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public function setInt64(_x:GoInt64):Int_ {
        var _z = __t__;
        _z;
        var _neg:Bool = false;
        if (_x < ((0 : GoInt64))) {
            _neg = true;
            _x = -_x;
        };
        _z._abs = (_z._abs._setUint64(((_x : GoUInt64))) == null ? null : _z._abs._setUint64(((_x : GoUInt64))).__copy__());
        _z._neg = _neg;
        return _z;
    }
    @:keep
    public function sign():GoInt {
        var _x = __t__;
        _x;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoInt));
        };
        if (_x._neg) {
            return ((-1 : GoInt));
        };
        return ((1 : GoInt));
    }
    public var __t__ : Int_;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class Int__static_extension {
    @:keep
    public static function _scaleDenom(_z:Ref<Int_>, _x:Int_, _f:T_nat):Void {
        _z;
        if ((_f != null ? _f.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z.set(_x);
            return;
        };
        _z._abs = (_z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_f == null ? null : _f.__copy__())) == null ? null : _z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_f == null ? null : _f.__copy__())).__copy__());
        _z._neg = _x._neg;
    }
    @:keep
    public static function probablyPrime(_x:Ref<Int_>, _n:GoInt):Bool {
        _x;
        if (_n < ((0 : GoInt))) {
            throw Go.toInterface(((("negative n for ProbablyPrime" : GoString))));
        };
        if (_x._neg || ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            return false;
        };
        {};
        var _w:Word = (_x._abs != null ? _x._abs[((0 : GoInt))] : new Word());
        if (((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((1 : GoInt))) && (_w < ((64 : GoUInt)))) {
            return ((("2891462833508853932" : GoUInt64)) & (((1 : GoUInt64)) << _w)) != ((0 : GoUInt64));
        };
        if ((_w & ((1 : GoUInt))) == ((0 : GoUInt))) {
            return false;
        };
        {};
        {};
        var _rA:GoUInt32 = ((0 : GoUInt32)), _rB:GoUInt32 = ((0 : GoUInt32));
        if (((32 : GoInt)) == ((32 : GoInt))) {
            _rA = ((_x._abs._modW((("4127218095" : GoUInt))) : GoUInt32));
            _rB = ((_x._abs._modW((("3948078067" : GoUInt))) : GoUInt32));
        } else if (((32 : GoInt)) == ((64 : GoInt))) {
            var _r:Word = _x._abs._modW(((820596253 : GoUInt)));
            _rA = (((_r % (("4127218095" : GoUInt))) : GoUInt32));
            _rB = (((_r % (("3948078067" : GoUInt))) : GoUInt32));
        } else {
            throw Go.toInterface(((("math/big: invalid word size" : GoString))));
        };
        if ((((((((((((((((_rA % ((3 : GoUInt32))) == ((0 : GoUInt32))) || ((_rA % ((5 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((7 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((11 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((13 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((17 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((19 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((23 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rA % ((37 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((29 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((31 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((41 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((43 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((47 : GoUInt32))) == ((0 : GoUInt32)))) || ((_rB % ((53 : GoUInt32))) == ((0 : GoUInt32)))) {
            return false;
        };
        return _x._abs._probablyPrimeMillerRabin(_n + ((1 : GoInt)), true) && _x._abs._probablyPrimeLucas();
    }
    @:keep
    public static function unmarshalJSON(_z:Ref<Int_>, _text:Slice<GoByte>):Error {
        _z;
        if (((_text : GoString)) == ((("null" : GoString)))) {
            return ((null : stdgo.Error));
        };
        return _z.unmarshalText(_text);
    }
    @:keep
    public static function marshalJSON(_x:Ref<Int_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        return _x.marshalText();
    }
    @:keep
    public static function unmarshalText(_z:Ref<Int_>, _text:Slice<GoByte>):Error {
        _z;
        {
            var __tmp__ = _z._setFromScanner(stdgo.bytes.Bytes.newReader(_text), ((0 : GoInt))), _0:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Int" : GoString))), Go.toInterface(_text));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public static function marshalText(_x:Ref<Int_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x == null) {
            return { _0 : ((((("<nil>" : GoString))) : Slice<GoByte>)), _1 : ((null : stdgo.Error)) };
        };
        return { _0 : _x._abs._itoa(_x._neg, ((10 : GoInt))), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function gobDecode(_z:Ref<Int_>, _buf:Slice<GoByte>):Error {
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Int_() : Int_));
                _z._neg = __tmp__._neg;
                _z._abs = __tmp__._abs;
            };
            return ((null : stdgo.Error));
        };
        var _b:GoUInt8 = (_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)));
        if ((_b >> ((1 : GoUnTypedInt))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Int.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface(_b >> ((1 : GoUnTypedInt))));
        };
        _z._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._abs = (_z._abs._setBytes(((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>))) == null ? null : _z._abs._setBytes(((_buf.__slice__(((1 : GoInt))) : Slice<GoUInt8>))).__copy__());
        return ((null : stdgo.Error));
    }
    @:keep
    public static function gobEncode(_x:Ref<Int_>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((1 : GoInt)) + ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) * ((4 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _i:GoInt = _x._abs._bytes(_buf) - ((1 : GoInt));
        var _b:GoUInt8 = ((2 : GoUInt8));
        if (_x._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[_i] = _b;
        return { _0 : ((_buf.__slice__(_i) : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function scan(_z:Ref<Int_>, _s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        _z;
        _s.skipSpace();
        var _base:GoInt = ((0 : GoInt));
        if (_ch == ((((("b" : GoString))).code : GoRune))) {
            _base = ((2 : GoInt));
        } else if (_ch == ((((("o" : GoString))).code : GoRune))) {
            _base = ((8 : GoInt));
        } else if (_ch == ((((("d" : GoString))).code : GoRune))) {
            _base = ((10 : GoInt));
        } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
            _base = ((16 : GoInt));
        } else if (_ch == ((((("s" : GoString))).code : GoRune)) || _ch == ((((("v" : GoString))).code : GoRune))) {} else {
            return stdgo.errors.Errors.new_(((("Int.Scan: invalid verb" : GoString))));
        };
        var __tmp__ = _z._scan(((new T_byteReader(_s) : T_byteReader)), _base), _0:Ref<Int_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        return _err;
    }
    @:keep
    public static function _scan(_z:Ref<Int_>, _r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Int_; var _1 : GoInt; var _2 : Error; } {
        _z;
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : ((0 : GoInt)), _2 : _err };
        };
        {
            var __tmp__ = _z._abs._scan(_r, _base, false);
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _base = __tmp__._1;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : _base, _2 : _err };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return { _0 : _z, _1 : _base, _2 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function format(_x:Ref<Int_>, _s:stdgo.fmt.Fmt.State, _ch:GoRune):Void {
        _x;
        var _base:GoInt = ((0 : GoInt));
        if (_ch == ((((("b" : GoString))).code : GoRune))) {
            _base = ((2 : GoInt));
        } else if (_ch == ((((("o" : GoString))).code : GoRune)) || _ch == ((((("O" : GoString))).code : GoRune))) {
            _base = ((8 : GoInt));
        } else if (_ch == ((((("d" : GoString))).code : GoRune)) || _ch == ((((("s" : GoString))).code : GoRune)) || _ch == ((((("v" : GoString))).code : GoRune))) {
            _base = ((10 : GoInt));
        } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
            _base = ((16 : GoInt));
        } else {
            stdgo.fmt.Fmt.fprintf(_s, ((("%%!%c(big.Int=%s)" : GoString))), Go.toInterface(_ch), Go.toInterface(((_x.toString() : GoString))));
            return;
        };
        if (_x == null) {
            stdgo.fmt.Fmt.fprint(_s, ((("<nil>" : GoString))));
            return;
        };
        var _sign:GoString = ((("" : GoString)));
        if (_x._neg) {
            _sign = ((("-" : GoString)));
        } else if (_s.flag(((((("+" : GoString))).code : GoRune)))) {
            _sign = ((("+" : GoString)));
        } else if (_s.flag((((((" " : GoString))).code : GoRune)))) {
            _sign = (((" " : GoString)));
        };
        var _prefix:GoString = ((("" : GoString)));
        if (_s.flag(((((("#" : GoString))).code : GoRune)))) {
            if (_ch == ((((("b" : GoString))).code : GoRune))) {
                _prefix = ((("0b" : GoString)));
            } else if (_ch == ((((("o" : GoString))).code : GoRune))) {
                _prefix = ((("0" : GoString)));
            } else if (_ch == ((((("x" : GoString))).code : GoRune))) {
                _prefix = ((("0x" : GoString)));
            } else if (_ch == ((((("X" : GoString))).code : GoRune))) {
                _prefix = ((("0X" : GoString)));
            };
        };
        if (_ch == ((((("O" : GoString))).code : GoRune))) {
            _prefix = ((("0o" : GoString)));
        };
        var _digits:Slice<GoUInt8> = _x._abs._utoa(_base);
        if (_ch == ((((("X" : GoString))).code : GoRune))) {
            for (_i => _d in _digits) {
                if ((((((("a" : GoString))).code : GoRune)) <= _d) && (_d <= ((((("z" : GoString))).code : GoRune)))) {
                    if (_digits != null) _digits[_i] = ((((("A" : GoString))).code : GoRune)) + (_d - ((((("a" : GoString))).code : GoRune)));
                };
            };
        };
        var _left:GoInt = ((0 : GoInt));
        var _zeros:GoInt = ((0 : GoInt));
        var _right:GoInt = ((0 : GoInt));
        var __tmp__ = _s.precision(), _precision:GoInt = __tmp__._0, _precisionSet:Bool = __tmp__._1;
        if (_precisionSet) {
            if ((_digits != null ? _digits.length : ((0 : GoInt))) < _precision) {
                _zeros = _precision - (_digits != null ? _digits.length : ((0 : GoInt)));
            } else if ((((_digits != null ? _digits.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_digits != null ? _digits[((0 : GoInt))] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune)))) && (_precision == ((0 : GoInt)))) {
                return;
            };
        };
        var _length:GoInt = (((_sign != null ? _sign.length : ((0 : GoInt))) + (_prefix != null ? _prefix.length : ((0 : GoInt)))) + _zeros) + (_digits != null ? _digits.length : ((0 : GoInt)));
        {
            var __tmp__ = _s.width(), _width:GoInt = __tmp__._0, _widthSet:Bool = __tmp__._1;
            if (_widthSet && (_length < _width)) {
                {
                    var _d:GoInt = _width - _length;
                    if (_s.flag(((((("-" : GoString))).code : GoRune)))) {
                        _right = _d;
                    } else if (_s.flag(((((("0" : GoString))).code : GoRune))) && !_precisionSet) {
                        _zeros = _d;
                    } else {
                        _left = _d;
                    };
                };
            };
        };
        _writeMultiple(_s, (((" " : GoString))), _left);
        _writeMultiple(_s, _sign, ((1 : GoInt)));
        _writeMultiple(_s, _prefix, ((1 : GoInt)));
        _writeMultiple(_s, ((("0" : GoString))), _zeros);
        _s.write(_digits);
        _writeMultiple(_s, (((" " : GoString))), _right);
    }
    @:keep
    public static function toString(_x:Ref<Int_>):GoString {
        _x;
        return _x.text(((10 : GoInt)));
    }
    @:keep
    public static function append(_x:Ref<Int_>, _buf:Slice<GoByte>, _base:GoInt):Slice<GoByte> {
        _x;
        if (_x == null) {
            return (_buf != null ? _buf.__append__(...((("<nil>" : GoString))).__toArray__()) : new Slice<GoUInt8>(...((("<nil>" : GoString))).__toArray__()));
        };
        return (_buf != null ? _buf.__append__(..._x._abs._itoa(_x._neg, _base).__toArray__()) : new Slice<GoUInt8>(..._x._abs._itoa(_x._neg, _base).__toArray__()));
    }
    @:keep
    public static function text(_x:Ref<Int_>, _base:GoInt):GoString {
        _x;
        if (_x == null) {
            return ((("<nil>" : GoString)));
        };
        return ((_x._abs._itoa(_x._neg, _base) : GoString));
    }
    @:keep
    public static function sqrt(_z:Ref<Int_>, _x:Int_):Int_ {
        _z;
        if (_x._neg) {
            throw Go.toInterface(((("square root of negative number" : GoString))));
        };
        _z._neg = false;
        _z._abs = (_z._abs._sqrt((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sqrt((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
        return _z;
    }
    @:keep
    public static function not(_z:Ref<Int_>, _x:Int_):Int_ {
        _z;
        if (_x._neg) {
            _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public static function xor(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._xor((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
                _z._neg = false;
                return _z;
            };
            _z._abs = (_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._add((_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._xor((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public static function or(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._add((_z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._neg = true;
                return _z;
            };
            _z._abs = (_z._abs._or((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._add((_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._neg = true;
        return _z;
    }
    @:keep
    public static function andNot(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x1 == null ? null : _x1.__copy__())) == null ? null : _z._abs._andNot((_y1 == null ? null : _y1.__copy__()), (_x1 == null ? null : _x1.__copy__())).__copy__());
                _z._neg = false;
                return _z;
            };
            _z._abs = (_z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._abs = (_z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = true;
            return _z;
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function and(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        if (_x._neg == _y._neg) {
            if (_x._neg) {
                var _x1:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._abs = (_z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._add((_z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._or((_x1 == null ? null : _x1.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _z._neg = true;
                return _z;
            };
            _z._abs = (_z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._and((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        if (_x._neg) {
            {
                final __tmp__0 = _y;
                final __tmp__1 = _x;
                _x = __tmp__0;
                _y = __tmp__1;
            };
        };
        var _y1:T_nat = (((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_y._abs == null ? null : _y._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        _z._abs = (_z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _z._abs._andNot((_x._abs == null ? null : _x._abs.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function setBit(_z:Ref<Int_>, _x:Int_, _i:GoInt, _b:GoUInt):Int_ {
        _z;
        if (_i < ((0 : GoInt))) {
            throw Go.toInterface(((("negative bit index" : GoString))));
        };
        if (_x._neg) {
            var _t:T_nat = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _t = (_t._setBit((_t == null ? null : _t.__copy__()), ((_i : GoUInt)), _b ^ ((1 : GoUInt))) == null ? null : _t._setBit((_t == null ? null : _t.__copy__()), ((_i : GoUInt)), _b ^ ((1 : GoUInt))).__copy__());
            _z._abs = (_t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = (_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt));
            return _z;
        };
        _z._abs = (_z._abs._setBit((_x._abs == null ? null : _x._abs.__copy__()), ((_i : GoUInt)), _b) == null ? null : _z._abs._setBit((_x._abs == null ? null : _x._abs.__copy__()), ((_i : GoUInt)), _b).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function bit(_x:Ref<Int_>, _i:GoInt):GoUInt {
        _x;
        if (_i == ((0 : GoInt))) {
            if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
                return ((((_x._abs != null ? _x._abs[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) : GoUInt));
            };
            return ((0 : GoUInt));
        };
        if (_i < ((0 : GoInt))) {
            throw Go.toInterface(((("negative bit index" : GoString))));
        };
        if (_x._neg) {
            var _t:T_nat = (((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            return _t._bit(((_i : GoUInt))) ^ ((1 : GoUInt));
        };
        return _x._abs._bit(((_i : GoUInt)));
    }
    @:keep
    public static function rsh(_z:Ref<Int_>, _x:Int_, _n:GoUInt):Int_ {
        _z;
        if (_x._neg) {
            var _t:T_nat = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _t = (_t._shr((_t == null ? null : _t.__copy__()), _n) == null ? null : _t._shr((_t == null ? null : _t.__copy__()), _n).__copy__());
            _z._abs = (_t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _t._add((_t == null ? null : _t.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            _z._neg = true;
            return _z;
        };
        _z._abs = (_z._abs._shr((_x._abs == null ? null : _x._abs.__copy__()), _n) == null ? null : _z._abs._shr((_x._abs == null ? null : _x._abs.__copy__()), _n).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function lsh(_z:Ref<Int_>, _x:Int_, _n:GoUInt):Int_ {
        _z;
        _z._abs = (_z._abs._shl((_x._abs == null ? null : _x._abs.__copy__()), _n) == null ? null : _z._abs._shl((_x._abs == null ? null : _x._abs.__copy__()), _n).__copy__());
        _z._neg = _x._neg;
        return _z;
    }
    @:keep
    public static function modSqrt(_z:Ref<Int_>, _x:Int_, _p:Int_):Int_ {
        _z;
        {
            var __switchIndex__ = -1;
            while (true) {
                if (jacobi(_x, _p) == ((-1 : GoInt))) {
                    return null;
                    break;
                } else if (jacobi(_x, _p) == ((0 : GoInt))) {
                    return _z.setInt64(((0 : GoInt64)));
                    break;
                } else if (jacobi(_x, _p) == ((1 : GoInt))) {
                    break;
                    break;
                };
                break;
            };
        };
        if (_x._neg || (_x.cmp(_p) >= ((0 : GoInt)))) {
            _x = new Int_().mod(_x, _p);
        };
        if (((_p._abs != null ? _p._abs[((0 : GoInt))] : new Word()) % ((4 : GoUInt))) == ((3 : GoUInt))) {
            return _z._modSqrt3Mod4Prime(_x, _p);
        } else if (((_p._abs != null ? _p._abs[((0 : GoInt))] : new Word()) % ((8 : GoUInt))) == ((5 : GoUInt))) {
            return _z._modSqrt5Mod8Prime(_x, _p);
        } else {
            return _z._modSqrtTonelliShanks(_x, _p);
        };
    }
    @:keep
    public static function _modSqrtTonelliShanks(_z:Ref<Int_>, _x:Int_, _p:Int_):Int_ {
        _z;
        var _s:Int_ = new Int_();
        _s.sub(_p, _intOne);
        var _e:GoUInt = _s._abs._trailingZeroBits();
        _s.rsh(_s, _e);
        var _n:Int_ = new Int_();
        _n.setInt64(((2 : GoInt64)));
        while (jacobi(_n, _p) != ((-1 : GoInt))) {
            _n.add(_n, _intOne);
        };
        var _y:Int_ = new Int_(), _b:Int_ = new Int_(), _g:Int_ = new Int_(), _t:Int_ = new Int_();
        _y.add(_s, _intOne);
        _y.rsh(_y, ((1 : GoUInt)));
        _y.exp(_x, _y, _p);
        _b.exp(_x, _s, _p);
        _g.exp(_n, _s, _p);
        var _r:GoUInt = _e;
        while (true) {
            var _m:GoUInt = ((0 : GoUInt));
            _t.set(_b);
            while (_t.cmp(_intOne) != ((0 : GoInt))) {
                _t.mul(_t, _t).mod(_t, _p);
                _m++;
            };
            if (_m == ((0 : GoUInt))) {
                return _z.set(_y);
            };
            _t.setInt64(((0 : GoInt64))).setBit(_t, ((((_r - _m) - ((1 : GoUInt))) : GoInt)), ((1 : GoUInt))).exp(_g, _t, _p);
            _g.mul(_t, _t).mod(_g, _p);
            _y.mul(_y, _t).mod(_y, _p);
            _b.mul(_b, _g).mod(_b, _p);
            _r = _m;
        };
    }
    @:keep
    public static function _modSqrt5Mod8Prime(_z:Ref<Int_>, _x:Int_, _p:Int_):Int_ {
        _z;
        var _e:Ref<Int_> = new Int_().rsh(_p, ((3 : GoUInt)));
        var _tx:Ref<Int_> = new Int_().lsh(_x, ((1 : GoUInt)));
        var _alpha:Ref<Int_> = new Int_().exp(_tx, _e, _p);
        var _beta:Ref<Int_> = new Int_().mul(_alpha, _alpha);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _tx);
        _beta.mod(_beta, _p);
        _beta.sub(_beta, _intOne);
        _beta.mul(_beta, _x);
        _beta.mod(_beta, _p);
        _beta.mul(_beta, _alpha);
        _z.mod(_beta, _p);
        return _z;
    }
    @:keep
    public static function _modSqrt3Mod4Prime(_z:Ref<Int_>, _x:Int_, _p:Int_):Int_ {
        _z;
        var _e:Ref<Int_> = new Int_().add(_p, _intOne);
        _e.rsh(_e, ((2 : GoUInt)));
        _z.exp(_x, _e, _p);
        return _z;
    }
    @:keep
    public static function modInverse(_z:Ref<Int_>, _g:Int_, _n:Int_):Int_ {
        _z;
        if (_n._neg) {
            var _n2:Int_ = new Int_();
            _n = _n2.neg(_n);
        };
        if (_g._neg) {
            var _g2:Int_ = new Int_();
            _g = _g2.mod(_g, _n);
        };
        var _d:Int_ = new Int_(), _x:Int_ = new Int_();
        _d.gcd(_x, null, _g, _n);
        if (_d.cmp(_intOne) != ((0 : GoInt))) {
            return null;
        };
        if (_x._neg) {
            _z.add(_x, _n);
        } else {
            _z.set(_x);
        };
        return _z;
    }
    @:keep
    public static function rand(_z:Ref<Int_>, _rnd:stdgo.math.rand.Rand.Rand, _n:Int_):Int_ {
        _z;
        _z._neg = false;
        if (_n._neg || ((_n._abs != null ? _n._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            _z._abs = null;
            return _z;
        };
        _z._abs = (_z._abs._random(_rnd, (_n._abs == null ? null : _n._abs.__copy__()), _n._abs._bitLen()) == null ? null : _z._abs._random(_rnd, (_n._abs == null ? null : _n._abs.__copy__()), _n._abs._bitLen()).__copy__());
        return _z;
    }
    @:keep
    public static function _lehmerGCD(_z:Ref<Int_>, _x:Int_, _y:Int_, _a:Int_, _b:Int_):Int_ {
        _z;
        var a:Int_ = ((null : Ref<Int_>)), b:Int_ = ((null : Ref<Int_>)), ua:Int_ = ((null : Ref<Int_>)), ub:Int_ = ((null : Ref<Int_>));
        a = new Int_().abs(_a);
        b = new Int_().abs(_b);
        var _extended:Bool = (_x != null) || (_y != null);
        if (_extended) {
            ua = new Int_().setInt64(((1 : GoInt64)));
            ub = new Int_();
        };
        var _q:Ref<Int_> = new Int_();
        var _r:Ref<Int_> = new Int_();
        var _s:Ref<Int_> = new Int_();
        var _t:Ref<Int_> = new Int_();
        if (a._abs._cmp((b._abs == null ? null : b._abs.__copy__())) < ((0 : GoInt))) {
            {
                final __tmp__0 = b;
                final __tmp__1 = a;
                a = __tmp__0;
                b = __tmp__1;
            };
            {
                final __tmp__0 = ua;
                final __tmp__1 = ub;
                ub = __tmp__0;
                ua = __tmp__1;
            };
        };
        while ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((1 : GoInt))) {
            var __tmp__ = _lehmerSimulate(a, b), _u0:Word = __tmp__._0, _u1:Word = __tmp__._1, _v0:Word = __tmp__._2, _v1:Word = __tmp__._3, _even:Bool = __tmp__._4;
            if (_v0 != ((0 : GoUInt))) {
                _lehmerUpdate(a,
b,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                if (_extended) {
                    _lehmerUpdate(ua,
ub,
_q,
_r,
_s,
_t,
_u0,
_u1,
_v0,
_v1,
_even);
                };
            } else {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
        };
        if ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
            if ((a._abs != null ? a._abs.length : ((0 : GoInt))) > ((1 : GoInt))) {
                _euclidUpdate(a, b, ua, ub, _q, _r, _s, _t, _extended);
            };
            if ((b._abs != null ? b._abs.length : ((0 : GoInt))) > ((0 : GoInt))) {
                var _aWord:Word = (a._abs != null ? a._abs[((0 : GoInt))] : new Word()), _bWord:Word = (b._abs != null ? b._abs[((0 : GoInt))] : new Word());
                if (_extended) {
                    var _ua:Word = new Word(), _ub:Word = new Word(), _va:Word = new Word(), _vb:Word = new Word();
                    {
                        final __tmp__0 = ((1 : GoUInt));
                        final __tmp__1 = ((0 : GoUInt));
                        _ua = __tmp__0;
                        _ub = __tmp__1;
                    };
                    {
                        final __tmp__0 = ((0 : GoUInt));
                        final __tmp__1 = ((1 : GoUInt));
                        _va = __tmp__0;
                        _vb = __tmp__1;
                    };
                    var _even:Bool = true;
                    while (_bWord != ((0 : GoUInt))) {
                        var _q:Word = _aWord / _bWord, _r:Word = _aWord % _bWord;
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _r;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                        {
                            final __tmp__0 = _ub;
                            final __tmp__1 = _ua + (_q * _ub);
                            _ua = __tmp__0;
                            _ub = __tmp__1;
                        };
                        {
                            final __tmp__0 = _vb;
                            final __tmp__1 = _va + (_q * _vb);
                            _va = __tmp__0;
                            _vb = __tmp__1;
                        };
                        _even = !_even;
                    };
                    _t._abs = (_t._abs._setWord(_ua) == null ? null : _t._abs._setWord(_ua).__copy__());
                    _s._abs = (_s._abs._setWord(_va) == null ? null : _s._abs._setWord(_va).__copy__());
                    _t._neg = !_even;
                    _s._neg = _even;
                    _t.mul(ua, _t);
                    _s.mul(ub, _s);
                    ua.add(_t, _s);
                } else {
                    while (_bWord != ((0 : GoUInt))) {
                        {
                            final __tmp__0 = _bWord;
                            final __tmp__1 = _aWord % _bWord;
                            _aWord = __tmp__0;
                            _bWord = __tmp__1;
                        };
                    };
                };
                if (a._abs != null) a._abs[((0 : GoInt))] = _aWord;
            };
        };
        var _negA:Bool = _a._neg;
        if (_y != null) {
            if (_y == _b) {
                b.set(_b);
            } else {
                b = _b;
            };
            _y.mul(_a, ua);
            if (_negA) {
                _y._neg = !_y._neg;
            };
            _y.sub(a, _y);
            _y.div(_y, b);
        };
        if (_x != null) {
            {
                var __tmp__ = (ua == null ? null : ua.__copy__());
                _x._neg = __tmp__._neg;
                _x._abs = __tmp__._abs;
            };
            if (_negA) {
                _x._neg = !_x._neg;
            };
        };
        {
            var __tmp__ = (a == null ? null : a.__copy__());
            _z._neg = __tmp__._neg;
            _z._abs = __tmp__._abs;
        };
        return _z;
    }
    @:keep
    public static function gcd(_z:Ref<Int_>, _x:Int_, _y:Int_, _a:Int_, _b:Int_):Int_ {
        _z;
        if (((_a._abs != null ? _a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || ((_b._abs != null ? _b._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
            var _lenA:GoInt = (_a._abs != null ? _a._abs.length : ((0 : GoInt))), _lenB:GoInt = (_b._abs != null ? _b._abs.length : ((0 : GoInt))), _negA:Bool = _a._neg, _negB:Bool = _b._neg;
            if (_lenA == ((0 : GoInt))) {
                _z.set(_b);
            } else {
                _z.set(_a);
            };
            _z._neg = false;
            if (_x != null) {
                if (_lenA == ((0 : GoInt))) {
                    _x.setUint64(((0 : GoUInt64)));
                } else {
                    _x.setUint64(((1 : GoUInt64)));
                    _x._neg = _negA;
                };
            };
            if (_y != null) {
                if (_lenB == ((0 : GoInt))) {
                    _y.setUint64(((0 : GoUInt64)));
                } else {
                    _y.setUint64(((1 : GoUInt64)));
                    _y._neg = _negB;
                };
            };
            return _z;
        };
        return _z._lehmerGCD(_x, _y, _a, _b);
    }
    @:keep
    public static function exp(_z:Ref<Int_>, _x:Int_, _y:Int_, _m:Int_):Int_ {
        _z;
        var _xWords:T_nat = (_x._abs == null ? null : _x._abs.__copy__());
        if (_y._neg) {
            if ((_m == null) || ((_m._abs != null ? _m._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                return _z.setInt64(((1 : GoInt64)));
            };
            var _inverse:Ref<Int_> = new Int_().modInverse(_x, _m);
            if (_inverse == null) {
                return null;
            };
            _xWords = (_inverse._abs == null ? null : _inverse._abs.__copy__());
        };
        var _yWords:T_nat = (_y._abs == null ? null : _y._abs.__copy__());
        var _mWords:T_nat = new T_nat();
        if (_m != null) {
            _mWords = (_m._abs == null ? null : _m._abs.__copy__());
        };
        _z._abs = (_z._abs._expNN((_xWords == null ? null : _xWords.__copy__()), (_yWords == null ? null : _yWords.__copy__()), (_mWords == null ? null : _mWords.__copy__())) == null ? null : _z._abs._expNN((_xWords == null ? null : _xWords.__copy__()), (_yWords == null ? null : _yWords.__copy__()), (_mWords == null ? null : _mWords.__copy__())).__copy__());
        _z._neg = ((((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg) && ((_yWords != null ? _yWords.length : ((0 : GoInt))) > ((0 : GoInt)))) && (((_yWords != null ? _yWords[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((1 : GoUInt)));
        if (_z._neg && ((_mWords != null ? _mWords.length : ((0 : GoInt))) > ((0 : GoInt)))) {
            _z._abs = (_z._abs._sub((_mWords == null ? null : _mWords.__copy__()), (_z._abs == null ? null : _z._abs.__copy__())) == null ? null : _z._abs._sub((_mWords == null ? null : _mWords.__copy__()), (_z._abs == null ? null : _z._abs.__copy__())).__copy__());
            _z._neg = false;
        };
        return _z;
    }
    @:keep
    public static function trailingZeroBits(_x:Ref<Int_>):GoUInt {
        _x;
        return _x._abs._trailingZeroBits();
    }
    @:keep
    public static function bitLen(_x:Ref<Int_>):GoInt {
        _x;
        return _x._abs._bitLen();
    }
    @:keep
    public static function fillBytes(_x:Ref<Int_>, _buf:Slice<GoByte>):Slice<GoByte> {
        _x;
        for (_i => _ in _buf) {
            if (_buf != null) _buf[_i] = ((0 : GoUInt8));
        };
        _x._abs._bytes(_buf);
        return _buf;
    }
    @:keep
    public static function bytes(_x:Ref<Int_>):Slice<GoByte> {
        _x;
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... (((_x._abs != null ? _x._abs.length : ((0 : GoInt))) * ((4 : GoInt)) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        return ((_buf.__slice__(_x._abs._bytes(_buf)) : Slice<GoUInt8>));
    }
    @:keep
    public static function setBytes(_z:Ref<Int_>, _buf:Slice<GoByte>):Int_ {
        _z;
        _z._abs = (_z._abs._setBytes(_buf) == null ? null : _z._abs._setBytes(_buf).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function _setFromScanner(_z:Ref<Int_>, _r:stdgo.io.Io.ByteScanner, _base:GoInt):{ var _0 : Int_; var _1 : Bool; } {
        _z;
        {
            var __tmp__ = _z._scan(_r, _base), _0:Ref<Int_> = __tmp__._0, _1:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
            if (_err != null) {
                return { _0 : null, _1 : false };
            };
        };
        {
            var __tmp__ = _r.readByte(), _2:GoUInt8 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
            if (_err != stdgo.io.Io.eof) {
                return { _0 : null, _1 : false };
            };
        };
        return { _0 : _z, _1 : true };
    }
    @:keep
    public static function setString(_z:Ref<Int_>, _s:GoString, _base:GoInt):{ var _0 : Int_; var _1 : Bool; } {
        _z;
        return _z._setFromScanner(stdgo.strings.Strings.newReader(_s), _base);
    }
    @:keep
    public static function isUint64(_x:Ref<Int_>):Bool {
        _x;
        return !_x._neg && ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) <= ((2 : GoInt)));
    }
    @:keep
    public static function isInt64(_x:Ref<Int_>):Bool {
        _x;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) <= ((2 : GoInt))) {
            var _w:GoInt64 = ((_low64((_x._abs == null ? null : _x._abs.__copy__())) : GoInt64));
            return (_w >= ((0 : GoInt64))) || (_x._neg && (_w == -_w));
        };
        return false;
    }
    @:keep
    public static function uint64(_x:Ref<Int_>):GoUInt64 {
        _x;
        return _low64((_x._abs == null ? null : _x._abs.__copy__()));
    }
    @:keep
    public static function int64(_x:Ref<Int_>):GoInt64 {
        _x;
        var _v:GoInt64 = ((_low64((_x._abs == null ? null : _x._abs.__copy__())) : GoInt64));
        if (_x._neg) {
            _v = -_v;
        };
        return _v;
    }
    @:keep
    public static function cmpAbs(_x:Ref<Int_>, _y:Int_):GoInt {
        _x;
        return _x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__()));
    }
    @:keep
    public static function cmp(_x:Ref<Int_>, _y:Int_):GoInt {
        _x;
        var _r:GoInt = ((0 : GoInt));
        if (_x == _y) {} else if (_x._neg == _y._neg) {
            _r = _x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__()));
            if (_x._neg) {
                _r = -_r;
            };
        } else if (_x._neg) {
            _r = ((-1 : GoInt));
        } else {
            _r = ((1 : GoInt));
        };
        return _r;
    }
    @:keep
    public static function divMod(_z:Ref<Int_>, _x:Int_, _y:Int_, _m:Int_):{ var _0 : Int_; var _1 : Int_; } {
        _z;
        var _y0:Ref<Int_> = _y;
        if ((_z == _y) || _alias((_z._abs == null ? null : _z._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()))) {
            _y0 = new Int_().set(_y);
        };
        _z.quoRem(_x, _y, _m);
        if (_m._neg) {
            if (_y0._neg) {
                _z.add(_z, _intOne);
                _m.sub(_m, _y0);
            } else {
                _z.sub(_z, _intOne);
                _m.add(_m, _y0);
            };
        };
        return { _0 : _z, _1 : _m };
    }
    @:keep
    public static function mod(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        var _y0:Ref<Int_> = _y;
        if ((_z == _y) || _alias((_z._abs == null ? null : _z._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()))) {
            _y0 = new Int_().set(_y);
        };
        var _q:Int_ = new Int_();
        _q.quoRem(_x, _y, _z);
        if (_z._neg) {
            if (_y0._neg) {
                _z.sub(_z, _y0);
            } else {
                _z.add(_z, _y0);
            };
        };
        return _z;
    }
    @:keep
    public static function div(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        var _y_neg:Bool = _y._neg;
        var _r:Int_ = new Int_();
        _z.quoRem(_x, _y, _r);
        if (_r._neg) {
            if (_y_neg) {
                _z.add(_z, _intOne);
            } else {
                _z.sub(_z, _intOne);
            };
        };
        return _z;
    }
    @:keep
    public static function quoRem(_z:Ref<Int_>, _x:Int_, _y:Int_, _r:Int_):{ var _0 : Int_; var _1 : Int_; } {
        _z;
        {
            var __tmp__ = _z._abs._div((_r._abs == null ? null : _r._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r._abs = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        {
            final __tmp__0 = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
            final __tmp__1 = ((_r._abs != null ? _r._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg;
            _z._neg = __tmp__0;
            _r._neg = __tmp__1;
        };
        return { _0 : _z, _1 : _r };
    }
    @:keep
    public static function rem(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        {
            var __tmp__ = ((new T_nat() : T_nat))._div((_z._abs == null ? null : _z._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _x._neg;
        return _z;
    }
    @:keep
    public static function quo(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        {
            var __tmp__ = _z._abs._div(null, (_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__()));
            _z._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
        return _z;
    }
    @:keep
    public static function binomial(_z:Ref<Int_>, _n:GoInt64, _k:GoInt64):Int_ {
        _z;
        if (((_n / ((2 : GoInt64))) < _k) && (_k <= _n)) {
            _k = _n - _k;
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a.mulRange((_n - _k) + ((1 : GoInt64)), _n);
        _b.mulRange(((1 : GoInt64)), _k);
        return _z.quo(_a, _b);
    }
    @:keep
    public static function mulRange(_z:Ref<Int_>, _a:GoInt64, _b:GoInt64):Int_ {
        _z;
        if (_a > _b) {
            return _z.setInt64(((1 : GoInt64)));
        } else if ((_a <= ((0 : GoInt64))) && (_b >= ((0 : GoInt64)))) {
            return _z.setInt64(((0 : GoInt64)));
        };
        var _neg:Bool = false;
        if (_a < ((0 : GoInt64))) {
            _neg = ((_b - _a) & ((1 : GoInt64))) == ((0 : GoInt64));
            {
                final __tmp__0 = -_b;
                final __tmp__1 = -_a;
                _a = __tmp__0;
                _b = __tmp__1;
            };
        };
        _z._abs = (_z._abs._mulRange(((_a : GoUInt64)), ((_b : GoUInt64))) == null ? null : _z._abs._mulRange(((_a : GoUInt64)), ((_b : GoUInt64))).__copy__());
        _z._neg = _neg;
        return _z;
    }
    @:keep
    public static function mul(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        if (_x == _y) {
            _z._abs = (_z._abs._sqr((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sqr((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            _z._neg = false;
            return _z;
        };
        _z._abs = (_z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._mul((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && (_x._neg != _y._neg);
        return _z;
    }
    @:keep
    public static function sub(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        var _neg:Bool = _x._neg;
        if (_x._neg != _y._neg) {
            _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        } else {
            if (_x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__())) >= ((0 : GoInt))) {
                _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            } else {
                _neg = !_neg;
                _z._abs = (_z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return _z;
    }
    @:keep
    public static function add(_z:Ref<Int_>, _x:Int_, _y:Int_):Int_ {
        _z;
        var _neg:Bool = _x._neg;
        if (_x._neg == _y._neg) {
            _z._abs = (_z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._add((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
        } else {
            if (_x._abs._cmp((_y._abs == null ? null : _y._abs.__copy__())) >= ((0 : GoInt))) {
                _z._abs = (_z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())) == null ? null : _z._abs._sub((_x._abs == null ? null : _x._abs.__copy__()), (_y._abs == null ? null : _y._abs.__copy__())).__copy__());
            } else {
                _neg = !_neg;
                _z._abs = (_z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._sub((_y._abs == null ? null : _y._abs.__copy__()), (_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            };
        };
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && _neg;
        return _z;
    }
    @:keep
    public static function neg(_z:Ref<Int_>, _x:Int_):Int_ {
        _z;
        _z.set(_x);
        _z._neg = ((_z._abs != null ? _z._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && !_z._neg;
        return _z;
    }
    @:keep
    public static function abs(_z:Ref<Int_>, _x:Int_):Int_ {
        _z;
        _z.set(_x);
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function setBits(_z:Ref<Int_>, _abs:Slice<Word>):Int_ {
        _z;
        _z._abs = (((_abs : T_nat))._norm() == null ? null : ((_abs : T_nat))._norm().__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function bits(_x:Ref<Int_>):Slice<Word> {
        _x;
        return _x._abs;
    }
    @:keep
    public static function set(_z:Ref<Int_>, _x:Int_):Int_ {
        _z;
        if (_z != _x) {
            _z._abs = (_z._abs._set((_x._abs == null ? null : _x._abs.__copy__())) == null ? null : _z._abs._set((_x._abs == null ? null : _x._abs.__copy__())).__copy__());
            _z._neg = _x._neg;
        };
        return _z;
    }
    @:keep
    public static function setUint64(_z:Ref<Int_>, _x:GoUInt64):Int_ {
        _z;
        _z._abs = (_z._abs._setUint64(_x) == null ? null : _z._abs._setUint64(_x).__copy__());
        _z._neg = false;
        return _z;
    }
    @:keep
    public static function setInt64(_z:Ref<Int_>, _x:GoInt64):Int_ {
        _z;
        var _neg:Bool = false;
        if (_x < ((0 : GoInt64))) {
            _neg = true;
            _x = -_x;
        };
        _z._abs = (_z._abs._setUint64(((_x : GoUInt64))) == null ? null : _z._abs._setUint64(((_x : GoUInt64))).__copy__());
        _z._neg = _neg;
        return _z;
    }
    @:keep
    public static function sign(_x:Ref<Int_>):GoInt {
        _x;
        if ((_x._abs != null ? _x._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoInt));
        };
        if (_x._neg) {
            return ((-1 : GoInt));
        };
        return ((1 : GoInt));
    }
}
class T_argZZ_wrapper {
    public var __t__ : T_argZZ;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_intShiftTest_wrapper {
    public var __t__ : T_intShiftTest;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_byteReader_wrapper {
    @:keep
    public function unreadByte():Error {
        var _r = __t__;
        (_r == null ? null : _r.__copy__());
        return _r.unreadRune();
    }
    @:keep
    public function readByte():{ var _0 : GoByte; var _1 : Error; } {
        var _r = __t__;
        (_r == null ? null : _r.__copy__());
        var __tmp__ = _r.readRune(), _ch:GoInt32 = __tmp__._0, _size:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if ((_size != ((1 : GoInt))) && (_err == null)) {
            _err = stdgo.fmt.Fmt.errorf(((("invalid rune %#U" : GoString))), Go.toInterface(_ch));
        };
        return { _0 : ((_ch : GoByte)), _1 : _err };
    }
    public var __t__ : T_byteReader;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class T_byteReader_static_extension {
    @:keep
    public static function unreadByte(_r:T_byteReader):Error {
        (_r == null ? null : _r.__copy__());
        return _r.unreadRune();
    }
    @:keep
    public static function readByte(_r:T_byteReader):{ var _0 : GoByte; var _1 : Error; } {
        (_r == null ? null : _r.__copy__());
        var __tmp__ = _r.readRune(), _ch:GoInt32 = __tmp__._0, _size:GoInt = __tmp__._1, _err:stdgo.Error = __tmp__._2;
        if ((_size != ((1 : GoInt))) && (_err == null)) {
            _err = stdgo.fmt.Fmt.errorf(((("invalid rune %#U" : GoString))), Go.toInterface(_ch));
        };
        return { _0 : ((_ch : GoByte)), _1 : _err };
    }
}
class T_argNN_wrapper {
    public var __t__ : T_argNN;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_shiftTest_wrapper {
    public var __t__ : T_shiftTest;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_modWTest_wrapper {
    public var __t__ : T_modWTest;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_divisor_wrapper {
    public var __t__ : T_divisor;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class Rat_wrapper {
    @:keep
    public function unmarshalText(_text:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        {
            var __tmp__ = _z.setString(((_text : GoString))), _0:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Rat" : GoString))), Go.toInterface(_text));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function marshalText():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x.isInt()) {
            return _x._a.marshalText();
        };
        return { _0 : _x._marshal(), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function gobDecode(_buf:Slice<GoByte>):Error {
        var _z = __t__;
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Rat() : Rat));
                _z._a = __tmp__._a;
                _z._b = __tmp__._b;
            };
            return ((null : stdgo.Error));
        };
        var _b:GoUInt8 = (_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)));
        if ((_b >> ((1 : GoUnTypedInt))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Rat.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface(_b >> ((1 : GoUnTypedInt))));
        };
        {};
        var _i:GoUInt32 = ((5 : GoUInt32)) + stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((1 : GoInt)), ((5 : GoInt))) : Slice<GoUInt8>)));
        _z._a._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._a._abs = (_z._a._abs._setBytes(((_buf.__slice__(((5 : GoInt)), _i) : Slice<GoUInt8>))) == null ? null : _z._a._abs._setBytes(((_buf.__slice__(((5 : GoInt)), _i) : Slice<GoUInt8>))).__copy__());
        _z._b._abs = (_z._b._abs._setBytes(((_buf.__slice__(_i) : Slice<GoUInt8>))) == null ? null : _z._b._abs._setBytes(((_buf.__slice__(_i) : Slice<GoUInt8>))).__copy__());
        return ((null : stdgo.Error));
    }
    @:keep
    public function gobEncode():{ var _0 : Slice<GoByte>; var _1 : Error; } {
        var _x = __t__;
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((5 : GoInt)) + (((_x._a._abs != null ? _x._a._abs.length : ((0 : GoInt))) + (_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt)))) * ((4 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _i:GoInt = _x._b._abs._bytes(_buf);
        var _j:GoInt = _x._a._abs._bytes(((_buf.__slice__(0, _i) : Slice<GoUInt8>)));
        var _n:GoInt = _i - _j;
        if (((((_n : GoUInt32)) : GoInt)) != _n) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : stdgo.errors.Errors.new_(((("Rat.GobEncode: numerator too large" : GoString)))) };
        };
        stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(_j - ((4 : GoInt)), _j) : Slice<GoUInt8>)), ((_n : GoUInt32)));
        _j = _j - (((5 : GoInt)));
        var _b:GoUInt8 = ((2 : GoUInt8));
        if (_x._a._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[_j] = _b;
        return { _0 : ((_buf.__slice__(_j) : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public function floatString(_prec:GoInt):GoString {
        var _x = __t__;
        _x;
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        if (_x.isInt()) {
            _buf = _x._a.append(_buf, ((10 : GoInt)));
            if (_prec > ((0 : GoInt))) {
                _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
                {
                    var _i:GoInt = _prec;
                    Go.cfor(_i > ((0 : GoInt)), _i--, {
                        _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                    });
                };
            };
            return ((_buf : GoString));
        };
        var __tmp__ = ((new T_nat() : T_nat))._div(((new T_nat() : T_nat)), (_x._a._abs == null ? null : _x._a._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__())), _q:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
        var _p:T_nat = (_natOne == null ? null : _natOne.__copy__());
        if (_prec > ((0 : GoInt))) {
            _p = (((new T_nat() : T_nat))._expNN((_natTen == null ? null : _natTen.__copy__()), (((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))) == null ? null : ((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))).__copy__()), null) == null ? null : ((new T_nat() : T_nat))._expNN((_natTen == null ? null : _natTen.__copy__()), (((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))) == null ? null : ((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))).__copy__()), null).__copy__());
        };
        _r = (_r._mul((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())) == null ? null : _r._mul((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())).__copy__());
        var __tmp__ = _r._div(((new T_nat() : T_nat)), (_r == null ? null : _r.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__())), _r:T_nat = __tmp__._0, _r2:T_nat = __tmp__._1;
        _r2 = (_r2._add((_r2 == null ? null : _r2.__copy__()), (_r2 == null ? null : _r2.__copy__())) == null ? null : _r2._add((_r2 == null ? null : _r2.__copy__()), (_r2 == null ? null : _r2.__copy__())).__copy__());
        if (_x._b._abs._cmp((_r2 == null ? null : _r2.__copy__())) <= ((0 : GoInt))) {
            _r = (_r._add((_r == null ? null : _r.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _r._add((_r == null ? null : _r.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            if (_r._cmp((_p == null ? null : _p.__copy__())) >= ((0 : GoInt))) {
                _q = (((new T_nat() : T_nat))._add((_q == null ? null : _q.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._add((_q == null ? null : _q.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _r = (((new T_nat() : T_nat))._sub((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())).__copy__());
            };
        };
        if (_x._a._neg) {
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        _buf = (_buf != null ? _buf.__append__(..._q._utoa(((10 : GoInt))).__toArray__()) : new Slice<GoUInt8>(..._q._utoa(((10 : GoInt))).__toArray__()));
        if (_prec > ((0 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            var _rs:Slice<GoUInt8> = _r._utoa(((10 : GoInt)));
            {
                var _i:GoInt = _prec - (_rs != null ? _rs.length : ((0 : GoInt)));
                Go.cfor(_i > ((0 : GoInt)), _i--, {
                    _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                });
            };
            _buf = (_buf != null ? _buf.__append__(..._rs.__toArray__()) : new Slice<GoUInt8>(..._rs.__toArray__()));
        };
        return ((_buf : GoString));
    }
    @:keep
    public function ratString():GoString {
        var _x = __t__;
        _x;
        if (_x.isInt()) {
            return ((_x._a.toString() : GoString));
        };
        return ((_x.toString() : GoString));
    }
    @:keep
    public function _marshal():Slice<GoByte> {
        var _x = __t__;
        _x;
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        _buf = _x._a.append(_buf, ((10 : GoInt)));
        _buf = (_buf != null ? _buf.__append__(((((("/" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("/" : GoString))).code : GoRune))));
        if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) != ((0 : GoInt))) {
            _buf = _x._b.append(_buf, ((10 : GoInt)));
        } else {
            _buf = (_buf != null ? _buf.__append__(((((("1" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("1" : GoString))).code : GoRune))));
        };
        return _buf;
    }
    @:keep
    public function toString():GoString {
        var _x = __t__;
        _x;
        return ((_x._marshal() : GoString));
    }
    @:keep
    public function setString(_s:GoString):{ var _0 : Rat; var _1 : Bool; } {
        var _z = __t__;
        _z;
        if ((_s != null ? _s.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return { _0 : null, _1 : false };
        };
        {
            var _sep:GoInt = stdgo.strings.Strings.index(_s, ((("/" : GoString))));
            if (_sep >= ((0 : GoInt))) {
                {
                    var __tmp__ = _z._a.setString(((_s.__slice__(0, _sep) : GoString)), ((0 : GoInt))), _0:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : false };
                    };
                };
                var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(((_s.__slice__(_sep + ((1 : GoInt))) : GoString)));
                var _err:Error = ((null : stdgo.Error));
                {
                    {
                        var __tmp__ = _z._b._abs._scan(_r, ((0 : GoInt)), false);
                        _z._b._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _err = __tmp__._3;
                    };
                    if (_err != null) {
                        return { _0 : null, _1 : false };
                    };
                };
                {
                    {
                        var __tmp__ = _r.readByte();
                        _err = __tmp__._1;
                    };
                    if (_err != stdgo.io.Io.eof) {
                        return { _0 : null, _1 : false };
                    };
                };
                if ((_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                    return { _0 : null, _1 : false };
                };
                return { _0 : _z._norm(), _1 : true };
            };
        };
        var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_s);
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _base:GoInt = ((0 : GoInt));
        var _fcount:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _z._a._abs._scan(_r, ((0 : GoInt)), true);
            _z._a._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _base = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _exp:GoInt64 = ((0 : GoInt64));
        var _ebase:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _scanExponent(_r, true, true);
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        {
            {
                var __tmp__ = _r.readByte();
                _err = __tmp__._1;
            };
            if (_err != stdgo.io.Io.eof) {
                return { _0 : null, _1 : false };
            };
        };
        if ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return { _0 : _z, _1 : true };
        };
        var _exp2:GoInt64 = ((0 : GoInt64)), _exp5:GoInt64 = ((0 : GoInt64));
        if (_fcount < ((0 : GoInt))) {
            var _d:GoInt64 = ((_fcount : GoInt64));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _base == ((10 : GoInt)))) {
                        _exp5 = _d;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _base == ((2 : GoInt)))) {
                        _exp2 = _d;
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _base == ((8 : GoInt)))) {
                        _exp2 = _d * ((3 : GoInt64));
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _base == ((16 : GoInt)))) {
                        _exp2 = _d * ((4 : GoInt64));
                        break;
                        break;
                    } else {
                        throw Go.toInterface(((("unexpected mantissa base" : GoString))));
                        break;
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ebase == ((10 : GoInt)))) {
                    _exp5 = _exp5 + (_exp);
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ebase == ((2 : GoInt)))) {
                    _exp2 = _exp2 + (_exp);
                    break;
                    break;
                } else {
                    throw Go.toInterface(((("unexpected exponent base" : GoString))));
                    break;
                };
                break;
            };
        };
        if (_exp5 != ((0 : GoInt64))) {
            var _n:GoInt64 = _exp5;
            if (_n < ((0 : GoInt64))) {
                _n = -_n;
                if (_n < ((0 : GoInt64))) {
                    return { _0 : null, _1 : false };
                };
            };
            if (_n > ((1e+06 : GoInt64))) {
                return { _0 : null, _1 : false };
            };
            var _pow5:T_nat = (_z._b._abs._expNN((_natFive == null ? null : _natFive.__copy__()), (((new T_nat() : T_nat))._setWord(((_n : Word))) == null ? null : ((new T_nat() : T_nat))._setWord(((_n : Word))).__copy__()), null) == null ? null : _z._b._abs._expNN((_natFive == null ? null : _natFive.__copy__()), (((new T_nat() : T_nat))._setWord(((_n : Word))) == null ? null : ((new T_nat() : T_nat))._setWord(((_n : Word))).__copy__()), null).__copy__());
            if (_exp5 > ((0 : GoInt64))) {
                _z._a._abs = (_z._a._abs._mul((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_pow5 == null ? null : _pow5.__copy__())) == null ? null : _z._a._abs._mul((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_pow5 == null ? null : _pow5.__copy__())).__copy__());
                _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
            } else {
                _z._b._abs = (_pow5 == null ? null : _pow5.__copy__());
            };
        } else {
            _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        };
        if ((_exp2 < ((-10000000 : GoInt64))) || (_exp2 > ((1e+07 : GoInt64)))) {
            return { _0 : null, _1 : false };
        };
        if (_exp2 > ((0 : GoInt64))) {
            _z._a._abs = (_z._a._abs._shl((_z._a._abs == null ? null : _z._a._abs.__copy__()), ((_exp2 : GoUInt))) == null ? null : _z._a._abs._shl((_z._a._abs == null ? null : _z._a._abs.__copy__()), ((_exp2 : GoUInt))).__copy__());
        } else if (_exp2 < ((0 : GoInt64))) {
            _z._b._abs = (_z._b._abs._shl((_z._b._abs == null ? null : _z._b._abs.__copy__()), ((-_exp2 : GoUInt))) == null ? null : _z._b._abs._shl((_z._b._abs == null ? null : _z._b._abs.__copy__()), ((-_exp2 : GoUInt))).__copy__());
        };
        _z._a._neg = _neg && ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) > ((0 : GoInt)));
        return { _0 : _z._norm(), _1 : true };
    }
    @:keep
    public function scan(_s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        var _z = __t__;
        _z;
        var __tmp__ = _s.token(true, _ratTok), _tok:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return _err;
        };
        if (!stdgo.strings.Strings.containsRune(((("efgEFGv" : GoString))), _ch)) {
            return stdgo.errors.Errors.new_(((("Rat.Scan: invalid verb" : GoString))));
        };
        {
            var __tmp__ = _z.setString(((_tok : GoString))), _0:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.errors.Errors.new_(((("Rat.Scan: invalid syntax" : GoString))));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public function quo(_x:Rat, _y:Rat):Rat {
        var _z = __t__;
        _z;
        if ((_y._a._abs != null ? _y._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _b._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a._abs = (_a._abs == null ? null : _a._abs.__copy__());
        _z._b._abs = (_b._abs == null ? null : _b._abs.__copy__());
        _z._a._neg = _a._neg != _b._neg;
        return _z._norm();
    }
    @:keep
    public function mul(_x:Rat, _y:Rat):Rat {
        var _z = __t__;
        _z;
        if (_x == _y) {
            _z._a._neg = false;
            _z._a._abs = (_z._a._abs._sqr((_x._a._abs == null ? null : _x._a._abs.__copy__())) == null ? null : _z._a._abs._sqr((_x._a._abs == null ? null : _x._a._abs.__copy__())).__copy__());
            if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
            } else {
                _z._b._abs = (_z._b._abs._sqr((_x._b._abs == null ? null : _x._b._abs.__copy__())) == null ? null : _z._b._abs._sqr((_x._b._abs == null ? null : _x._b._abs.__copy__())).__copy__());
            };
            return _z;
        };
        _z._a.mul(_x._a, _y._a);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function sub(_x:Rat, _y:Rat):Rat {
        var _z = __t__;
        _z;
        var _a1:Int_ = new Int_(), _a2:Int_ = new Int_();
        _a1._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _a2._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a.sub(_a1, _a2);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function add(_x:Rat, _y:Rat):Rat {
        var _z = __t__;
        _z;
        var _a1:Int_ = new Int_(), _a2:Int_ = new Int_();
        _a1._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _a2._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a.add(_a1, _a2);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function cmp(_y:Rat):GoInt {
        var _x = __t__;
        _x;
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _b._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        return _a.cmp(_b);
    }
    @:keep
    public function _norm():Rat {
        var _z = __t__;
        _z;
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                    _z._a._neg = false;
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                    _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
                    break;
                    break;
                } else {
                    var _neg:Bool = _z._a._neg;
                    _z._a._neg = false;
                    _z._b._neg = false;
                    {
                        var _f:Ref<Int_> = newInt(((0 : GoInt64)))._lehmerGCD(null, null, _z._a, _z._b);
                        if (_f.cmp(_intOne) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _z._a._abs._div(null, (_z._a._abs == null ? null : _z._a._abs.__copy__()), (_f._abs == null ? null : _f._abs.__copy__()));
                                _z._a._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            };
                            {
                                var __tmp__ = _z._b._abs._div(null, (_z._b._abs == null ? null : _z._b._abs.__copy__()), (_f._abs == null ? null : _f._abs.__copy__()));
                                _z._b._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            };
                        };
                    };
                    _z._a._neg = _neg;
                    break;
                };
                break;
            };
        };
        return _z;
    }
    @:keep
    public function denom():Int_ {
        var _x = __t__;
        _x;
        if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (({ _abs : ((new Slice<Word>(((1 : GoUInt))) : T_nat)), _neg : false } : Int_));
        };
        return _x._b;
    }
    @:keep
    public function num():Int_ {
        var _x = __t__;
        _x;
        return _x._a;
    }
    @:keep
    public function isInt():Bool {
        var _x = __t__;
        _x;
        return ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || (_x._b._abs._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt)));
    }
    @:keep
    public function sign():GoInt {
        var _x = __t__;
        _x;
        return _x._a.sign();
    }
    @:keep
    public function inv(_x:Rat):Rat {
        var _z = __t__;
        _z;
        if ((_x._a._abs != null ? _x._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        _z.set(_x);
        {
            final __tmp__0 = (_z._b._abs == null ? null : _z._b._abs.__copy__());
            final __tmp__1 = (_z._a._abs == null ? null : _z._a._abs.__copy__());
            _z._a._abs = __tmp__0;
            _z._b._abs = __tmp__1;
        };
        return _z;
    }
    @:keep
    public function neg(_x:Rat):Rat {
        var _z = __t__;
        _z;
        _z.set(_x);
        _z._a._neg = ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && !_z._a._neg;
        return _z;
    }
    @:keep
    public function abs(_x:Rat):Rat {
        var _z = __t__;
        _z;
        _z.set(_x);
        _z._a._neg = false;
        return _z;
    }
    @:keep
    public function set(_x:Rat):Rat {
        var _z = __t__;
        _z;
        if (_z != _x) {
            _z._a.set(_x._a);
            _z._b.set(_x._b);
        };
        if ((_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        };
        return _z;
    }
    @:keep
    public function setUint64(_x:GoUInt64):Rat {
        var _z = __t__;
        _z;
        _z._a.setUint64(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public function setInt64(_x:GoInt64):Rat {
        var _z = __t__;
        _z;
        _z._a.setInt64(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public function setInt(_x:Int_):Rat {
        var _z = __t__;
        _z;
        _z._a.set(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public function setFrac64(_a:GoInt64, _b:GoInt64):Rat {
        var _z = __t__;
        _z;
        if (_b == ((0 : GoInt64))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        _z._a.setInt64(_a);
        if (_b < ((0 : GoInt64))) {
            _b = -_b;
            _z._a._neg = !_z._a._neg;
        };
        _z._b._abs = (_z._b._abs._setUint64(((_b : GoUInt64))) == null ? null : _z._b._abs._setUint64(((_b : GoUInt64))).__copy__());
        return _z._norm();
    }
    @:keep
    public function setFrac(_a:Int_, _b:Int_):Rat {
        var _z = __t__;
        _z;
        _z._a._neg = _a._neg != _b._neg;
        var _babs:T_nat = (_b._abs == null ? null : _b._abs.__copy__());
        if ((_babs != null ? _babs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        if ((_z._a == _b) || _alias((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_babs == null ? null : _babs.__copy__()))) {
            _babs = (((new T_nat() : T_nat))._set((_babs == null ? null : _babs.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_babs == null ? null : _babs.__copy__())).__copy__());
        };
        _z._a._abs = (_z._a._abs._set((_a._abs == null ? null : _a._abs.__copy__())) == null ? null : _z._a._abs._set((_a._abs == null ? null : _a._abs.__copy__())).__copy__());
        _z._b._abs = (_z._b._abs._set((_babs == null ? null : _babs.__copy__())) == null ? null : _z._b._abs._set((_babs == null ? null : _babs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public function float64():{ var _0 : GoFloat64; var _1 : Bool; } {
        var _x = __t__;
        _x;
        var _f:GoFloat64 = ((0 : GoFloat64)), _exact:Bool = false;
        var _b:T_nat = (_x._b._abs == null ? null : _x._b._abs.__copy__());
        if ((_b != null ? _b.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _b = (_natOne == null ? null : _natOne.__copy__());
        };
        {
            var __tmp__ = _quotToFloat64((_x._a._abs == null ? null : _x._a._abs.__copy__()), (_b == null ? null : _b.__copy__()));
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    @:keep
    public function float32():{ var _0 : GoFloat32; var _1 : Bool; } {
        var _x = __t__;
        _x;
        var _f:GoFloat32 = ((0 : GoFloat32)), _exact:Bool = false;
        var _b:T_nat = (_x._b._abs == null ? null : _x._b._abs.__copy__());
        if ((_b != null ? _b.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _b = (_natOne == null ? null : _natOne.__copy__());
        };
        {
            var __tmp__ = _quotToFloat32((_x._a._abs == null ? null : _x._a._abs.__copy__()), (_b == null ? null : _b.__copy__()));
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    @:keep
    public function setFloat64(_f:GoFloat64):Rat {
        var _z = __t__;
        _z;
        {};
        var _bits:GoUInt64 = stdgo.math.Math.float64bits(_f);
        var _mantissa:GoUInt64 = _bits & (("4503599627370495" : GoUInt64));
        var _exp:GoInt = ((((_bits >> ((52 : GoUnTypedInt))) & ((2047 : GoUInt64))) : GoInt));
        if (_exp == ((2047 : GoInt))) {
            return null;
        } else if (_exp == ((0 : GoInt))) {
            _exp = _exp - (((1022 : GoInt)));
        } else {
            _mantissa = _mantissa | ((("4503599627370496" : GoUInt64)));
            _exp = _exp - (((1023 : GoInt)));
        };
        var _shift:GoInt = ((52 : GoInt)) - _exp;
        while (((_mantissa & ((1 : GoUInt64))) == ((0 : GoUInt64))) && (_shift > ((0 : GoInt)))) {
            _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
            _shift--;
        };
        _z._a.setUint64(_mantissa);
        _z._a._neg = _f < ((0 : GoFloat64));
        _z._b.set(_intOne);
        if (_shift > ((0 : GoInt))) {
            _z._b.lsh(_z._b, ((_shift : GoUInt)));
        } else {
            _z._a.lsh(_z._a, ((-_shift : GoUInt)));
        };
        return _z._norm();
    }
    public var __t__ : Rat;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class Rat_static_extension {
    @:keep
    public static function unmarshalText(_z:Ref<Rat>, _text:Slice<GoByte>):Error {
        _z;
        {
            var __tmp__ = _z.setString(((_text : GoString))), _0:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.fmt.Fmt.errorf(((("math/big: cannot unmarshal %q into a *big.Rat" : GoString))), Go.toInterface(_text));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public static function marshalText(_x:Ref<Rat>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        var _text:Slice<GoByte> = ((null : Slice<GoUInt8>)), _err:Error = ((null : stdgo.Error));
        if (_x.isInt()) {
            return _x._a.marshalText();
        };
        return { _0 : _x._marshal(), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function gobDecode(_z:Ref<Rat>, _buf:Slice<GoByte>):Error {
        _z;
        if ((_buf != null ? _buf.length : ((0 : GoInt))) == ((0 : GoInt))) {
            {
                var __tmp__ = ((new Rat() : Rat));
                _z._a = __tmp__._a;
                _z._b = __tmp__._b;
            };
            return ((null : stdgo.Error));
        };
        var _b:GoUInt8 = (_buf != null ? _buf[((0 : GoInt))] : ((0 : GoUInt8)));
        if ((_b >> ((1 : GoUnTypedInt))) != ((1 : GoUInt8))) {
            return stdgo.fmt.Fmt.errorf(((("Rat.GobDecode: encoding version %d not supported" : GoString))), Go.toInterface(_b >> ((1 : GoUnTypedInt))));
        };
        {};
        var _i:GoUInt32 = ((5 : GoUInt32)) + stdgo.encoding.binary.Binary.bigEndian.uint32(((_buf.__slice__(((1 : GoInt)), ((5 : GoInt))) : Slice<GoUInt8>)));
        _z._a._neg = (_b & ((1 : GoUInt8))) != ((0 : GoUInt8));
        _z._a._abs = (_z._a._abs._setBytes(((_buf.__slice__(((5 : GoInt)), _i) : Slice<GoUInt8>))) == null ? null : _z._a._abs._setBytes(((_buf.__slice__(((5 : GoInt)), _i) : Slice<GoUInt8>))).__copy__());
        _z._b._abs = (_z._b._abs._setBytes(((_buf.__slice__(_i) : Slice<GoUInt8>))) == null ? null : _z._b._abs._setBytes(((_buf.__slice__(_i) : Slice<GoUInt8>))).__copy__());
        return ((null : stdgo.Error));
    }
    @:keep
    public static function gobEncode(_x:Ref<Rat>):{ var _0 : Slice<GoByte>; var _1 : Error; } {
        _x;
        if (_x == null) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
        };
        var _buf:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((((5 : GoInt)) + (((_x._a._abs != null ? _x._a._abs.length : ((0 : GoInt))) + (_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt)))) * ((4 : GoInt))) : GoInt)).toBasic()) ((0 : GoUInt8))]);
        var _i:GoInt = _x._b._abs._bytes(_buf);
        var _j:GoInt = _x._a._abs._bytes(((_buf.__slice__(0, _i) : Slice<GoUInt8>)));
        var _n:GoInt = _i - _j;
        if (((((_n : GoUInt32)) : GoInt)) != _n) {
            return { _0 : ((null : Slice<GoUInt8>)), _1 : stdgo.errors.Errors.new_(((("Rat.GobEncode: numerator too large" : GoString)))) };
        };
        stdgo.encoding.binary.Binary.bigEndian.putUint32(((_buf.__slice__(_j - ((4 : GoInt)), _j) : Slice<GoUInt8>)), ((_n : GoUInt32)));
        _j = _j - (((5 : GoInt)));
        var _b:GoUInt8 = ((2 : GoUInt8));
        if (_x._a._neg) {
            _b = _b | (((1 : GoUInt8)));
        };
        if (_buf != null) _buf[_j] = _b;
        return { _0 : ((_buf.__slice__(_j) : Slice<GoUInt8>)), _1 : ((null : stdgo.Error)) };
    }
    @:keep
    public static function floatString(_x:Ref<Rat>, _prec:GoInt):GoString {
        _x;
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        if (_x.isInt()) {
            _buf = _x._a.append(_buf, ((10 : GoInt)));
            if (_prec > ((0 : GoInt))) {
                _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
                {
                    var _i:GoInt = _prec;
                    Go.cfor(_i > ((0 : GoInt)), _i--, {
                        _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                    });
                };
            };
            return ((_buf : GoString));
        };
        var __tmp__ = ((new T_nat() : T_nat))._div(((new T_nat() : T_nat)), (_x._a._abs == null ? null : _x._a._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__())), _q:T_nat = __tmp__._0, _r:T_nat = __tmp__._1;
        var _p:T_nat = (_natOne == null ? null : _natOne.__copy__());
        if (_prec > ((0 : GoInt))) {
            _p = (((new T_nat() : T_nat))._expNN((_natTen == null ? null : _natTen.__copy__()), (((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))) == null ? null : ((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))).__copy__()), null) == null ? null : ((new T_nat() : T_nat))._expNN((_natTen == null ? null : _natTen.__copy__()), (((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))) == null ? null : ((new T_nat() : T_nat))._setUint64(((_prec : GoUInt64))).__copy__()), null).__copy__());
        };
        _r = (_r._mul((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())) == null ? null : _r._mul((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())).__copy__());
        var __tmp__ = _r._div(((new T_nat() : T_nat)), (_r == null ? null : _r.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__())), _r:T_nat = __tmp__._0, _r2:T_nat = __tmp__._1;
        _r2 = (_r2._add((_r2 == null ? null : _r2.__copy__()), (_r2 == null ? null : _r2.__copy__())) == null ? null : _r2._add((_r2 == null ? null : _r2.__copy__()), (_r2 == null ? null : _r2.__copy__())).__copy__());
        if (_x._b._abs._cmp((_r2 == null ? null : _r2.__copy__())) <= ((0 : GoInt))) {
            _r = (_r._add((_r == null ? null : _r.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : _r._add((_r == null ? null : _r.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            if (_r._cmp((_p == null ? null : _p.__copy__())) >= ((0 : GoInt))) {
                _q = (((new T_nat() : T_nat))._add((_q == null ? null : _q.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._add((_q == null ? null : _q.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
                _r = (((new T_nat() : T_nat))._sub((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__())).__copy__());
            };
        };
        if (_x._a._neg) {
            _buf = (_buf != null ? _buf.__append__(((((("-" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("-" : GoString))).code : GoRune))));
        };
        _buf = (_buf != null ? _buf.__append__(..._q._utoa(((10 : GoInt))).__toArray__()) : new Slice<GoUInt8>(..._q._utoa(((10 : GoInt))).__toArray__()));
        if (_prec > ((0 : GoInt))) {
            _buf = (_buf != null ? _buf.__append__(((((("." : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("." : GoString))).code : GoRune))));
            var _rs:Slice<GoUInt8> = _r._utoa(((10 : GoInt)));
            {
                var _i:GoInt = _prec - (_rs != null ? _rs.length : ((0 : GoInt)));
                Go.cfor(_i > ((0 : GoInt)), _i--, {
                    _buf = (_buf != null ? _buf.__append__(((((("0" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("0" : GoString))).code : GoRune))));
                });
            };
            _buf = (_buf != null ? _buf.__append__(..._rs.__toArray__()) : new Slice<GoUInt8>(..._rs.__toArray__()));
        };
        return ((_buf : GoString));
    }
    @:keep
    public static function ratString(_x:Ref<Rat>):GoString {
        _x;
        if (_x.isInt()) {
            return ((_x._a.toString() : GoString));
        };
        return ((_x.toString() : GoString));
    }
    @:keep
    public static function _marshal(_x:Ref<Rat>):Slice<GoByte> {
        _x;
        var _buf:Slice<GoByte> = ((null : Slice<GoUInt8>));
        _buf = _x._a.append(_buf, ((10 : GoInt)));
        _buf = (_buf != null ? _buf.__append__(((((("/" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("/" : GoString))).code : GoRune))));
        if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) != ((0 : GoInt))) {
            _buf = _x._b.append(_buf, ((10 : GoInt)));
        } else {
            _buf = (_buf != null ? _buf.__append__(((((("1" : GoString))).code : GoRune))) : new Slice<GoUInt8>(((((("1" : GoString))).code : GoRune))));
        };
        return _buf;
    }
    @:keep
    public static function toString(_x:Ref<Rat>):GoString {
        _x;
        return ((_x._marshal() : GoString));
    }
    @:keep
    public static function setString(_z:Ref<Rat>, _s:GoString):{ var _0 : Rat; var _1 : Bool; } {
        _z;
        if ((_s != null ? _s.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return { _0 : null, _1 : false };
        };
        {
            var _sep:GoInt = stdgo.strings.Strings.index(_s, ((("/" : GoString))));
            if (_sep >= ((0 : GoInt))) {
                {
                    var __tmp__ = _z._a.setString(((_s.__slice__(0, _sep) : GoString)), ((0 : GoInt))), _0:Ref<Int_> = __tmp__._0, _ok:Bool = __tmp__._1;
                    if (!_ok) {
                        return { _0 : null, _1 : false };
                    };
                };
                var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(((_s.__slice__(_sep + ((1 : GoInt))) : GoString)));
                var _err:Error = ((null : stdgo.Error));
                {
                    {
                        var __tmp__ = _z._b._abs._scan(_r, ((0 : GoInt)), false);
                        _z._b._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _err = __tmp__._3;
                    };
                    if (_err != null) {
                        return { _0 : null, _1 : false };
                    };
                };
                {
                    {
                        var __tmp__ = _r.readByte();
                        _err = __tmp__._1;
                    };
                    if (_err != stdgo.io.Io.eof) {
                        return { _0 : null, _1 : false };
                    };
                };
                if ((_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                    return { _0 : null, _1 : false };
                };
                return { _0 : _z._norm(), _1 : true };
            };
        };
        var _r:Ref<stdgo.strings.Strings.Reader> = stdgo.strings.Strings.newReader(_s);
        var __tmp__ = _scanSign(_r), _neg:Bool = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _base:GoInt = ((0 : GoInt));
        var _fcount:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _z._a._abs._scan(_r, ((0 : GoInt)), true);
            _z._a._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _base = __tmp__._1;
            _fcount = __tmp__._2;
            _err = __tmp__._3;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        var _exp:GoInt64 = ((0 : GoInt64));
        var _ebase:GoInt = ((0 : GoInt));
        {
            var __tmp__ = _scanExponent(_r, true, true);
            _exp = __tmp__._0;
            _ebase = __tmp__._1;
            _err = __tmp__._2;
        };
        if (_err != null) {
            return { _0 : null, _1 : false };
        };
        {
            {
                var __tmp__ = _r.readByte();
                _err = __tmp__._1;
            };
            if (_err != stdgo.io.Io.eof) {
                return { _0 : null, _1 : false };
            };
        };
        if ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return { _0 : _z, _1 : true };
        };
        var _exp2:GoInt64 = ((0 : GoInt64)), _exp5:GoInt64 = ((0 : GoInt64));
        if (_fcount < ((0 : GoInt))) {
            var _d:GoInt64 = ((_fcount : GoInt64));
            {
                var __switchIndex__ = -1;
                while (true) {
                    if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _base == ((10 : GoInt)))) {
                        _exp5 = _d;
                        @:fallthrough {
                            __switchIndex__ = 1;
                            continue;
                        };
                        break;
                    } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _base == ((2 : GoInt)))) {
                        _exp2 = _d;
                        break;
                        break;
                    } else if (__switchIndex__ == 2 || (__switchIndex__ == -1 && _base == ((8 : GoInt)))) {
                        _exp2 = _d * ((3 : GoInt64));
                        break;
                        break;
                    } else if (__switchIndex__ == 3 || (__switchIndex__ == -1 && _base == ((16 : GoInt)))) {
                        _exp2 = _d * ((4 : GoInt64));
                        break;
                        break;
                    } else {
                        throw Go.toInterface(((("unexpected mantissa base" : GoString))));
                        break;
                    };
                    break;
                };
            };
        };
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && _ebase == ((10 : GoInt)))) {
                    _exp5 = _exp5 + (_exp);
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && _ebase == ((2 : GoInt)))) {
                    _exp2 = _exp2 + (_exp);
                    break;
                    break;
                } else {
                    throw Go.toInterface(((("unexpected exponent base" : GoString))));
                    break;
                };
                break;
            };
        };
        if (_exp5 != ((0 : GoInt64))) {
            var _n:GoInt64 = _exp5;
            if (_n < ((0 : GoInt64))) {
                _n = -_n;
                if (_n < ((0 : GoInt64))) {
                    return { _0 : null, _1 : false };
                };
            };
            if (_n > ((1e+06 : GoInt64))) {
                return { _0 : null, _1 : false };
            };
            var _pow5:T_nat = (_z._b._abs._expNN((_natFive == null ? null : _natFive.__copy__()), (((new T_nat() : T_nat))._setWord(((_n : Word))) == null ? null : ((new T_nat() : T_nat))._setWord(((_n : Word))).__copy__()), null) == null ? null : _z._b._abs._expNN((_natFive == null ? null : _natFive.__copy__()), (((new T_nat() : T_nat))._setWord(((_n : Word))) == null ? null : ((new T_nat() : T_nat))._setWord(((_n : Word))).__copy__()), null).__copy__());
            if (_exp5 > ((0 : GoInt64))) {
                _z._a._abs = (_z._a._abs._mul((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_pow5 == null ? null : _pow5.__copy__())) == null ? null : _z._a._abs._mul((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_pow5 == null ? null : _pow5.__copy__())).__copy__());
                _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
            } else {
                _z._b._abs = (_pow5 == null ? null : _pow5.__copy__());
            };
        } else {
            _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        };
        if ((_exp2 < ((-10000000 : GoInt64))) || (_exp2 > ((1e+07 : GoInt64)))) {
            return { _0 : null, _1 : false };
        };
        if (_exp2 > ((0 : GoInt64))) {
            _z._a._abs = (_z._a._abs._shl((_z._a._abs == null ? null : _z._a._abs.__copy__()), ((_exp2 : GoUInt))) == null ? null : _z._a._abs._shl((_z._a._abs == null ? null : _z._a._abs.__copy__()), ((_exp2 : GoUInt))).__copy__());
        } else if (_exp2 < ((0 : GoInt64))) {
            _z._b._abs = (_z._b._abs._shl((_z._b._abs == null ? null : _z._b._abs.__copy__()), ((-_exp2 : GoUInt))) == null ? null : _z._b._abs._shl((_z._b._abs == null ? null : _z._b._abs.__copy__()), ((-_exp2 : GoUInt))).__copy__());
        };
        _z._a._neg = _neg && ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) > ((0 : GoInt)));
        return { _0 : _z._norm(), _1 : true };
    }
    @:keep
    public static function scan(_z:Ref<Rat>, _s:stdgo.fmt.Fmt.ScanState, _ch:GoRune):Error {
        _z;
        var __tmp__ = _s.token(true, _ratTok), _tok:Slice<GoUInt8> = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        if (_err != null) {
            return _err;
        };
        if (!stdgo.strings.Strings.containsRune(((("efgEFGv" : GoString))), _ch)) {
            return stdgo.errors.Errors.new_(((("Rat.Scan: invalid verb" : GoString))));
        };
        {
            var __tmp__ = _z.setString(((_tok : GoString))), _0:Ref<Rat> = __tmp__._0, _ok:Bool = __tmp__._1;
            if (!_ok) {
                return stdgo.errors.Errors.new_(((("Rat.Scan: invalid syntax" : GoString))));
            };
        };
        return ((null : stdgo.Error));
    }
    @:keep
    public static function quo(_z:Ref<Rat>, _x:Rat, _y:Rat):Rat {
        _z;
        if ((_y._a._abs != null ? _y._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _b._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a._abs = (_a._abs == null ? null : _a._abs.__copy__());
        _z._b._abs = (_b._abs == null ? null : _b._abs.__copy__());
        _z._a._neg = _a._neg != _b._neg;
        return _z._norm();
    }
    @:keep
    public static function mul(_z:Ref<Rat>, _x:Rat, _y:Rat):Rat {
        _z;
        if (_x == _y) {
            _z._a._neg = false;
            _z._a._abs = (_z._a._abs._sqr((_x._a._abs == null ? null : _x._a._abs.__copy__())) == null ? null : _z._a._abs._sqr((_x._a._abs == null ? null : _x._a._abs.__copy__())).__copy__());
            if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
                _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
            } else {
                _z._b._abs = (_z._b._abs._sqr((_x._b._abs == null ? null : _x._b._abs.__copy__())) == null ? null : _z._b._abs._sqr((_x._b._abs == null ? null : _x._b._abs.__copy__())).__copy__());
            };
            return _z;
        };
        _z._a.mul(_x._a, _y._a);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public static function sub(_z:Ref<Rat>, _x:Rat, _y:Rat):Rat {
        _z;
        var _a1:Int_ = new Int_(), _a2:Int_ = new Int_();
        _a1._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _a2._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a.sub(_a1, _a2);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public static function add(_z:Ref<Rat>, _x:Rat, _y:Rat):Rat {
        _z;
        var _a1:Int_ = new Int_(), _a2:Int_ = new Int_();
        _a1._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _a2._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        _z._a.add(_a1, _a2);
        _z._b._abs = (_mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())) == null ? null : _mulDenom((_z._b._abs == null ? null : _z._b._abs.__copy__()), (_x._b._abs == null ? null : _x._b._abs.__copy__()), (_y._b._abs == null ? null : _y._b._abs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public static function cmp(_x:Ref<Rat>, _y:Rat):GoInt {
        _x;
        var _a:Int_ = new Int_(), _b:Int_ = new Int_();
        _a._scaleDenom(_x._a, (_y._b._abs == null ? null : _y._b._abs.__copy__()));
        _b._scaleDenom(_y._a, (_x._b._abs == null ? null : _x._b._abs.__copy__()));
        return _a.cmp(_b);
    }
    @:keep
    public static function _norm(_z:Ref<Rat>):Rat {
        _z;
        {
            var __switchIndex__ = -1;
            while (true) {
                if (__switchIndex__ == 0 || (__switchIndex__ == -1 && (_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                    _z._a._neg = false;
                    @:fallthrough {
                        __switchIndex__ = 1;
                        continue;
                    };
                    break;
                } else if (__switchIndex__ == 1 || (__switchIndex__ == -1 && (_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt)))) {
                    _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
                    break;
                    break;
                } else {
                    var _neg:Bool = _z._a._neg;
                    _z._a._neg = false;
                    _z._b._neg = false;
                    {
                        var _f:Ref<Int_> = newInt(((0 : GoInt64)))._lehmerGCD(null, null, _z._a, _z._b);
                        if (_f.cmp(_intOne) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _z._a._abs._div(null, (_z._a._abs == null ? null : _z._a._abs.__copy__()), (_f._abs == null ? null : _f._abs.__copy__()));
                                _z._a._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            };
                            {
                                var __tmp__ = _z._b._abs._div(null, (_z._b._abs == null ? null : _z._b._abs.__copy__()), (_f._abs == null ? null : _f._abs.__copy__()));
                                _z._b._abs = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            };
                        };
                    };
                    _z._a._neg = _neg;
                    break;
                };
                break;
            };
        };
        return _z;
    }
    @:keep
    public static function denom(_x:Ref<Rat>):Int_ {
        _x;
        if ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (({ _abs : ((new Slice<Word>(((1 : GoUInt))) : T_nat)), _neg : false } : Int_));
        };
        return _x._b;
    }
    @:keep
    public static function num(_x:Ref<Rat>):Int_ {
        _x;
        return _x._a;
    }
    @:keep
    public static function isInt(_x:Ref<Rat>):Bool {
        _x;
        return ((_x._b._abs != null ? _x._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) || (_x._b._abs._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt)));
    }
    @:keep
    public static function sign(_x:Ref<Rat>):GoInt {
        _x;
        return _x._a.sign();
    }
    @:keep
    public static function inv(_z:Ref<Rat>, _x:Rat):Rat {
        _z;
        if ((_x._a._abs != null ? _x._a._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        _z.set(_x);
        {
            final __tmp__0 = (_z._b._abs == null ? null : _z._b._abs.__copy__());
            final __tmp__1 = (_z._a._abs == null ? null : _z._a._abs.__copy__());
            _z._a._abs = __tmp__0;
            _z._b._abs = __tmp__1;
        };
        return _z;
    }
    @:keep
    public static function neg(_z:Ref<Rat>, _x:Rat):Rat {
        _z;
        _z.set(_x);
        _z._a._neg = ((_z._a._abs != null ? _z._a._abs.length : ((0 : GoInt))) > ((0 : GoInt))) && !_z._a._neg;
        return _z;
    }
    @:keep
    public static function abs(_z:Ref<Rat>, _x:Rat):Rat {
        _z;
        _z.set(_x);
        _z._a._neg = false;
        return _z;
    }
    @:keep
    public static function set(_z:Ref<Rat>, _x:Rat):Rat {
        _z;
        if (_z != _x) {
            _z._a.set(_x._a);
            _z._b.set(_x._b);
        };
        if ((_z._b._abs != null ? _z._b._abs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        };
        return _z;
    }
    @:keep
    public static function setUint64(_z:Ref<Rat>, _x:GoUInt64):Rat {
        _z;
        _z._a.setUint64(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public static function setInt64(_z:Ref<Rat>, _x:GoInt64):Rat {
        _z;
        _z._a.setInt64(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public static function setInt(_z:Ref<Rat>, _x:Int_):Rat {
        _z;
        _z._a.set(_x);
        _z._b._abs = (_z._b._abs._setWord(((1 : GoUInt))) == null ? null : _z._b._abs._setWord(((1 : GoUInt))).__copy__());
        return _z;
    }
    @:keep
    public static function setFrac64(_z:Ref<Rat>, _a:GoInt64, _b:GoInt64):Rat {
        _z;
        if (_b == ((0 : GoInt64))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        _z._a.setInt64(_a);
        if (_b < ((0 : GoInt64))) {
            _b = -_b;
            _z._a._neg = !_z._a._neg;
        };
        _z._b._abs = (_z._b._abs._setUint64(((_b : GoUInt64))) == null ? null : _z._b._abs._setUint64(((_b : GoUInt64))).__copy__());
        return _z._norm();
    }
    @:keep
    public static function setFrac(_z:Ref<Rat>, _a:Int_, _b:Int_):Rat {
        _z;
        _z._a._neg = _a._neg != _b._neg;
        var _babs:T_nat = (_b._abs == null ? null : _b._abs.__copy__());
        if ((_babs != null ? _babs.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        if ((_z._a == _b) || _alias((_z._a._abs == null ? null : _z._a._abs.__copy__()), (_babs == null ? null : _babs.__copy__()))) {
            _babs = (((new T_nat() : T_nat))._set((_babs == null ? null : _babs.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_babs == null ? null : _babs.__copy__())).__copy__());
        };
        _z._a._abs = (_z._a._abs._set((_a._abs == null ? null : _a._abs.__copy__())) == null ? null : _z._a._abs._set((_a._abs == null ? null : _a._abs.__copy__())).__copy__());
        _z._b._abs = (_z._b._abs._set((_babs == null ? null : _babs.__copy__())) == null ? null : _z._b._abs._set((_babs == null ? null : _babs.__copy__())).__copy__());
        return _z._norm();
    }
    @:keep
    public static function float64(_x:Ref<Rat>):{ var _0 : GoFloat64; var _1 : Bool; } {
        _x;
        var _f:GoFloat64 = ((0 : GoFloat64)), _exact:Bool = false;
        var _b:T_nat = (_x._b._abs == null ? null : _x._b._abs.__copy__());
        if ((_b != null ? _b.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _b = (_natOne == null ? null : _natOne.__copy__());
        };
        {
            var __tmp__ = _quotToFloat64((_x._a._abs == null ? null : _x._a._abs.__copy__()), (_b == null ? null : _b.__copy__()));
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    @:keep
    public static function float32(_x:Ref<Rat>):{ var _0 : GoFloat32; var _1 : Bool; } {
        _x;
        var _f:GoFloat32 = ((0 : GoFloat32)), _exact:Bool = false;
        var _b:T_nat = (_x._b._abs == null ? null : _x._b._abs.__copy__());
        if ((_b != null ? _b.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _b = (_natOne == null ? null : _natOne.__copy__());
        };
        {
            var __tmp__ = _quotToFloat32((_x._a._abs == null ? null : _x._a._abs.__copy__()), (_b == null ? null : _b.__copy__()));
            _f = __tmp__._0;
            _exact = __tmp__._1;
        };
        if (_x._a._neg) {
            _f = -_f;
        };
        return { _0 : _f, _1 : _exact };
    }
    @:keep
    public static function setFloat64(_z:Ref<Rat>, _f:GoFloat64):Rat {
        _z;
        {};
        var _bits:GoUInt64 = stdgo.math.Math.float64bits(_f);
        var _mantissa:GoUInt64 = _bits & (("4503599627370495" : GoUInt64));
        var _exp:GoInt = ((((_bits >> ((52 : GoUnTypedInt))) & ((2047 : GoUInt64))) : GoInt));
        if (_exp == ((2047 : GoInt))) {
            return null;
        } else if (_exp == ((0 : GoInt))) {
            _exp = _exp - (((1022 : GoInt)));
        } else {
            _mantissa = _mantissa | ((("4503599627370496" : GoUInt64)));
            _exp = _exp - (((1023 : GoInt)));
        };
        var _shift:GoInt = ((52 : GoInt)) - _exp;
        while (((_mantissa & ((1 : GoUInt64))) == ((0 : GoUInt64))) && (_shift > ((0 : GoInt)))) {
            _mantissa = _mantissa >> (((1 : GoUnTypedInt)));
            _shift--;
        };
        _z._a.setUint64(_mantissa);
        _z._a._neg = _f < ((0 : GoFloat64));
        _z._b.set(_intOne);
        if (_shift > ((0 : GoInt))) {
            _z._b.lsh(_z._b, ((_shift : GoUInt)));
        } else {
            _z._a.lsh(_z._a, ((-_shift : GoUInt)));
        };
        return _z._norm();
    }
}
class T_ratBinArg_wrapper {
    public var __t__ : T_ratBinArg;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class StringTest_wrapper {
    public var __t__ : StringTest;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_0_wrapper {
    public var __t__ : T__struct_0;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_1_wrapper {
    public var __t__ : T__struct_1;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_2_wrapper {
    public var __t__ : T__struct_2;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_3_wrapper {
    public var __t__ : T__struct_3;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_4_wrapper {
    public var __t__ : T__struct_4;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_5_wrapper {
    public var __t__ : T__struct_5;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_6_wrapper {
    public var __t__ : T__struct_6;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_7_wrapper {
    public var __t__ : T__struct_7;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_8_wrapper {
    public var __t__ : T__struct_8;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_9_wrapper {
    public var __t__ : T__struct_9;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_10_wrapper {
    public var __t__ : T__struct_10;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_11_wrapper {
    public var __t__ : T__struct_11;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_12_wrapper {
    public var __t__ : T__struct_12;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_13_wrapper {
    public var __t__ : T__struct_13;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_14_wrapper {
    public var __t__ : T__struct_14;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_15_wrapper {
    public var __t__ : T__struct_15;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_16_wrapper {
    public var __t__ : T__struct_16;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_17_wrapper {
    public var __t__ : T__struct_17;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_18_wrapper {
    public var __t__ : T__struct_18;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_19_wrapper {
    public var __t__ : T__struct_19;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_20_wrapper {
    public var __t__ : T__struct_20;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_21_wrapper {
    public var __t__ : T__struct_21;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_22_wrapper {
    public var __t__ : T__struct_22;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_23_wrapper {
    public var __t__ : T__struct_23;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_24_wrapper {
    public var __t__ : T__struct_24;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_25_wrapper {
    public var __t__ : T__struct_25;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_26_wrapper {
    public var __t__ : T__struct_26;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_27_wrapper {
    public var __t__ : T__struct_27;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_28_wrapper {
    public var __t__ : T__struct_28;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_29_wrapper {
    public var __t__ : T__struct_29;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_30_wrapper {
    public var __t__ : T__struct_30;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_31_wrapper {
    public var __t__ : T__struct_31;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_32_wrapper {
    public var __t__ : T__struct_32;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_33_wrapper {
    public var __t__ : T__struct_33;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_34_wrapper {
    public var __t__ : T__struct_34;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_35_wrapper {
    public var __t__ : T__struct_35;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_36_wrapper {
    public var __t__ : T__struct_36;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_37_wrapper {
    public var __t__ : T__struct_37;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_38_wrapper {
    public var __t__ : T__struct_38;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_39_wrapper {
    public var __t__ : T__struct_39;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_40_wrapper {
    public var __t__ : T__struct_40;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_41_wrapper {
    public var __t__ : T__struct_41;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_42_wrapper {
    public var __t__ : T__struct_42;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_43_wrapper {
    public var __t__ : T__struct_43;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_44_wrapper {
    public var __t__ : T__struct_44;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_45_wrapper {
    public var __t__ : T__struct_45;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_46_wrapper {
    public var __t__ : T__struct_46;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_47_wrapper {
    public var __t__ : T__struct_47;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_48_wrapper {
    public var __t__ : T__struct_48;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_49_wrapper {
    public var __t__ : T__struct_49;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_50_wrapper {
    public var __t__ : T__struct_50;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_51_wrapper {
    public var __t__ : T__struct_51;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_52_wrapper {
    public var __t__ : T__struct_52;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_53_wrapper {
    public var __t__ : T__struct_53;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_54_wrapper {
    public var __t__ : T__struct_54;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_55_wrapper {
    public var __t__ : T__struct_55;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_56_wrapper {
    public var __t__ : T__struct_56;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_57_wrapper {
    public var __t__ : T__struct_57;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_58_wrapper {
    public var __t__ : T__struct_58;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_59_wrapper {
    public var __t__ : T__struct_59;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_60_wrapper {
    public var __t__ : T__struct_60;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_61_wrapper {
    public var __t__ : T__struct_61;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_62_wrapper {
    public var __t__ : T__struct_62;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_63_wrapper {
    public var __t__ : T__struct_63;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T__struct_64_wrapper {
    public var __t__ : T__struct_64;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class Word_wrapper {
    public var __t__ : Word;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_funVV_wrapper {
    public var __t__ : T_funVV;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_funVW_wrapper {
    public var __t__ : T_funVW;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_funVWW_wrapper {
    public var __t__ : T_funVWW;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_funWVW_wrapper {
    public var __t__ : T_funWVW;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class Bits_wrapper {
    @:keep
    public function float():Float_ {
        var _bits = __t__;
        (_bits == null ? null : _bits.__copy__());
        if ((stdgo.math.bits.Bits != null ? stdgo.math.bits.Bits.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return new Float_();
        };
        var _min:GoInt = ((0 : GoInt));
        for (_i => _b in stdgo.math.bits.Bits) {
            if ((_i == ((0 : GoInt))) || (_b < _min)) {
                _min = _b;
            };
        };
        var _x:Ref<Int_> = newInt(((0 : GoInt64)));
        for (_0 => _b in stdgo.math.bits.Bits) {
            var _badj:GoInt = _b - _min;
            while (_x.bit(_badj) != ((0 : GoUInt))) {
                _x.setBit(_x, _badj, ((0 : GoUInt)));
                _badj++;
            };
            _x.setBit(_x, _badj, ((1 : GoUInt)));
        };
        var _z:Ref<Float_> = new Float_().setInt(_x);
        {
            var _e:GoInt64 = ((_z._exp : GoInt64)) + ((_min : GoInt64));
            if ((((-2147483648 : GoInt64)) <= _e) && (_e <= ((2147483647 : GoInt64)))) {
                _z._exp = ((_e : GoInt32));
            } else {
                throw Go.toInterface(((("exponent out of range" : GoString))));
            };
        };
        return _z;
    }
    @:keep
    public function _round(_prec:GoUInt, _mode:RoundingMode):Float_ {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        _x = (_x._norm() == null ? null : _x._norm().__copy__());
        var _min:GoInt = ((0 : GoInt)), _max:GoInt = ((0 : GoInt));
        for (_i => _b in _x) {
            if ((_i == ((0 : GoInt))) || (_b < _min)) {
                _min = _b;
            };
            if ((_i == ((0 : GoInt))) || (_b > _max)) {
                _max = _b;
            };
        };
        var _prec0:GoUInt = ((((_max + ((1 : GoInt))) - _min) : GoUInt));
        if (_prec >= _prec0) {
            return _x.float();
        };
        var _bit0:GoUInt = ((0 : GoUInt)), _rbit:GoUInt = ((0 : GoUInt)), _sbit:GoUInt = ((0 : GoUInt));
        var _z:Bits = new Bits();
        var _r:GoInt = _max - ((_prec : GoInt));
        for (_0 => _b in _x) {
            if (_b == _r) {
                _rbit = ((1 : GoUInt));
            } else if (_b < _r) {
                _sbit = ((1 : GoUInt));
            } else {
                if (_b == (_r + ((1 : GoInt)))) {
                    _bit0 = ((1 : GoUInt));
                };
                _z = ((_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)) == null ? null : (_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)).__copy__());
            };
        };
        var _f:Ref<Float_> = _z.float();
        if (_mode == ((1 : GoUInt8))) {
            throw Go.toInterface(((("not yet implemented" : GoString))));
        };
        if ((((_mode == ((0 : GoUInt8))) && (_rbit == ((1 : GoUInt)))) && ((_sbit == ((1 : GoUInt))) || ((_sbit == ((0 : GoUInt))) && (_bit0 != ((0 : GoUInt)))))) || (_mode == ((3 : GoUInt8)))) {
            _f.setMode(((2 : GoUInt8))).setPrec(_prec);
            _f.add(_f, ((new Slice<GoInt>(((_r : GoInt)) + ((1 : GoInt))) : Bits)).float());
        };
        return _f;
    }
    @:keep
    public function _norm():Bits {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        var _m:GoMap<GoInt, Bool> = new Map<Int, Bool>();
        for (_0 => _b in _x) {
            while ((_m != null ? _m[_b] : false)) {
                if (_m != null) _m[_b] = false;
                _b++;
            };
            if (_m != null) _m[_b] = true;
        };
        var _z:Bits = new Bits();
        for (_b => _set in _m) {
            if (_set) {
                _z = ((_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)) == null ? null : (_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)).__copy__());
            };
        };
        stdgo.sort.Sort.ints(((_z : Slice<GoInt>)));
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public function _mul(_y:Bits):Bits {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        var _p:Bits = new Bits();
        for (_0 => _x in _x) {
            for (_1 => _y in _y) {
                _p = ((_p != null ? _p.__append__(_x + _y) : new Slice<Slice<GoInt>>(_x + _y)) == null ? null : (_p != null ? _p.__append__(_x + _y) : new Slice<Slice<GoInt>>(_x + _y)).__copy__());
            };
        };
        return (_p == null ? null : _p.__copy__());
    }
    @:keep
    public function _add(_y:Bits):Bits {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        return ((_x != null ? _x.__append__(..._y.__toArray__()) : new Slice<Slice<GoInt>>(..._y.__toArray__())) == null ? null : (_x != null ? _x.__append__(..._y.__toArray__()) : new Slice<Slice<GoInt>>(..._y.__toArray__())).__copy__());
    }
    public var __t__ : Bits;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class Bits_static_extension {
    @:keep
    public static function float(_bits:Bits):Float_ {
        (_bits == null ? null : _bits.__copy__());
        if ((stdgo.math.bits.Bits != null ? stdgo.math.bits.Bits.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return new Float_();
        };
        var _min:GoInt = ((0 : GoInt));
        for (_i => _b in stdgo.math.bits.Bits) {
            if ((_i == ((0 : GoInt))) || (_b < _min)) {
                _min = _b;
            };
        };
        var _x:Ref<Int_> = newInt(((0 : GoInt64)));
        for (_0 => _b in stdgo.math.bits.Bits) {
            var _badj:GoInt = _b - _min;
            while (_x.bit(_badj) != ((0 : GoUInt))) {
                _x.setBit(_x, _badj, ((0 : GoUInt)));
                _badj++;
            };
            _x.setBit(_x, _badj, ((1 : GoUInt)));
        };
        var _z:Ref<Float_> = new Float_().setInt(_x);
        {
            var _e:GoInt64 = ((_z._exp : GoInt64)) + ((_min : GoInt64));
            if ((((-2147483648 : GoInt64)) <= _e) && (_e <= ((2147483647 : GoInt64)))) {
                _z._exp = ((_e : GoInt32));
            } else {
                throw Go.toInterface(((("exponent out of range" : GoString))));
            };
        };
        return _z;
    }
    @:keep
    public static function _round(_x:Bits, _prec:GoUInt, _mode:RoundingMode):Float_ {
        (_x == null ? null : _x.__copy__());
        _x = (_x._norm() == null ? null : _x._norm().__copy__());
        var _min:GoInt = ((0 : GoInt)), _max:GoInt = ((0 : GoInt));
        for (_i => _b in _x) {
            if ((_i == ((0 : GoInt))) || (_b < _min)) {
                _min = _b;
            };
            if ((_i == ((0 : GoInt))) || (_b > _max)) {
                _max = _b;
            };
        };
        var _prec0:GoUInt = ((((_max + ((1 : GoInt))) - _min) : GoUInt));
        if (_prec >= _prec0) {
            return _x.float();
        };
        var _bit0:GoUInt = ((0 : GoUInt)), _rbit:GoUInt = ((0 : GoUInt)), _sbit:GoUInt = ((0 : GoUInt));
        var _z:Bits = new Bits();
        var _r:GoInt = _max - ((_prec : GoInt));
        for (_0 => _b in _x) {
            if (_b == _r) {
                _rbit = ((1 : GoUInt));
            } else if (_b < _r) {
                _sbit = ((1 : GoUInt));
            } else {
                if (_b == (_r + ((1 : GoInt)))) {
                    _bit0 = ((1 : GoUInt));
                };
                _z = ((_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)) == null ? null : (_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)).__copy__());
            };
        };
        var _f:Ref<Float_> = _z.float();
        if (_mode == ((1 : GoUInt8))) {
            throw Go.toInterface(((("not yet implemented" : GoString))));
        };
        if ((((_mode == ((0 : GoUInt8))) && (_rbit == ((1 : GoUInt)))) && ((_sbit == ((1 : GoUInt))) || ((_sbit == ((0 : GoUInt))) && (_bit0 != ((0 : GoUInt)))))) || (_mode == ((3 : GoUInt8)))) {
            _f.setMode(((2 : GoUInt8))).setPrec(_prec);
            _f.add(_f, ((new Slice<GoInt>(((_r : GoInt)) + ((1 : GoInt))) : Bits)).float());
        };
        return _f;
    }
    @:keep
    public static function _norm(_x:Bits):Bits {
        (_x == null ? null : _x.__copy__());
        var _m:GoMap<GoInt, Bool> = new Map<Int, Bool>();
        for (_0 => _b in _x) {
            while ((_m != null ? _m[_b] : false)) {
                if (_m != null) _m[_b] = false;
                _b++;
            };
            if (_m != null) _m[_b] = true;
        };
        var _z:Bits = new Bits();
        for (_b => _set in _m) {
            if (_set) {
                _z = ((_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)) == null ? null : (_z != null ? _z.__append__(_b) : new Slice<Slice<GoInt>>(_b)).__copy__());
            };
        };
        stdgo.sort.Sort.ints(((_z : Slice<GoInt>)));
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public static function _mul(_x:Bits, _y:Bits):Bits {
        (_x == null ? null : _x.__copy__());
        var _p:Bits = new Bits();
        for (_0 => _x in _x) {
            for (_1 => _y in _y) {
                _p = ((_p != null ? _p.__append__(_x + _y) : new Slice<Slice<GoInt>>(_x + _y)) == null ? null : (_p != null ? _p.__append__(_x + _y) : new Slice<Slice<GoInt>>(_x + _y)).__copy__());
            };
        };
        return (_p == null ? null : _p.__copy__());
    }
    @:keep
    public static function _add(_x:Bits, _y:Bits):Bits {
        (_x == null ? null : _x.__copy__());
        return ((_x != null ? _x.__append__(..._y.__toArray__()) : new Slice<Slice<GoInt>>(..._y.__toArray__())) == null ? null : (_x != null ? _x.__append__(..._y.__toArray__()) : new Slice<Slice<GoInt>>(..._y.__toArray__())).__copy__());
    }
}
class T_form_wrapper {
    public var __t__ : T_form;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class RoundingMode_wrapper {
    @:keep
    public function toString():GoString {
        var _i = __t__;
        _i;
        if (_i >= ((((6 : GoInt)) : RoundingMode))) {
            return (((("RoundingMode(" : GoString))) + stdgo.strconv.Strconv.formatInt(((_i : GoInt64)), ((10 : GoInt)))) + (((")" : GoString)));
        };
        return ((((("ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf" : GoString))).__slice__((__RoundingMode_index != null ? __RoundingMode_index[_i] : ((0 : GoUInt8))), (__RoundingMode_index != null ? __RoundingMode_index[_i + ((1 : GoUInt8))] : ((0 : GoUInt8)))) : GoString));
    }
    public var __t__ : RoundingMode;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class RoundingMode_static_extension {
    @:keep
    public static function toString(_i:RoundingMode):GoString {
        _i;
        if (_i >= ((((6 : GoInt)) : RoundingMode))) {
            return (((("RoundingMode(" : GoString))) + stdgo.strconv.Strconv.formatInt(((_i : GoInt64)), ((10 : GoInt)))) + (((")" : GoString)));
        };
        return ((((("ToNearestEvenToNearestAwayToZeroAwayFromZeroToNegativeInfToPositiveInf" : GoString))).__slice__((__RoundingMode_index != null ? __RoundingMode_index[_i] : ((0 : GoUInt8))), (__RoundingMode_index != null ? __RoundingMode_index[_i + ((1 : GoUInt8))] : ((0 : GoUInt8)))) : GoString));
    }
}
class Accuracy_wrapper {
    @:keep
    public function toString():GoString {
        var _i = __t__;
        _i;
        _i = _i - (((-1 : GoInt8)));
        if ((_i < ((0 : GoInt8))) || (_i >= ((((3 : GoInt)) : Accuracy)))) {
            return (((("Accuracy(" : GoString))) + stdgo.strconv.Strconv.formatInt((((_i + ((-1 : GoInt8))) : GoInt64)), ((10 : GoInt)))) + (((")" : GoString)));
        };
        return ((((("BelowExactAbove" : GoString))).__slice__((__Accuracy_index != null ? __Accuracy_index[_i] : ((0 : GoUInt8))), (__Accuracy_index != null ? __Accuracy_index[_i + ((1 : GoInt8))] : ((0 : GoUInt8)))) : GoString));
    }
    public var __t__ : Accuracy;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class Accuracy_static_extension {
    @:keep
    public static function toString(_i:Accuracy):GoString {
        _i;
        _i = _i - (((-1 : GoInt8)));
        if ((_i < ((0 : GoInt8))) || (_i >= ((((3 : GoInt)) : Accuracy)))) {
            return (((("Accuracy(" : GoString))) + stdgo.strconv.Strconv.formatInt((((_i + ((-1 : GoInt8))) : GoInt64)), ((10 : GoInt)))) + (((")" : GoString)));
        };
        return ((((("BelowExactAbove" : GoString))).__slice__((__Accuracy_index != null ? __Accuracy_index[_i] : ((0 : GoUInt8))), (__Accuracy_index != null ? __Accuracy_index[_i + ((1 : GoInt8))] : ((0 : GoUInt8)))) : GoString));
    }
}
class T_funZZ_wrapper {
    public var __t__ : T_funZZ;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_bitFun_wrapper {
    public var __t__ : T_bitFun;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_nat_wrapper {
    @:keep
    public function _probablyPrimeLucas():Bool {
        var _n = __t__;
        (_n == null ? null : _n.__copy__());
        if (((_n != null ? _n.length : ((0 : GoInt))) == ((0 : GoInt))) || (_n._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt)))) {
            return false;
        };
        if (((_n != null ? _n[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((0 : GoUInt))) {
            return _n._cmp((_natTwo == null ? null : _natTwo.__copy__())) == ((0 : GoInt));
        };
        var _p:Word = ((((3 : GoUInt)) : Word));
        var _d:T_nat = ((new Slice<Word>(((1 : GoUInt))) : T_nat));
        var _t1:T_nat = ((new T_nat() : T_nat));
        var _intD:Ref<Int_> = (({ _abs : (_d == null ? null : _d.__copy__()), _neg : false } : Int_));
        var _intN:Ref<Int_> = (({ _abs : (_n == null ? null : _n.__copy__()), _neg : false } : Int_));
        Go.cfor(true, _p++, {
            if (_p > ((10000 : GoUInt))) {
                throw Go.toInterface(((("math/big: internal error: cannot find (D/n) = -1 for " : GoString))) + ((_intN.toString() : GoString)));
            };
            if (_d != null) _d[((0 : GoInt))] = (_p * _p) - ((4 : GoUInt));
            var _j:GoInt = jacobi(_intD, _intN);
            if (_j == ((-1 : GoInt))) {
                break;
            };
            if (_j == ((0 : GoInt))) {
                return ((_n != null ? _n.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_n != null ? _n[((0 : GoInt))] : new Word()) == (_p + ((2 : GoUInt))));
            };
            if (_p == ((40 : GoUInt))) {
                _t1 = (_t1._sqrt((_n == null ? null : _n.__copy__())) == null ? null : _t1._sqrt((_n == null ? null : _n.__copy__())).__copy__());
                _t1 = (_t1._sqr((_t1 == null ? null : _t1.__copy__())) == null ? null : _t1._sqr((_t1 == null ? null : _t1.__copy__())).__copy__());
                if (_t1._cmp((_n == null ? null : _n.__copy__())) == ((0 : GoInt))) {
                    return false;
                };
            };
        });
        var _s:T_nat = (((new T_nat() : T_nat))._add((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._add((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        var _r:GoInt = ((_s._trailingZeroBits() : GoInt));
        _s = (_s._shr((_s == null ? null : _s.__copy__()), ((_r : GoUInt))) == null ? null : _s._shr((_s == null ? null : _s.__copy__()), ((_r : GoUInt))).__copy__());
        var _nm2:T_nat = (((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
        var _natP:T_nat = (((new T_nat() : T_nat))._setWord(_p) == null ? null : ((new T_nat() : T_nat))._setWord(_p).__copy__());
        var _vk:T_nat = (((new T_nat() : T_nat))._setWord(((2 : GoUInt))) == null ? null : ((new T_nat() : T_nat))._setWord(((2 : GoUInt))).__copy__());
        var _vk1:T_nat = (((new T_nat() : T_nat))._setWord(_p) == null ? null : ((new T_nat() : T_nat))._setWord(_p).__copy__());
        var _t2:T_nat = ((new T_nat() : T_nat));
        {
            var _i:GoInt = ((_s._bitLen() : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                if (_s._bit(((_i : GoUInt))) != ((0 : GoUInt))) {
                    _t1 = (_t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())) == null ? null : _t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())).__copy__());
                    _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk == null ? null : _vk.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                    _t1 = (_t1._sqr((_vk1 == null ? null : _vk1.__copy__())) == null ? null : _t1._sqr((_vk1 == null ? null : _vk1.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk1 == null ? null : _vk1.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk1 = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                } else {
                    _t1 = (_t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())) == null ? null : _t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())).__copy__());
                    _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk1 == null ? null : _vk1.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk1 = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                    _t1 = (_t1._sqr((_vk == null ? null : _vk.__copy__())) == null ? null : _t1._sqr((_vk == null ? null : _vk.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk == null ? null : _vk.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                };
            });
        };
        if ((_vk._cmp((_natTwo == null ? null : _natTwo.__copy__())) == ((0 : GoInt))) || (_vk._cmp((_nm2 == null ? null : _nm2.__copy__())) == ((0 : GoInt)))) {
            var _t1:T_nat = (_t1._mul((_vk == null ? null : _vk.__copy__()), (_natP == null ? null : _natP.__copy__())) == null ? null : _t1._mul((_vk == null ? null : _vk.__copy__()), (_natP == null ? null : _natP.__copy__())).__copy__());
            var _t2:T_nat = (_t2._shl((_vk1 == null ? null : _vk1.__copy__()), ((1 : GoUInt))) == null ? null : _t2._shl((_vk1 == null ? null : _vk1.__copy__()), ((1 : GoUInt))).__copy__());
            if (_t1._cmp((_t2 == null ? null : _t2.__copy__())) < ((0 : GoInt))) {
                {
                    final __tmp__0 = (_t2 == null ? null : _t2.__copy__());
                    final __tmp__1 = (_t1 == null ? null : _t1.__copy__());
                    _t1 = __tmp__0;
                    _t2 = __tmp__1;
                };
            };
            _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_t2 == null ? null : _t2.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_t2 == null ? null : _t2.__copy__())).__copy__());
            var _t3:T_nat = (_vk1 == null ? null : _vk1.__copy__());
            _vk1 = null;
            _vk1;
            {
                var __tmp__ = _t2._div((_t3 == null ? null : _t3.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                _t3 = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
            };
            if ((_t3 != null ? _t3.length : ((0 : GoInt))) == ((0 : GoInt))) {
                return true;
            };
        };
        {
            var _t:GoInt = ((0 : GoInt));
            Go.cfor(_t < (_r - ((1 : GoInt))), _t++, {
                if ((_vk != null ? _vk.length : ((0 : GoInt))) == ((0 : GoInt))) {
                    return true;
                };
                if (((_vk != null ? _vk.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_vk != null ? _vk[((0 : GoInt))] : new Word()) == ((2 : GoUInt)))) {
                    return false;
                };
                _t1 = (_t1._sqr((_vk == null ? null : _vk.__copy__())) == null ? null : _t1._sqr((_vk == null ? null : _vk.__copy__())).__copy__());
                _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
                {
                    var __tmp__ = _t2._div((_vk == null ? null : _vk.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                    _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _vk = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
            });
        };
        return false;
    }
    @:keep
    public function _probablyPrimeMillerRabin(_reps:GoInt, _force2:Bool):Bool {
        var _n = __t__;
        (_n == null ? null : _n.__copy__());
        return stdgo.internal.Macro.controlFlow({
            var _nm1:T_nat = (((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            var _k:GoUInt = _nm1._trailingZeroBits();
            var _q:T_nat = (((new T_nat() : T_nat))._shr((_nm1 == null ? null : _nm1.__copy__()), _k) == null ? null : ((new T_nat() : T_nat))._shr((_nm1 == null ? null : _nm1.__copy__()), _k).__copy__());
            var _nm3:T_nat = (((new T_nat() : T_nat))._sub((_nm1 == null ? null : _nm1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_nm1 == null ? null : _nm1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
            var _rand:Ref<stdgo.math.rand.Rand.Rand> = _rand.new_(_rand.newSource((((_n != null ? _n[((0 : GoInt))] : new Word()) : GoInt64))));
            var _x:T_nat = new T_nat(), _y:T_nat = new T_nat(), _quotient:T_nat = new T_nat();
            var _nm3Len:GoInt = _nm3._bitLen();
            @:label("NextRandom") {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _reps, _i++, {
                    if ((_i == (_reps - ((1 : GoInt)))) && _force2) {
                        _x = (_x._set((_natTwo == null ? null : _natTwo.__copy__())) == null ? null : _x._set((_natTwo == null ? null : _natTwo.__copy__())).__copy__());
                    } else {
                        _x = (_x._random(_rand, (_nm3 == null ? null : _nm3.__copy__()), _nm3Len) == null ? null : _x._random(_rand, (_nm3 == null ? null : _nm3.__copy__()), _nm3Len).__copy__());
                        _x = (_x._add((_x == null ? null : _x.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : _x._add((_x == null ? null : _x.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
                    };
                    _y = (_y._expNN((_x == null ? null : _x.__copy__()), (_q == null ? null : _q.__copy__()), (_n == null ? null : _n.__copy__())) == null ? null : _y._expNN((_x == null ? null : _x.__copy__()), (_q == null ? null : _q.__copy__()), (_n == null ? null : _n.__copy__())).__copy__());
                    if ((_y._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt))) || (_y._cmp((_nm1 == null ? null : _nm1.__copy__())) == ((0 : GoInt)))) {
                        continue;
                    };
                    {
                        var _j:GoUInt = ((((1 : GoUInt)) : GoUInt));
                        Go.cfor(_j < _k, _j++, {
                            _y = (_y._sqr((_y == null ? null : _y.__copy__())) == null ? null : _y._sqr((_y == null ? null : _y.__copy__())).__copy__());
                            {
                                var __tmp__ = _quotient._div((_y == null ? null : _y.__copy__()), (_y == null ? null : _y.__copy__()), (_n == null ? null : _n.__copy__()));
                                _quotient = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _y = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            if (_y._cmp((_nm1 == null ? null : _nm1.__copy__())) == ((0 : GoInt))) {
                                continue;
                            };
                            if (_y._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt))) {
                                return false;
                            };
                        });
                    };
                    return false;
                });
            };
            return true;
        });
    }
    @:keep
    public function _divRecursiveStep(_u:T_nat, _v:T_nat, _depth:GoInt, _tmp:T_nat, _temps:Slice<T_nat>):Void {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        _u = (_u._norm() == null ? null : _u._norm().__copy__());
        _v = (_v._norm() == null ? null : _v._norm().__copy__());
        if ((_u != null ? _u.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._clear();
            return;
        };
        var _n:GoInt = (_v != null ? _v.length : ((0 : GoInt)));
        if (_n < ((100 : GoInt))) {
            _z._divBasic((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
            return;
        };
        var _m:GoInt = (_u != null ? _u.length : ((0 : GoInt))) - _n;
        if (_m < ((0 : GoInt))) {
            return;
        };
        var b:GoInt = _n / ((2 : GoInt));
        if ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) == null) {
            if (_temps != null) _temps[_depth] = _getNat(_n);
        } else {
            (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) = ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>)))._make(b + ((1 : GoInt))) == null ? null : (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>)))._make(b + ((1 : GoInt))).__copy__());
        };
        var _j:GoInt = _m;
        while (_j > b) {
            var _s:GoInt = (b - ((1 : GoInt)));
            var _uu:T_nat = (((_u.__slice__(_j - b) : T_nat)) == null ? null : ((_u.__slice__(_j - b) : T_nat)).__copy__());
            var _qhat:T_nat = ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) == null ? null : (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))).__copy__());
            _qhat._clear();
            _qhat._divRecursiveStep((((_uu.__slice__(_s, b + _n) : T_nat)) == null ? null : ((_uu.__slice__(_s, b + _n) : T_nat)).__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), _depth + ((1 : GoInt)), _tmp, _temps);
            _qhat = (_qhat._norm() == null ? null : _qhat._norm().__copy__());
            var _qhatv:T_nat = (_tmp._make(((3 : GoInt)) * _n) == null ? null : _tmp._make(((3 : GoInt)) * _n).__copy__());
            _qhatv._clear();
            _qhatv = (_qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())) == null ? null : _qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())).__copy__());
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < ((2 : GoInt)), _i++, {
                    var _e:GoInt = _qhatv._cmp((_uu._norm() == null ? null : _uu._norm().__copy__()));
                    if (_e <= ((0 : GoInt))) {
                        break;
                    };
                    _subVW(_qhat, _qhat, ((1 : GoUInt)));
                    var _c:Word = _subVV(((_qhatv.__slice__(0, _s) : T_nat)), ((_qhatv.__slice__(0, _s) : T_nat)), ((_v.__slice__(0, _s) : T_nat)));
                    if ((_qhatv != null ? _qhatv.length : ((0 : GoInt))) > _s) {
                        _subVW(((_qhatv.__slice__(_s) : T_nat)), ((_qhatv.__slice__(_s) : T_nat)), _c);
                    };
                    _addAt((((_uu.__slice__(_s) : T_nat)) == null ? null : ((_uu.__slice__(_s) : T_nat)).__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), ((0 : GoInt)));
                });
            };
            if (_qhatv._cmp((_uu._norm() == null ? null : _uu._norm().__copy__())) > ((0 : GoInt))) {
                throw Go.toInterface(((("impossible" : GoString))));
            };
            var _c:Word = _subVV(((_uu.__slice__(0, (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_uu.__slice__(0, (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _qhatv);
            if (_c > ((0 : GoUInt))) {
                _subVW(((_uu.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_uu.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _c);
            };
            _addAt((_z == null ? null : _z.__copy__()), (_qhat == null ? null : _qhat.__copy__()), _j - b);
            _j = _j - (b);
        };
        var _s:GoInt = b - ((1 : GoInt));
        var _qhat:T_nat = ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) == null ? null : (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))).__copy__());
        _qhat._clear();
        _qhat._divRecursiveStep((((_u.__slice__(_s) : T_nat))._norm() == null ? null : ((_u.__slice__(_s) : T_nat))._norm().__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), _depth + ((1 : GoInt)), _tmp, _temps);
        _qhat = (_qhat._norm() == null ? null : _qhat._norm().__copy__());
        var _qhatv:T_nat = (_tmp._make(((3 : GoInt)) * _n) == null ? null : _tmp._make(((3 : GoInt)) * _n).__copy__());
        _qhatv._clear();
        _qhatv = (_qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())) == null ? null : _qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((2 : GoInt)), _i++, {
                {
                    var _e:GoInt = _qhatv._cmp((_u._norm() == null ? null : _u._norm().__copy__()));
                    if (_e > ((0 : GoInt))) {
                        _subVW(_qhat, _qhat, ((1 : GoUInt)));
                        var _c:Word = _subVV(((_qhatv.__slice__(0, _s) : T_nat)), ((_qhatv.__slice__(0, _s) : T_nat)), ((_v.__slice__(0, _s) : T_nat)));
                        if ((_qhatv != null ? _qhatv.length : ((0 : GoInt))) > _s) {
                            _subVW(((_qhatv.__slice__(_s) : T_nat)), ((_qhatv.__slice__(_s) : T_nat)), _c);
                        };
                        _addAt((((_u.__slice__(_s) : T_nat)) == null ? null : ((_u.__slice__(_s) : T_nat)).__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), ((0 : GoInt)));
                    };
                };
            });
        };
        if (_qhatv._cmp((_u._norm() == null ? null : _u._norm().__copy__())) > ((0 : GoInt))) {
            throw Go.toInterface(((("impossible" : GoString))));
        };
        var _c:Word = _subVV(((_u.__slice__(((0 : GoInt)), (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_u.__slice__(((0 : GoInt)), (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _qhatv);
        if (_c > ((0 : GoUInt))) {
            _c = _subVW(((_u.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_u.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _c);
        };
        if (_c > ((0 : GoUInt))) {
            throw Go.toInterface(((("impossible" : GoString))));
        };
        _addAt((_z == null ? null : _z.__copy__()), (_qhat._norm() == null ? null : _qhat._norm().__copy__()), ((0 : GoInt)));
    }
    @:keep
    public function _divRecursive(_u:T_nat, _v:T_nat):Void {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _recDepth:GoInt = ((2 : GoInt)) * stdgo.math.bits.Bits.len((((_v != null ? _v.length : ((0 : GoInt))) : GoUInt)));
        var _tmp:Ref<T_nat> = _getNat(((3 : GoInt)) * (_v != null ? _v.length : ((0 : GoInt))));
        var _temps:Slice<Ref<T_nat>> = new Slice<Ref<T_nat>>(...[for (i in 0 ... ((_recDepth : GoInt)).toBasic()) ((null : Ref<T_nat>))]);
        _z._clear();
        _z._divRecursiveStep((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()), ((0 : GoInt)), _tmp, _temps);
        for (_0 => _n in _temps) {
            if (_n != null) {
                _putNat(_n);
            };
        };
        _putNat(_tmp);
    }
    @:keep
    public function _divBasic(_u:T_nat, _v:T_nat):Void {
        var _q = __t__;
        (_q == null ? null : _q.__copy__());
        var _n:GoInt = (_v != null ? _v.length : ((0 : GoInt)));
        var _m:GoInt = (_u != null ? _u.length : ((0 : GoInt))) - _n;
        var _qhatvp:Ref<T_nat> = _getNat(_n + ((1 : GoInt)));
        var _qhatv:T_nat = (_qhatvp == null ? null : _qhatvp.__copy__());
        var _vn1:Word = (_v != null ? _v[_n - ((1 : GoInt))] : new Word());
        var _rec:Word = _reciprocalWord(_vn1);
        {
            var _j:GoInt = _m;
            Go.cfor(_j >= ((0 : GoInt)), _j--, {
                var _qhat:Word = (((("4294967295" : GoUInt)) : Word));
                var _ujn:Word = new Word();
                if ((_j + _n) < (_u != null ? _u.length : ((0 : GoInt)))) {
                    _ujn = (_u != null ? _u[_j + _n] : new Word());
                };
                if (_ujn != _vn1) {
                    var _rhat:Word = new Word();
                    {
                        var __tmp__ = _divWW(_ujn, (_u != null ? _u[(_j + _n) - ((1 : GoInt))] : new Word()), _vn1, _rec);
                        _qhat = __tmp__._0;
                        _rhat = __tmp__._1;
                    };
                    var _vn2:Word = (_v != null ? _v[_n - ((2 : GoInt))] : new Word());
                    var __tmp__ = _mulWW(_qhat, _vn2), _x1:Word = __tmp__._0, _x2:Word = __tmp__._1;
                    var _ujn2:Word = (_u != null ? _u[(_j + _n) - ((2 : GoInt))] : new Word());
                    while (_greaterThan(_x1, _x2, _rhat, _ujn2)) {
                        _qhat--;
                        var _prevRhat:Word = _rhat;
                        _rhat = _rhat + (_vn1);
                        if (_rhat < _prevRhat) {
                            break;
                        };
                        {
                            var __tmp__ = _mulWW(_qhat, _vn2);
                            _x1 = __tmp__._0;
                            _x2 = __tmp__._1;
                        };
                    };
                };
                if (_qhatv != null) _qhatv[_n] = _mulAddVWW(((_qhatv.__slice__(((0 : GoInt)), _n) : T_nat)), _v, _qhat, ((0 : GoUInt)));
                var _qhl:GoInt = (_qhatv != null ? _qhatv.length : ((0 : GoInt)));
                if (((_j + _qhl) > (_u != null ? _u.length : ((0 : GoInt)))) && ((_qhatv != null ? _qhatv[_n] : new Word()) == ((0 : GoUInt)))) {
                    _qhl--;
                };
                var _c:Word = _subVV(((_u.__slice__(_j, _j + _qhl) : T_nat)), ((_u.__slice__(_j) : T_nat)), _qhatv);
                if (_c != ((0 : GoUInt))) {
                    var _c:Word = _addVV(((_u.__slice__(_j, _j + _n) : T_nat)), ((_u.__slice__(_j) : T_nat)), _v);
                    if (_n < _qhl) {
                        if (_u != null) (_u != null ? _u[_j + _n] : new Word()) + (_c);
                    };
                    _qhat--;
                };
                if (((_j == _m) && (_m == (_q != null ? _q.length : ((0 : GoInt))))) && (_qhat == ((0 : GoUInt)))) {
                    continue;
                };
                if (_q != null) _q[_j] = _qhat;
            });
        };
        _putNat(_qhatvp);
    }
    @:keep
    public function _divLarge(_u:T_nat, _uIn:T_nat, _vIn:T_nat):{ var _0 : T_nat; var _1 : T_nat; } {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _q:T_nat = new T_nat(), _r:T_nat = new T_nat();
        var _n:GoInt = (_vIn != null ? _vIn.length : ((0 : GoInt)));
        var _m:GoInt = (_uIn != null ? _uIn.length : ((0 : GoInt))) - _n;
        var _shift:GoUInt = _nlz((_vIn != null ? _vIn[_n - ((1 : GoInt))] : new Word()));
        var _vp:Ref<T_nat> = _getNat(_n);
        var _v:T_nat = (_vp == null ? null : _vp.__copy__());
        _shlVU(_v, _vIn, _shift);
        _u = (_u._make((_uIn != null ? _uIn.length : ((0 : GoInt))) + ((1 : GoInt))) == null ? null : _u._make((_uIn != null ? _uIn.length : ((0 : GoInt))) + ((1 : GoInt))).__copy__());
        if (_u != null) _u[(_uIn != null ? _uIn.length : ((0 : GoInt)))] = _shlVU(((_u.__slice__(((0 : GoInt)), (_uIn != null ? _uIn.length : ((0 : GoInt)))) : T_nat)), _uIn, _shift);
        if (_alias((_z == null ? null : _z.__copy__()), (_u == null ? null : _u.__copy__()))) {
            _z = null;
        };
        _q = (_z._make(_m + ((1 : GoInt))) == null ? null : _z._make(_m + ((1 : GoInt))).__copy__());
        if (_n < ((100 : GoInt))) {
            _q._divBasic((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
        } else {
            _q._divRecursive((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
        };
        _putNat(_vp);
        _q = (_q._norm() == null ? null : _q._norm().__copy__());
        _shrVU(_u, _u, _shift);
        _r = (_u._norm() == null ? null : _u._norm().__copy__());
        return { _0 : (_q == null ? null : _q.__copy__()), _1 : (_r == null ? null : _r.__copy__()) };
    }
    @:keep
    public function _modW(_d:Word):Word {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        var _r:Word = new Word();
        var _q:T_nat = new T_nat();
        _q = (_q._make((_x != null ? _x.length : ((0 : GoInt)))) == null ? null : _q._make((_x != null ? _x.length : ((0 : GoInt)))).__copy__());
        return _divWVW(_q, ((0 : GoUInt)), _x, _d);
    }
    @:keep
    public function _divW(_x:T_nat, _y:Word):{ var _0 : T_nat; var _1 : Word; } {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _q:T_nat = new T_nat(), _r:Word = new Word();
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_y == ((0 : GoUInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        } else if (_y == ((1 : GoUInt))) {
            _q = (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
            return { _0 : _q, _1 : _r };
        } else if (_m == ((0 : GoInt))) {
            _q = (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            return { _0 : _q, _1 : _r };
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        _r = _divWVW(_z, ((0 : GoUInt)), _x, _y);
        _q = (_z._norm() == null ? null : _z._norm().__copy__());
        return { _0 : _q, _1 : _r };
    }
    @:keep
    public function _div(_z2:T_nat, _u:T_nat, _v:T_nat):{ var _0 : T_nat; var _1 : T_nat; } {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _q:T_nat = new T_nat(), _r:T_nat = new T_nat();
        if ((_v != null ? _v.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        if (_u._cmp((_v == null ? null : _v.__copy__())) < ((0 : GoInt))) {
            _q = (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            _r = (_z2._set((_u == null ? null : _u.__copy__())) == null ? null : _z2._set((_u == null ? null : _u.__copy__())).__copy__());
            return { _0 : _q, _1 : _r };
        };
        if ((_v != null ? _v.length : ((0 : GoInt))) == ((1 : GoInt))) {
            var _r2:Word = new Word();
            {
                var __tmp__ = _z._divW((_u == null ? null : _u.__copy__()), (_v != null ? _v[((0 : GoInt))] : new Word()));
                _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                _r2 = __tmp__._1;
            };
            _r = (_z2._setWord(_r2) == null ? null : _z2._setWord(_r2).__copy__());
            return { _0 : _q, _1 : _r };
        };
        {
            var __tmp__ = _z._divLarge((_z2 == null ? null : _z2.__copy__()), (_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
            _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        return { _0 : _q, _1 : _r };
    }
    @:keep
    public function _expWW(_x:Word, _y:Word):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        return (_z._expNN((((new T_nat() : T_nat))._setWord(_x) == null ? null : ((new T_nat() : T_nat))._setWord(_x).__copy__()), (((new T_nat() : T_nat))._setWord(_y) == null ? null : ((new T_nat() : T_nat))._setWord(_y).__copy__()), null) == null ? null : _z._expNN((((new T_nat() : T_nat))._setWord(_x) == null ? null : ((new T_nat() : T_nat))._setWord(_x).__copy__()), (((new T_nat() : T_nat))._setWord(_y) == null ? null : ((new T_nat() : T_nat))._setWord(_y).__copy__()), null).__copy__());
    }
    @:keep
    public function _convertWords(_s:Slice<GoByte>, _b:Word, _ndigits:GoInt, _bb:Word, _table:Slice<T_divisor>):Void {
        var _q = __t__;
        (_q == null ? null : _q.__copy__());
        if (_table != null) {
            var _r:T_nat = new T_nat();
            var _index:GoInt = (_table != null ? _table.length : ((0 : GoInt))) - ((1 : GoInt));
            while ((_q != null ? _q.length : ((0 : GoInt))) > _leafSize) {
                var _maxLength:GoInt = _q._bitLen();
                var _minLength:GoInt = _maxLength >> ((1 : GoUnTypedInt));
                while ((_index > ((0 : GoInt))) && ((_table != null ? _table[_index - ((1 : GoInt))] : new T_divisor())._nbits > _minLength)) {
                    _index--;
                };
                if (((_table != null ? _table[_index] : new T_divisor())._nbits >= _maxLength) && ((_table != null ? _table[_index] : new T_divisor())._bbb._cmp((_q == null ? null : _q.__copy__())) >= ((0 : GoInt)))) {
                    _index--;
                    if (_index < ((0 : GoInt))) {
                        throw Go.toInterface(((("internal inconsistency" : GoString))));
                    };
                };
                {
                    var __tmp__ = _q._div((_r == null ? null : _r.__copy__()), (_q == null ? null : _q.__copy__()), ((_table != null ? _table[_index] : new T_divisor())._bbb == null ? null : (_table != null ? _table[_index] : new T_divisor())._bbb.__copy__()));
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                var _h:GoInt = (_s != null ? _s.length : ((0 : GoInt))) - (_table != null ? _table[_index] : new T_divisor())._ndigits;
                _r._convertWords(((_s.__slice__(_h) : Slice<GoUInt8>)), _b, _ndigits, _bb, ((_table.__slice__(((0 : GoInt)), _index) : Slice<T_divisor>)));
                _s = ((_s.__slice__(0, _h) : Slice<GoUInt8>));
            };
        };
        var _i:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        var _r:Word = new Word();
        if (_b == ((10 : GoUInt))) {
            while ((_q != null ? _q.length : ((0 : GoInt))) > ((0 : GoInt))) {
                {
                    var __tmp__ = _q._divW((_q == null ? null : _q.__copy__()), _bb);
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = __tmp__._1;
                };
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor((_j < _ndigits) && (_i > ((0 : GoInt))), _j++, {
                        _i--;
                        var _t:Word = _r / ((10 : GoUInt));
                        if (_s != null) _s[_i] = ((((("0" : GoString))).code : GoRune)) + (((_r - (_t * ((10 : GoUInt)))) : GoByte));
                        _r = _t;
                    });
                };
            };
        } else {
            while ((_q != null ? _q.length : ((0 : GoInt))) > ((0 : GoInt))) {
                {
                    var __tmp__ = _q._divW((_q == null ? null : _q.__copy__()), _bb);
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = __tmp__._1;
                };
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor((_j < _ndigits) && (_i > ((0 : GoInt))), _j++, {
                        _i--;
                        if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_r % _b] : ((0 : GoUInt8)));
                        _r = _r / (_b);
                    });
                };
            };
        };
        while (_i > ((0 : GoInt))) {
            _i--;
            if (_s != null) _s[_i] = ((((("0" : GoString))).code : GoRune));
        };
    }
    @:keep
    public function _itoa(_neg:Bool, _base:GoInt):Slice<GoByte> {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        if ((_base < ((2 : GoInt))) || (_base > ((62 : GoInt)))) {
            throw Go.toInterface(((("invalid base" : GoString))));
        };
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((((("0" : GoString))) : Slice<GoByte>));
        };
        var _i:GoInt = (((((_x._bitLen() : GoFloat64)) / stdgo.math.Math.log2(((_base : GoFloat64)))) : GoInt)) + ((1 : GoInt));
        if (_neg) {
            _i++;
        };
        var _s:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_i : GoInt)).toBasic()) ((0 : GoUInt8))]);
        {
            var _b:Word = ((_base : Word));
            if (_b == (_b & -_b)) {
                var _shift:GoUInt = ((stdgo.math.bits.Bits.trailingZeros(((_b : GoUInt))) : GoUInt));
                var _mask:Word = ((((((1 : GoUInt)) << _shift) - ((1 : GoUInt))) : Word));
                var _w:Word = (_x != null ? _x[((0 : GoInt))] : new Word());
                var _nbits:GoUInt = ((((32 : GoUInt)) : GoUInt));
                {
                    var _k:GoInt = ((1 : GoInt));
                    Go.cfor(_k < (_x != null ? _x.length : ((0 : GoInt))), _k++, {
                        while (_nbits >= _shift) {
                            _i--;
                            if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_w & _mask] : ((0 : GoUInt8)));
                            _w = _w >> (_shift);
                            _nbits = _nbits - (_shift);
                        };
                        if (_nbits == ((0 : GoUInt))) {
                            _w = (_x != null ? _x[_k] : new Word());
                            _nbits = ((32 : GoUInt));
                        } else {
                            _w = _w | ((_x != null ? _x[_k] : new Word()) << _nbits);
                            _i--;
                            if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_w & _mask] : ((0 : GoUInt8)));
                            _w = (_x != null ? _x[_k] : new Word()) >> (_shift - _nbits);
                            _nbits = ((32 : GoUInt)) - (_shift - _nbits);
                        };
                    });
                };
                while (_w != ((0 : GoUInt))) {
                    _i--;
                    if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_w & _mask] : ((0 : GoUInt8)));
                    _w = _w >> (_shift);
                };
            } else {
                var __tmp__ = _maxPow(_b), _bb:Word = __tmp__._0, _ndigits:GoInt = __tmp__._1;
                var _table:Slice<T_divisor> = _divisors((_x != null ? _x.length : ((0 : GoInt))), _b, _ndigits, _bb);
                var _q:T_nat = (((new T_nat() : T_nat))._set((_x == null ? null : _x.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_x == null ? null : _x.__copy__())).__copy__());
                _q._convertWords(_s, _b, _ndigits, _bb, _table);
                _i = ((0 : GoInt));
                while ((_s != null ? _s[_i] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune))) {
                    _i++;
                };
            };
        };
        if (_neg) {
            _i--;
            if (_s != null) _s[_i] = ((((("-" : GoString))).code : GoRune));
        };
        return ((_s.__slice__(_i) : Slice<GoUInt8>));
    }
    @:keep
    public function _utoa(_base:GoInt):Slice<GoByte> {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        return _x._itoa(false, _base);
    }
    @:keep
    public function _scan(_r:stdgo.io.Io.ByteScanner, _base:GoInt, _fracOk:Bool):{ var _0 : T_nat; var _1 : GoInt; var _2 : GoInt; var _3 : Error; } {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _res:T_nat = new T_nat(), _b:GoInt = ((0 : GoInt)), _count:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        var _baseOk:Bool = ((_base == ((0 : GoInt))) || ((!_fracOk && (((2 : GoInt)) <= _base)) && (_base <= ((62 : GoInt))))) || (_fracOk && ((((_base == ((2 : GoInt))) || (_base == ((8 : GoInt)))) || (_base == ((10 : GoInt)))) || (_base == ((16 : GoInt)))));
        if (!_baseOk) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("invalid number base %d" : GoString))), Go.toInterface(_base)));
        };
        var _prev:GoInt32 = ((((("." : GoString))).code : GoRune));
        var _invalSep:Bool = false;
        var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        var _b:GoInt = _base, _prefix:GoInt = ((0 : GoInt));
        if (_base == ((0 : GoInt))) {
            _b = ((10 : GoInt));
            if ((_err == null) && (_ch == ((((("0" : GoString))).code : GoRune)))) {
                _prev = ((((("0" : GoString))).code : GoRune));
                _count = ((1 : GoInt));
                {
                    var __tmp__ = _r.readByte();
                    _ch = __tmp__._0;
                    _err = __tmp__._1;
                };
                if (_err == null) {
                    if (_ch == ((((("b" : GoString))).code : GoRune)) || _ch == ((((("B" : GoString))).code : GoRune))) {
                        {
                            final __tmp__0 = ((2 : GoInt));
                            final __tmp__1 = ((((("b" : GoString))).code : GoRune));
                            _b = __tmp__0;
                            _prefix = __tmp__1;
                        };
                    } else if (_ch == ((((("o" : GoString))).code : GoRune)) || _ch == ((((("O" : GoString))).code : GoRune))) {
                        {
                            final __tmp__0 = ((8 : GoInt));
                            final __tmp__1 = ((((("o" : GoString))).code : GoRune));
                            _b = __tmp__0;
                            _prefix = __tmp__1;
                        };
                    } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
                        {
                            final __tmp__0 = ((16 : GoInt));
                            final __tmp__1 = ((((("x" : GoString))).code : GoRune));
                            _b = __tmp__0;
                            _prefix = __tmp__1;
                        };
                    } else {
                        if (!_fracOk) {
                            {
                                final __tmp__0 = ((8 : GoInt));
                                final __tmp__1 = ((((("0" : GoString))).code : GoRune));
                                _b = __tmp__0;
                                _prefix = __tmp__1;
                            };
                        };
                    };
                    if (_prefix != ((0 : GoInt))) {
                        _count = ((0 : GoInt));
                        if (_prefix != ((((("0" : GoString))).code : GoRune))) {
                            {
                                var __tmp__ = _r.readByte();
                                _ch = __tmp__._0;
                                _err = __tmp__._1;
                            };
                        };
                    };
                };
            };
        };
        _z = (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        var _b1:Word = ((_b : Word));
        var __tmp__ = _maxPow(_b1), _bn:Word = __tmp__._0, _n:GoInt = __tmp__._1;
        var _di:Word = ((((0 : GoUInt)) : Word));
        var _i:GoInt = ((0 : GoInt));
        var _dp:GoInt = ((-1 : GoInt));
        while (_err == null) {
            if ((_ch == ((((("." : GoString))).code : GoRune))) && _fracOk) {
                _fracOk = false;
                if (_prev == ((((("_" : GoString))).code : GoRune))) {
                    _invalSep = true;
                };
                _prev = ((((("." : GoString))).code : GoRune));
                _dp = _count;
            } else if ((_ch == ((((("_" : GoString))).code : GoRune))) && (_base == ((0 : GoInt)))) {
                if (_prev != ((((("0" : GoString))).code : GoRune))) {
                    _invalSep = true;
                };
                _prev = ((((("_" : GoString))).code : GoRune));
            } else {
                var _d1:Word = new Word();
                if ((((((("0" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("9" : GoString))).code : GoRune)))) {
                    _d1 = (((_ch - ((((("0" : GoString))).code : GoRune))) : Word));
                } else if ((((((("a" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("z" : GoString))).code : GoRune)))) {
                    _d1 = ((((_ch - ((((("a" : GoString))).code : GoRune))) + ((10 : GoUInt8))) : Word));
                } else if ((((((("A" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("Z" : GoString))).code : GoRune)))) {
                    if (_b <= ((36 : GoInt))) {
                        _d1 = ((((_ch - ((((("A" : GoString))).code : GoRune))) + ((10 : GoUInt8))) : Word));
                    } else {
                        _d1 = ((((_ch - ((((("A" : GoString))).code : GoRune))) + ((36 : GoUInt8))) : Word));
                    };
                } else {
                    _d1 = ((63 : GoUInt));
                };
                if (_d1 >= _b1) {
                    _r.unreadByte();
                    break;
                };
                _prev = ((((("0" : GoString))).code : GoRune));
                _count++;
                _di = (_di * _b1) + _d1;
                _i++;
                if (_i == _n) {
                    _z = (_z._mulAddWW((_z == null ? null : _z.__copy__()), _bn, _di) == null ? null : _z._mulAddWW((_z == null ? null : _z.__copy__()), _bn, _di).__copy__());
                    _di = ((0 : GoUInt));
                    _i = ((0 : GoInt));
                };
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if (_err == stdgo.io.Io.eof) {
            _err = ((null : stdgo.Error));
        };
        if ((_err == null) && (_invalSep || (_prev == ((((("_" : GoString))).code : GoRune))))) {
            _err = _errInvalSep;
        };
        if (_count == ((0 : GoInt))) {
            if (_prefix == ((((("0" : GoString))).code : GoRune))) {
                return { _0 : (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__()), _1 : ((10 : GoInt)), _2 : ((1 : GoInt)), _3 : _err };
            };
            _err = _errNoDigits;
        };
        if (_i > ((0 : GoInt))) {
            _z = (_z._mulAddWW((_z == null ? null : _z.__copy__()), _pow(_b1, _i), _di) == null ? null : _z._mulAddWW((_z == null ? null : _z.__copy__()), _pow(_b1, _i), _di).__copy__());
        };
        _res = (_z._norm() == null ? null : _z._norm().__copy__());
        if (_dp >= ((0 : GoInt))) {
            _count = _dp - _count;
        };
        return { _0 : _res, _1 : _b, _2 : _count, _3 : _err };
    }
    @:keep
    public function _sqrt(_x:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_x._cmp((_natOne == null ? null : _natOne.__copy__())) <= ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
            _z = null;
        };
        var _z1:T_nat = new T_nat(), _z2:T_nat = new T_nat();
        _z1 = (_z == null ? null : _z.__copy__());
        _z1 = (_z1._setUint64(((1 : GoUInt64))) == null ? null : _z1._setUint64(((1 : GoUInt64))).__copy__());
        _z1 = (_z1._shl((_z1 == null ? null : _z1.__copy__()), (((_x._bitLen() + ((1 : GoInt))) : GoUInt)) / ((2 : GoUInt))) == null ? null : _z1._shl((_z1 == null ? null : _z1.__copy__()), (((_x._bitLen() + ((1 : GoInt))) : GoUInt)) / ((2 : GoUInt))).__copy__());
        {
            var _n:GoInt = ((0 : GoInt));
            Go.cfor(true, _n++, {
                {
                    var __tmp__ = _z2._div(null, (_x == null ? null : _x.__copy__()), (_z1 == null ? null : _z1.__copy__()));
                    _z2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                };
                _z2 = (_z2._add((_z2 == null ? null : _z2.__copy__()), (_z1 == null ? null : _z1.__copy__())) == null ? null : _z2._add((_z2 == null ? null : _z2.__copy__()), (_z1 == null ? null : _z1.__copy__())).__copy__());
                _z2 = (_z2._shr((_z2 == null ? null : _z2.__copy__()), ((1 : GoUInt))) == null ? null : _z2._shr((_z2 == null ? null : _z2.__copy__()), ((1 : GoUInt))).__copy__());
                if (_z2._cmp((_z1 == null ? null : _z1.__copy__())) >= ((0 : GoInt))) {
                    if ((_n & ((1 : GoInt))) == ((0 : GoInt))) {
                        return (_z1 == null ? null : _z1.__copy__());
                    };
                    return (_z._set((_z1 == null ? null : _z1.__copy__())) == null ? null : _z._set((_z1 == null ? null : _z1.__copy__())).__copy__());
                };
                {
                    final __tmp__0 = (_z2 == null ? null : _z2.__copy__());
                    final __tmp__1 = (_z1 == null ? null : _z1.__copy__());
                    _z1 = __tmp__0;
                    _z2 = __tmp__1;
                };
            });
        };
    }
    @:keep
    public function _setBytes(_buf:Slice<GoByte>):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        _z = (_z._make((((_buf != null ? _buf.length : ((0 : GoInt))) + ((4 : GoInt))) - ((1 : GoInt))) / ((4 : GoInt))) == null ? null : _z._make((((_buf != null ? _buf.length : ((0 : GoInt))) + ((4 : GoInt))) - ((1 : GoInt))) / ((4 : GoInt))).__copy__());
        var _i:GoInt = (_buf != null ? _buf.length : ((0 : GoInt)));
        {
            var _k:GoInt = ((0 : GoInt));
            Go.cfor(_i >= ((4 : GoInt)), _k++, {
                if (_z != null) _z[_k] = _bigEndianWord(((_buf.__slice__(_i - ((4 : GoInt)), _i) : Slice<GoUInt8>)));
                _i = _i - (((4 : GoInt)));
            });
        };
        if (_i > ((0 : GoInt))) {
            var _d:Word = new Word();
            {
                var _s:GoUInt = ((((0 : GoUInt)) : GoUInt));
                Go.cfor(_i > ((0 : GoInt)), _s = _s + (((8 : GoUInt))), {
                    _d = _d | ((((_buf != null ? _buf[_i - ((1 : GoInt))] : ((0 : GoUInt8))) : Word)) << _s);
                    _i--;
                });
            };
            if (_z != null) _z[(_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt))] = _d;
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _bytes(_buf:Slice<GoByte>):GoInt {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _i:GoInt = ((0 : GoInt));
        _i = (_buf != null ? _buf.length : ((0 : GoInt)));
        for (_0 => _d in _z) {
            {
                var _j:GoInt = ((0 : GoInt));
                Go.cfor(_j < ((4 : GoInt)), _j++, {
                    _i--;
                    if (_i >= ((0 : GoInt))) {
                        if (_buf != null) _buf[_i] = ((_d : GoByte));
                    } else if (((_d : GoByte)) != ((0 : GoUInt8))) {
                        throw Go.toInterface(((("math/big: buffer too small to fit value" : GoString))));
                    };
                    _d = _d >> (((8 : GoUnTypedInt)));
                });
            };
        };
        if (_i < ((0 : GoInt))) {
            _i = ((0 : GoInt));
        };
        while ((_i < (_buf != null ? _buf.length : ((0 : GoInt)))) && ((_buf != null ? _buf[_i] : ((0 : GoUInt8))) == ((0 : GoUInt8)))) {
            _i++;
        };
        return _i;
    }
    @:keep
    public function _expNNMontgomery(_x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _numWords:GoInt = (_m != null ? _m.length : ((0 : GoInt)));
        if ((_x != null ? _x.length : ((0 : GoInt))) > _numWords) {
            {
                var __tmp__ = ((new T_nat() : T_nat))._div(null, (_x == null ? null : _x.__copy__()), (_m == null ? null : _m.__copy__()));
                _x = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
            };
        };
        if ((_x != null ? _x.length : ((0 : GoInt))) < _numWords) {
            var _rr:T_nat = new Slice<Word>(...[for (i in 0 ... ((_numWords : GoInt)).toBasic()) new Word()]);
            Go.copySlice(_rr, _x);
            _x = (_rr == null ? null : _rr.__copy__());
        };
        var _k0:Word = ((2 : GoUInt)) - (_m != null ? _m[((0 : GoInt))] : new Word());
        var _t:Word = (_m != null ? _m[((0 : GoInt))] : new Word()) - ((1 : GoUInt));
        {
            var _i:GoInt = ((1 : GoInt));
            Go.cfor(_i < ((32 : GoInt)), _i = _i << (((1 : GoUnTypedInt))), {
                _t = _t * (_t);
                _k0 = _k0 * ((_t + ((1 : GoUInt))));
            });
        };
        _k0 = -_k0;
        var rr:T_nat = (((new T_nat() : T_nat))._setWord(((1 : GoUInt))) == null ? null : ((new T_nat() : T_nat))._setWord(((1 : GoUInt))).__copy__());
        var _zz:T_nat = (((new T_nat() : T_nat))._shl((rr == null ? null : rr.__copy__()), ((((((2 : GoInt)) * _numWords) * ((32 : GoInt))) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((rr == null ? null : rr.__copy__()), ((((((2 : GoInt)) * _numWords) * ((32 : GoInt))) : GoUInt))).__copy__());
        {
            var __tmp__ = ((new T_nat() : T_nat))._div((rr == null ? null : rr.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()));
            rr = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        if ((rr != null ? rr.length : ((0 : GoInt))) < _numWords) {
            _zz = (_zz._make(_numWords) == null ? null : _zz._make(_numWords).__copy__());
            Go.copySlice(_zz, rr);
            rr = (_zz == null ? null : _zz.__copy__());
        };
        var _one:T_nat = new Slice<Word>(...[for (i in 0 ... ((_numWords : GoInt)).toBasic()) new Word()]);
        if (_one != null) _one[((0 : GoInt))] = ((1 : GoUInt));
        {};
        var _powers:GoArray<T_nat> = new GoArray<T_nat>(...[for (i in 0 ... 16) new T_nat()]);
        if (_powers != null) _powers[((0 : GoInt))] = ((_powers != null ? _powers[((0 : GoInt))] : new T_nat())._montgomery((_one == null ? null : _one.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : (_powers != null ? _powers[((0 : GoInt))] : new T_nat())._montgomery((_one == null ? null : _one.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
        if (_powers != null) _powers[((1 : GoInt))] = ((_powers != null ? _powers[((1 : GoInt))] : new T_nat())._montgomery((_x == null ? null : _x.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : (_powers != null ? _powers[((1 : GoInt))] : new T_nat())._montgomery((_x == null ? null : _x.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
        {
            var _i:GoInt = ((2 : GoInt));
            Go.cfor(_i < ((16 : GoInt)), _i++, {
                if (_powers != null) _powers[_i] = ((_powers != null ? _powers[_i] : new T_nat())._montgomery(((_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()).__copy__()), ((_powers != null ? _powers[((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[((1 : GoInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : (_powers != null ? _powers[_i] : new T_nat())._montgomery(((_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()).__copy__()), ((_powers != null ? _powers[((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[((1 : GoInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
            });
        };
        _z = (_z._make(_numWords) == null ? null : _z._make(_numWords).__copy__());
        Go.copySlice(_z, (_powers != null ? _powers[((0 : GoInt))] : new T_nat()));
        _zz = (_zz._make(_numWords) == null ? null : _zz._make(_numWords).__copy__());
        {
            var _i:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                var _yi:Word = (_y != null ? _y[_i] : new Word());
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < ((32 : GoInt)), _j = _j + (((4 : GoInt))), {
                        if ((_i != ((_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt)))) || (_j != ((0 : GoInt)))) {
                            _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                            _z = (_z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                            _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                            _z = (_z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                        };
                        _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                        {
                            final __tmp__0 = (_zz == null ? null : _zz.__copy__());
                            final __tmp__1 = (_z == null ? null : _z.__copy__());
                            _z = __tmp__0;
                            _zz = __tmp__1;
                        };
                        _yi = _yi << (((4 : GoUnTypedInt)));
                    });
                };
            });
        };
        _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), (_one == null ? null : _one.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), (_one == null ? null : _one.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
        if (_zz._cmp((_m == null ? null : _m.__copy__())) >= ((0 : GoInt))) {
            _zz = (_zz._sub((_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : _zz._sub((_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
            if (_zz._cmp((_m == null ? null : _m.__copy__())) >= ((0 : GoInt))) {
                {
                    var __tmp__ = ((new T_nat() : T_nat))._div(null, (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()));
                    _zz = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
            };
        };
        return (_zz._norm() == null ? null : _zz._norm().__copy__());
    }
    @:keep
    public function _expNNWindowed(_x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _zz:T_nat = new T_nat(), _r:T_nat = new T_nat();
        {};
        var _powers:GoArray<T_nat> = new GoArray<T_nat>(...[for (i in 0 ... 16) new T_nat()]);
        if (_powers != null) _powers[((0 : GoInt))] = (_natOne == null ? null : _natOne.__copy__());
        if (_powers != null) _powers[((1 : GoInt))] = (_x == null ? null : _x.__copy__());
        {
            var _i:GoInt = ((2 : GoInt));
            Go.cfor(_i < ((16 : GoInt)), _i = _i + (((2 : GoInt))), {
                var _p2:Ref<T_nat> = (_powers != null ? _powers[_i / ((2 : GoInt))] : new T_nat()), _p:Ref<T_nat> = (_powers != null ? _powers[_i] : new T_nat()), _p1:Ref<T_nat> = (_powers != null ? _powers[_i + ((1 : GoInt))] : new T_nat());
                _p = (_p._sqr((_p2 == null ? null : _p2.__copy__())) == null ? null : _p._sqr((_p2 == null ? null : _p2.__copy__())).__copy__());
                {
                    var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__()), (_m == null ? null : _m.__copy__()));
                    _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                {
                    final __tmp__0 = (_r == null ? null : _r.__copy__());
                    final __tmp__1 = (_p == null ? null : _p.__copy__());
                    _p = __tmp__0;
                    _r = __tmp__1;
                };
                _p1 = (_p1._mul((_p == null ? null : _p.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _p1._mul((_p == null ? null : _p.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
                {
                    var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_p1 == null ? null : _p1.__copy__()), (_m == null ? null : _m.__copy__()));
                    _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                {
                    final __tmp__0 = (_r == null ? null : _r.__copy__());
                    final __tmp__1 = (_p1 == null ? null : _p1.__copy__());
                    _p1 = __tmp__0;
                    _r = __tmp__1;
                };
            });
        };
        _z = (_z._setWord(((1 : GoUInt))) == null ? null : _z._setWord(((1 : GoUInt))).__copy__());
        {
            var _i:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                var _yi:Word = (_y != null ? _y[_i] : new Word());
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < ((32 : GoInt)), _j = _j + (((4 : GoInt))), {
                        if ((_i != ((_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt)))) || (_j != ((0 : GoInt)))) {
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                        };
                        _zz = (_zz._mul((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__())) == null ? null : _zz._mul((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__())).__copy__());
                        {
                            final __tmp__0 = (_z == null ? null : _z.__copy__());
                            final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        {
                            var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                            _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                        };
                        {
                            final __tmp__0 = (_r == null ? null : _r.__copy__());
                            final __tmp__1 = (_z == null ? null : _z.__copy__());
                            _z = __tmp__0;
                            _r = __tmp__1;
                        };
                        _yi = _yi << (((4 : GoUnTypedInt)));
                    });
                };
            });
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _expNN(_x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) || _alias((_z == null ? null : _z.__copy__()), (_y == null ? null : _y.__copy__()))) {
            _z = null;
        };
        if (((_m != null ? _m.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_m != null ? _m[((0 : GoInt))] : new Word()) == ((1 : GoUInt)))) {
            return (_z._setWord(((0 : GoUInt))) == null ? null : _z._setWord(((0 : GoUInt))).__copy__());
        };
        if ((_y != null ? _y.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (_z._setWord(((1 : GoUInt))) == null ? null : _z._setWord(((1 : GoUInt))).__copy__());
        };
        if ((((_y != null ? _y.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_y != null ? _y[((0 : GoInt))] : new Word()) == ((1 : GoUInt)))) && ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt)))) {
            {
                var __tmp__ = ((new T_nat() : T_nat))._div((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_m == null ? null : _m.__copy__()));
                _z = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
            };
            return (_z == null ? null : _z.__copy__());
        };
        if ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt))) {
            _z = (_z._make((_m != null ? _m.length : ((0 : GoInt)))) == null ? null : _z._make((_m != null ? _m.length : ((0 : GoInt)))).__copy__());
        };
        _z = (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        if (((_x._cmp((_natOne == null ? null : _natOne.__copy__())) > ((0 : GoInt))) && ((_y != null ? _y.length : ((0 : GoInt))) > ((1 : GoInt)))) && ((_m != null ? _m.length : ((0 : GoInt))) > ((0 : GoInt)))) {
            if (((_m != null ? _m[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((1 : GoUInt))) {
                return (_z._expNNMontgomery((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : _z._expNNMontgomery((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
            };
            return (_z._expNNWindowed((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : _z._expNNWindowed((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
        };
        var _v:Word = (_y != null ? _y[(_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word());
        var _shift:GoUInt = _nlz(_v) + ((1 : GoUInt));
        _v = _v << (_shift);
        var _q:T_nat = new T_nat();
        {};
        var _w:GoInt = ((32 : GoInt)) - ((_shift : GoInt));
        var _zz:T_nat = new T_nat(), _r:T_nat = new T_nat();
        {
            var _j:GoInt = ((0 : GoInt));
            Go.cfor(_j < _w, _j++, {
                _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                {
                    final __tmp__0 = (_z == null ? null : _z.__copy__());
                    final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                    _zz = __tmp__0;
                    _z = __tmp__1;
                };
                if ((_v & (("2147483648" : GoUInt))) != ((0 : GoUInt))) {
                    _zz = (_zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
                    {
                        final __tmp__0 = (_z == null ? null : _z.__copy__());
                        final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                        _zz = __tmp__0;
                        _z = __tmp__1;
                    };
                };
                if ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt))) {
                    {
                        var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                        _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                    {
                        final __tmp__0 = (_q == null ? null : _q.__copy__());
                        final __tmp__1 = (_z == null ? null : _z.__copy__());
                        final __tmp__2 = (_zz == null ? null : _zz.__copy__());
                        final __tmp__3 = (_r == null ? null : _r.__copy__());
                        _zz = __tmp__0;
                        _r = __tmp__1;
                        _q = __tmp__2;
                        _z = __tmp__3;
                    };
                };
                _v = _v << (((1 : GoUnTypedInt)));
            });
        };
        {
            var _i:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((2 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _v = (_y != null ? _y[_i] : new Word());
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < ((32 : GoInt)), _j++, {
                        _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                        {
                            final __tmp__0 = (_z == null ? null : _z.__copy__());
                            final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        if ((_v & (("2147483648" : GoUInt))) != ((0 : GoUInt))) {
                            _zz = (_zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                        };
                        if ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_q == null ? null : _q.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                final __tmp__2 = (_zz == null ? null : _zz.__copy__());
                                final __tmp__3 = (_r == null ? null : _r.__copy__());
                                _zz = __tmp__0;
                                _r = __tmp__1;
                                _q = __tmp__2;
                                _z = __tmp__3;
                            };
                        };
                        _v = _v << (((1 : GoUnTypedInt)));
                    });
                };
            });
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _random(_rand:stdgo.math.rand.Rand.Rand, _limit:T_nat, _n:GoInt):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_alias((_z == null ? null : _z.__copy__()), (_limit == null ? null : _limit.__copy__()))) {
            _z = null;
        };
        _z = (_z._make((_limit != null ? _limit.length : ((0 : GoInt)))) == null ? null : _z._make((_limit != null ? _limit.length : ((0 : GoInt)))).__copy__());
        var _bitLengthOfMSW:GoUInt = (((_n % ((32 : GoInt))) : GoUInt));
        if (_bitLengthOfMSW == ((0 : GoUInt))) {
            _bitLengthOfMSW = ((32 : GoUInt));
        };
        var _mask:Word = ((((((1 : GoUInt)) << _bitLengthOfMSW) - ((1 : GoUInt))) : Word));
        while (true) {
            if (((32 : GoInt)) == ((32 : GoInt))) {
                for (_i => _ in _z) {
                    if (_z != null) _z[_i] = ((_rand.uint32() : Word));
                };
            } else if (((32 : GoInt)) == ((64 : GoInt))) {
                for (_i => _ in _z) {
                    if (_z != null) _z[_i] = ((_rand.uint32() : Word)) | (((_rand.uint32() : Word)) << ((32 : GoUnTypedInt)));
                };
            } else {
                throw Go.toInterface(((("unknown word size" : GoString))));
            };
            if (_z != null) (_z != null ? _z[(_limit != null ? _limit.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) & (_mask);
            if (_z._cmp((_limit == null ? null : _limit.__copy__())) < ((0 : GoInt))) {
                break;
            };
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _xor(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        var _s:T_nat = (_x == null ? null : _x.__copy__());
        if (_m < _n) {
            {
                final __tmp__0 = _m;
                final __tmp__1 = _n;
                _n = __tmp__0;
                _m = __tmp__1;
            };
            _s = (_y == null ? null : _y.__copy__());
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) ^ (_y != null ? _y[_i] : new Word());
            });
        };
        Go.copySlice(((_z.__slice__(_n, _m) : T_nat)), ((_s.__slice__(_n, _m) : T_nat)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _or(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        var _s:T_nat = (_x == null ? null : _x.__copy__());
        if (_m < _n) {
            {
                final __tmp__0 = _m;
                final __tmp__1 = _n;
                _n = __tmp__0;
                _m = __tmp__1;
            };
            _s = (_y == null ? null : _y.__copy__());
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) | (_y != null ? _y[_i] : new Word());
            });
        };
        Go.copySlice(((_z.__slice__(_n, _m) : T_nat)), ((_s.__slice__(_n, _m) : T_nat)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _andNot(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_n > _m) {
            _n = _m;
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) & ((_y != null ? _y[_i] : new Word()) ^ ((-1 : GoUnTypedInt)));
            });
        };
        Go.copySlice(((_z.__slice__(_n, _m) : T_nat)), ((_x.__slice__(_n, _m) : T_nat)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _and(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m > _n) {
            _m = _n;
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _m, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) & (_y != null ? _y[_i] : new Word());
            });
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _sticky(_i:GoUInt):GoUInt {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        var _j:GoUInt = _i / ((32 : GoUInt));
        if (_j >= (((_x != null ? _x.length : ((0 : GoInt))) : GoUInt))) {
            if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
                return ((0 : GoUInt));
            };
            return ((1 : GoUInt));
        };
        for (_0 => _x in ((_x.__slice__(0, _j) : T_nat))) {
            if (_x != ((0 : GoUInt))) {
                return ((1 : GoUInt));
            };
        };
        if (((_x != null ? _x[_j] : new Word()) << (((32 : GoUInt)) - (_i % ((32 : GoUInt))))) != ((0 : GoUInt))) {
            return ((1 : GoUInt));
        };
        return ((0 : GoUInt));
    }
    @:keep
    public function _bit(_i:GoUInt):GoUInt {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        var _j:GoUInt = _i / ((32 : GoUInt));
        if (_j >= (((_x != null ? _x.length : ((0 : GoInt))) : GoUInt))) {
            return ((0 : GoUInt));
        };
        return (((((_x != null ? _x[_j] : new Word()) >> (_i % ((32 : GoUInt)))) & ((1 : GoUInt))) : GoUInt));
    }
    @:keep
    public function _setBit(_x:T_nat, _i:GoUInt, _b:GoUInt):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _j:GoInt = (((_i / ((32 : GoUInt))) : GoInt));
        var _m:Word = ((((1 : GoUInt)) : Word)) << (_i % ((32 : GoUInt)));
        var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_b == ((0 : GoUInt))) {
            _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
            Go.copySlice(_z, _x);
            if (_j >= _n) {
                return (_z == null ? null : _z.__copy__());
            };
            if (_z != null) (_z != null ? _z[_j] : new Word()) & ((_m) ^ ((-1 : GoUnTypedInt)));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        } else if (_b == ((1 : GoUInt))) {
            if (_j >= _n) {
                _z = (_z._make(_j + ((1 : GoInt))) == null ? null : _z._make(_j + ((1 : GoInt))).__copy__());
                ((_z.__slice__(_n) : T_nat))._clear();
            } else {
                _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
            };
            Go.copySlice(_z, _x);
            if (_z != null) (_z != null ? _z[_j] : new Word()) | (_m);
            return (_z == null ? null : _z.__copy__());
        };
        throw Go.toInterface(((("set bit is not 0 or 1" : GoString))));
    }
    @:keep
    public function _shr(_x:T_nat, _s:GoUInt):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_s == ((0 : GoUInt))) {
            if (_same((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z == null ? null : _z.__copy__());
            };
            if (!_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
            };
        };
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = _m - (((_s / ((32 : GoUInt))) : GoInt));
        if (_n <= ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        };
        _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
        _shrVU(_z, ((_x.__slice__(_m - _n) : T_nat)), _s % ((32 : GoUInt)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _shl(_x:T_nat, _s:GoUInt):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_s == ((0 : GoUInt))) {
            if (_same((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z == null ? null : _z.__copy__());
            };
            if (!_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
            };
        };
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_m == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        };
        var _n:GoInt = _m + (((_s / ((32 : GoUInt))) : GoInt));
        _z = (_z._make(_n + ((1 : GoInt))) == null ? null : _z._make(_n + ((1 : GoInt))).__copy__());
        if (_z != null) _z[_n] = _shlVU(((_z.__slice__(_n - _m, _n) : T_nat)), _x, _s % ((32 : GoUInt)));
        ((_z.__slice__(((0 : GoInt)), _n - _m) : T_nat))._clear();
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _trailingZeroBits():GoUInt {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoUInt));
        };
        var _i:GoUInt = ((0 : GoUInt));
        while ((_x != null ? _x[_i] : new Word()) == ((0 : GoUInt))) {
            _i++;
        };
        return (_i * ((32 : GoUInt))) + ((stdgo.math.bits.Bits.trailingZeros((((_x != null ? _x[_i] : new Word()) : GoUInt))) : GoUInt));
    }
    @:keep
    public function _bitLen():GoInt {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        {
            var _i:GoInt = (_x != null ? _x.length : ((0 : GoInt))) - ((1 : GoInt));
            if (_i >= ((0 : GoInt))) {
                return (_i * ((32 : GoInt))) + stdgo.math.bits.Bits.len((((_x != null ? _x[_i] : new Word()) : GoUInt)));
            };
        };
        return ((0 : GoInt));
    }
    @:keep
    public function _mulRange(_a:GoUInt64, _b:GoUInt64):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_a == ((0 : GoUInt64))) {
            return (_z._setUint64(((0 : GoUInt64))) == null ? null : _z._setUint64(((0 : GoUInt64))).__copy__());
        } else if (_a > _b) {
            return (_z._setUint64(((1 : GoUInt64))) == null ? null : _z._setUint64(((1 : GoUInt64))).__copy__());
        } else if (_a == _b) {
            return (_z._setUint64(_a) == null ? null : _z._setUint64(_a).__copy__());
        } else if ((_a + ((1 : GoUInt64))) == _b) {
            return (_z._mul((((new T_nat() : T_nat))._setUint64(_a) == null ? null : ((new T_nat() : T_nat))._setUint64(_a).__copy__()), (((new T_nat() : T_nat))._setUint64(_b) == null ? null : ((new T_nat() : T_nat))._setUint64(_b).__copy__())) == null ? null : _z._mul((((new T_nat() : T_nat))._setUint64(_a) == null ? null : ((new T_nat() : T_nat))._setUint64(_a).__copy__()), (((new T_nat() : T_nat))._setUint64(_b) == null ? null : ((new T_nat() : T_nat))._setUint64(_b).__copy__())).__copy__());
        };
        var _m:GoUInt64 = (_a + _b) / ((2 : GoUInt64));
        return (_z._mul((((new T_nat() : T_nat))._mulRange(_a, _m) == null ? null : ((new T_nat() : T_nat))._mulRange(_a, _m).__copy__()), (((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b) == null ? null : ((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b).__copy__())) == null ? null : _z._mul((((new T_nat() : T_nat))._mulRange(_a, _m) == null ? null : ((new T_nat() : T_nat))._mulRange(_a, _m).__copy__()), (((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b) == null ? null : ((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b).__copy__())).__copy__());
    }
    @:keep
    public function _sqr(_x:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_n == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((1 : GoInt))) {
            var _d:Word = (_x != null ? _x[((0 : GoInt))] : new Word());
            _z = (_z._make(((2 : GoInt))) == null ? null : _z._make(((2 : GoInt))).__copy__());
            {
                var __tmp__ = _mulWW(_d, _d);
                if (_z != null) _z[((1 : GoInt))] = __tmp__._0;
                if (_z != null) _z[((0 : GoInt))] = __tmp__._1;
            };
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
            _z = null;
        };
        if (_n < _basicSqrThreshold) {
            _z = (_z._make(((2 : GoInt)) * _n) == null ? null : _z._make(((2 : GoInt)) * _n).__copy__());
            _basicMul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_x == null ? null : _x.__copy__()));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        if (_n < _karatsubaSqrThreshold) {
            _z = (_z._make(((2 : GoInt)) * _n) == null ? null : _z._make(((2 : GoInt)) * _n).__copy__());
            _basicSqr((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        var _k:GoInt = _karatsubaLen(_n, _karatsubaSqrThreshold);
        var _x0:T_nat = (((_x.__slice__(((0 : GoInt)), _k) : T_nat)) == null ? null : ((_x.__slice__(((0 : GoInt)), _k) : T_nat)).__copy__());
        _z = (_z._make(_max(((6 : GoInt)) * _k, ((2 : GoInt)) * _n)) == null ? null : _z._make(_max(((6 : GoInt)) * _k, ((2 : GoInt)) * _n)).__copy__());
        _karatsubaSqr((_z == null ? null : _z.__copy__()), (_x0 == null ? null : _x0.__copy__()));
        _z = (((_z.__slice__(((0 : GoInt)), ((2 : GoInt)) * _n) : T_nat)) == null ? null : ((_z.__slice__(((0 : GoInt)), ((2 : GoInt)) * _n) : T_nat)).__copy__());
        ((_z.__slice__(((2 : GoInt)) * _k) : T_nat))._clear();
        if (_k < _n) {
            var _tp:Ref<T_nat> = _getNat(((2 : GoInt)) * _k);
            var _t:T_nat = (_tp == null ? null : _tp.__copy__());
            var _x0:T_nat = (_x0._norm() == null ? null : _x0._norm().__copy__());
            var _x1:T_nat = (((_x.__slice__(_k) : T_nat)) == null ? null : ((_x.__slice__(_k) : T_nat)).__copy__());
            _t = (_t._mul((_x0 == null ? null : _x0.__copy__()), (_x1 == null ? null : _x1.__copy__())) == null ? null : _t._mul((_x0 == null ? null : _x0.__copy__()), (_x1 == null ? null : _x1.__copy__())).__copy__());
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _k);
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _k);
            _t = (_t._sqr((_x1 == null ? null : _x1.__copy__())) == null ? null : _t._sqr((_x1 == null ? null : _x1.__copy__())).__copy__());
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), ((2 : GoInt)) * _k);
            _putNat(_tp);
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _mul(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m < _n) {
            return (_z._mul((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _z._mul((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
        } else if ((_m == ((0 : GoInt))) || (_n == ((0 : GoInt)))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((1 : GoInt))) {
            return (_z._mulAddWW((_x == null ? null : _x.__copy__()), (_y != null ? _y[((0 : GoInt))] : new Word()), ((0 : GoUInt))) == null ? null : _z._mulAddWW((_x == null ? null : _x.__copy__()), (_y != null ? _y[((0 : GoInt))] : new Word()), ((0 : GoUInt))).__copy__());
        };
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) || _alias((_z == null ? null : _z.__copy__()), (_y == null ? null : _y.__copy__()))) {
            _z = null;
        };
        if (_n < _karatsubaThreshold) {
            _z = (_z._make(_m + _n) == null ? null : _z._make(_m + _n).__copy__());
            _basicMul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        var _k:GoInt = _karatsubaLen(_n, _karatsubaThreshold);
        var _x0:T_nat = (((_x.__slice__(((0 : GoInt)), _k) : T_nat)) == null ? null : ((_x.__slice__(((0 : GoInt)), _k) : T_nat)).__copy__());
        var _y0:T_nat = (((_y.__slice__(((0 : GoInt)), _k) : T_nat)) == null ? null : ((_y.__slice__(((0 : GoInt)), _k) : T_nat)).__copy__());
        _z = (_z._make(_max(((6 : GoInt)) * _k, _m + _n)) == null ? null : _z._make(_max(((6 : GoInt)) * _k, _m + _n)).__copy__());
        _karatsuba((_z == null ? null : _z.__copy__()), (_x0 == null ? null : _x0.__copy__()), (_y0 == null ? null : _y0.__copy__()));
        _z = (((_z.__slice__(((0 : GoInt)), _m + _n) : T_nat)) == null ? null : ((_z.__slice__(((0 : GoInt)), _m + _n) : T_nat)).__copy__());
        ((_z.__slice__(((2 : GoInt)) * _k) : T_nat))._clear();
        if ((_k < _n) || (_m != _n)) {
            var _tp:Ref<T_nat> = _getNat(((3 : GoInt)) * _k);
            var _t:T_nat = (_tp == null ? null : _tp.__copy__());
            var _x0:T_nat = (_x0._norm() == null ? null : _x0._norm().__copy__());
            var _y1:T_nat = (((_y.__slice__(_k) : T_nat)) == null ? null : ((_y.__slice__(_k) : T_nat)).__copy__());
            _t = (_t._mul((_x0 == null ? null : _x0.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _t._mul((_x0 == null ? null : _x0.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _k);
            var _y0:T_nat = (_y0._norm() == null ? null : _y0._norm().__copy__());
            {
                var _i:GoInt = _k;
                Go.cfor(_i < (_x != null ? _x.length : ((0 : GoInt))), _i = _i + (_k), {
                    var _xi:T_nat = (((_x.__slice__(_i) : T_nat)) == null ? null : ((_x.__slice__(_i) : T_nat)).__copy__());
                    if ((_xi != null ? _xi.length : ((0 : GoInt))) > _k) {
                        _xi = (((_xi.__slice__(0, _k) : T_nat)) == null ? null : ((_xi.__slice__(0, _k) : T_nat)).__copy__());
                    };
                    _xi = (_xi._norm() == null ? null : _xi._norm().__copy__());
                    _t = (_t._mul((_xi == null ? null : _xi.__copy__()), (_y0 == null ? null : _y0.__copy__())) == null ? null : _t._mul((_xi == null ? null : _xi.__copy__()), (_y0 == null ? null : _y0.__copy__())).__copy__());
                    _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _i);
                    _t = (_t._mul((_xi == null ? null : _xi.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _t._mul((_xi == null ? null : _xi.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
                    _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _i + _k);
                });
            };
            _putNat(_tp);
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _montgomery(_x:T_nat, _y:T_nat, _m:T_nat, _k:Word, _n:GoInt):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if ((((_x != null ? _x.length : ((0 : GoInt))) != _n) || ((_y != null ? _y.length : ((0 : GoInt))) != _n)) || ((_m != null ? _m.length : ((0 : GoInt))) != _n)) {
            throw Go.toInterface(((("math/big: mismatched montgomery number lengths" : GoString))));
        };
        _z = (_z._make(_n * ((2 : GoInt))) == null ? null : _z._make(_n * ((2 : GoInt))).__copy__());
        _z._clear();
        var _c:Word = new Word();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                var _d:Word = (_y != null ? _y[_i] : new Word());
                var _c2:Word = _addMulVVW(((_z.__slice__(_i, _n + _i) : T_nat)), _x, _d);
                var _t:Word = (_z != null ? _z[_i] : new Word()) * _k;
                var _c3:Word = _addMulVVW(((_z.__slice__(_i, _n + _i) : T_nat)), _m, _t);
                var _cx:Word = _c + _c2;
                var _cy:Word = _cx + _c3;
                if (_z != null) _z[_n + _i] = _cy;
                if ((_cx < _c2) || (_cy < _c3)) {
                    _c = ((1 : GoUInt));
                } else {
                    _c = ((0 : GoUInt));
                };
            });
        };
        if (_c != ((0 : GoUInt))) {
            _subVV(((_z.__slice__(0, _n) : T_nat)), ((_z.__slice__(_n) : T_nat)), _m);
        } else {
            Go.copySlice(((_z.__slice__(0, _n) : T_nat)), ((_z.__slice__(_n) : T_nat)));
        };
        return (((_z.__slice__(0, _n) : T_nat)) == null ? null : ((_z.__slice__(0, _n) : T_nat)).__copy__());
    }
    @:keep
    public function _mulAddWW(_x:T_nat, _y:Word, _r:Word):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if ((_m == ((0 : GoInt))) || (_y == ((0 : GoUInt)))) {
            return (_z._setWord(_r) == null ? null : _z._setWord(_r).__copy__());
        };
        _z = (_z._make(_m + ((1 : GoInt))) == null ? null : _z._make(_m + ((1 : GoInt))).__copy__());
        if (_z != null) _z[_m] = _mulAddVWW(((_z.__slice__(((0 : GoInt)), _m) : T_nat)), _x, _y, _r);
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _cmp(_y:T_nat):GoInt {
        var _x = __t__;
        (_x == null ? null : _x.__copy__());
        var _r:GoInt = ((0 : GoInt));
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if ((_m != _n) || (_m == ((0 : GoInt)))) {
            if (_m < _n) {
                _r = ((-1 : GoInt));
            } else if (_m > _n) {
                _r = ((1 : GoInt));
            };
            return _r;
        };
        var _i:GoInt = _m - ((1 : GoInt));
        while ((_i > ((0 : GoInt))) && ((_x != null ? _x[_i] : new Word()) == (_y != null ? _y[_i] : new Word()))) {
            _i--;
        };
        if ((_x != null ? _x[_i] : new Word()) < (_y != null ? _y[_i] : new Word())) {
            _r = ((-1 : GoInt));
        } else if ((_x != null ? _x[_i] : new Word()) > (_y != null ? _y[_i] : new Word())) {
            _r = ((1 : GoInt));
        };
        return _r;
    }
    @:keep
    public function _sub(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m < _n) {
            throw Go.toInterface(((("underflow" : GoString))));
        } else if (_m == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        var _c:Word = _subVV(((_z.__slice__(((0 : GoInt)), _n) : T_nat)), _x, _y);
        if (_m > _n) {
            _c = _subVW(((_z.__slice__(_n) : T_nat)), ((_x.__slice__(_n) : T_nat)), _c);
        };
        if (_c != ((0 : GoUInt))) {
            throw Go.toInterface(((("underflow" : GoString))));
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _add(_x:T_nat, _y:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m < _n) {
            return (_z._add((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _z._add((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
        } else if (_m == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        _z = (_z._make(_m + ((1 : GoInt))) == null ? null : _z._make(_m + ((1 : GoInt))).__copy__());
        var _c:Word = _addVV(((_z.__slice__(((0 : GoInt)), _n) : T_nat)), _x, _y);
        if (_m > _n) {
            _c = _addVW(((_z.__slice__(_n, _m) : T_nat)), ((_x.__slice__(_n) : T_nat)), _c);
        };
        if (_z != null) _z[_m] = _c;
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public function _set(_x:T_nat):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        _z = (_z._make((_x != null ? _x.length : ((0 : GoInt)))) == null ? null : _z._make((_x != null ? _x.length : ((0 : GoInt)))).__copy__());
        Go.copySlice(_z, _x);
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public function _setUint64(_x:GoUInt64):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        {
            var _w:Word = ((_x : Word));
            if (((_w : GoUInt64)) == _x) {
                return (_z._setWord(_w) == null ? null : _z._setWord(_w).__copy__());
            };
        };
        _z = (_z._make(((2 : GoInt))) == null ? null : _z._make(((2 : GoInt))).__copy__());
        if (_z != null) _z[((1 : GoInt))] = (((_x >> ((32 : GoUnTypedInt))) : Word));
        if (_z != null) _z[((0 : GoInt))] = ((_x : Word));
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public function _setWord(_x:Word):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_x == ((0 : GoUInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        };
        _z = (_z._make(((1 : GoInt))) == null ? null : _z._make(((1 : GoInt))).__copy__());
        if (_z != null) _z[((0 : GoInt))] = _x;
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public function _make(_n:GoInt):T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        if (_n <= (_z != null ? _z.cap() : ((0 : GoInt)))) {
            return (((_z.__slice__(0, _n) : T_nat)) == null ? null : ((_z.__slice__(0, _n) : T_nat)).__copy__());
        };
        if (_n == ((1 : GoInt))) {
            return new Slice<Word>(...[for (i in 0 ... ((((1 : GoInt)) : GoInt)).toBasic()) new Word()]);
        };
        {};
        return (new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]).__setCap__(((_n + ((4 : GoInt)) : GoInt)).toBasic()) == null ? null : new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]).__setCap__(((_n + ((4 : GoInt)) : GoInt)).toBasic()).__copy__());
    }
    @:keep
    public function _norm():T_nat {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        var _i:GoInt = (_z != null ? _z.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) && ((_z != null ? _z[_i - ((1 : GoInt))] : new Word()) == ((0 : GoUInt)))) {
            _i--;
        };
        return (((_z.__slice__(((0 : GoInt)), _i) : T_nat)) == null ? null : ((_z.__slice__(((0 : GoInt)), _i) : T_nat)).__copy__());
    }
    @:keep
    public function _clear():Void {
        var _z = __t__;
        (_z == null ? null : _z.__copy__());
        for (_i => _ in _z) {
            if (_z != null) _z[_i] = ((0 : GoUInt));
        };
    }
    public var __t__ : T_nat;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
@:keep class T_nat_static_extension {
    @:keep
    public static function _probablyPrimeLucas(_n:T_nat):Bool {
        (_n == null ? null : _n.__copy__());
        if (((_n != null ? _n.length : ((0 : GoInt))) == ((0 : GoInt))) || (_n._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt)))) {
            return false;
        };
        if (((_n != null ? _n[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((0 : GoUInt))) {
            return _n._cmp((_natTwo == null ? null : _natTwo.__copy__())) == ((0 : GoInt));
        };
        var _p:Word = ((((3 : GoUInt)) : Word));
        var _d:T_nat = ((new Slice<Word>(((1 : GoUInt))) : T_nat));
        var _t1:T_nat = ((new T_nat() : T_nat));
        var _intD:Ref<Int_> = (({ _abs : (_d == null ? null : _d.__copy__()), _neg : false } : Int_));
        var _intN:Ref<Int_> = (({ _abs : (_n == null ? null : _n.__copy__()), _neg : false } : Int_));
        Go.cfor(true, _p++, {
            if (_p > ((10000 : GoUInt))) {
                throw Go.toInterface(((("math/big: internal error: cannot find (D/n) = -1 for " : GoString))) + ((_intN.toString() : GoString)));
            };
            if (_d != null) _d[((0 : GoInt))] = (_p * _p) - ((4 : GoUInt));
            var _j:GoInt = jacobi(_intD, _intN);
            if (_j == ((-1 : GoInt))) {
                break;
            };
            if (_j == ((0 : GoInt))) {
                return ((_n != null ? _n.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_n != null ? _n[((0 : GoInt))] : new Word()) == (_p + ((2 : GoUInt))));
            };
            if (_p == ((40 : GoUInt))) {
                _t1 = (_t1._sqrt((_n == null ? null : _n.__copy__())) == null ? null : _t1._sqrt((_n == null ? null : _n.__copy__())).__copy__());
                _t1 = (_t1._sqr((_t1 == null ? null : _t1.__copy__())) == null ? null : _t1._sqr((_t1 == null ? null : _t1.__copy__())).__copy__());
                if (_t1._cmp((_n == null ? null : _n.__copy__())) == ((0 : GoInt))) {
                    return false;
                };
            };
        });
        var _s:T_nat = (((new T_nat() : T_nat))._add((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._add((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
        var _r:GoInt = ((_s._trailingZeroBits() : GoInt));
        _s = (_s._shr((_s == null ? null : _s.__copy__()), ((_r : GoUInt))) == null ? null : _s._shr((_s == null ? null : _s.__copy__()), ((_r : GoUInt))).__copy__());
        var _nm2:T_nat = (((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
        var _natP:T_nat = (((new T_nat() : T_nat))._setWord(_p) == null ? null : ((new T_nat() : T_nat))._setWord(_p).__copy__());
        var _vk:T_nat = (((new T_nat() : T_nat))._setWord(((2 : GoUInt))) == null ? null : ((new T_nat() : T_nat))._setWord(((2 : GoUInt))).__copy__());
        var _vk1:T_nat = (((new T_nat() : T_nat))._setWord(_p) == null ? null : ((new T_nat() : T_nat))._setWord(_p).__copy__());
        var _t2:T_nat = ((new T_nat() : T_nat));
        {
            var _i:GoInt = ((_s._bitLen() : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                if (_s._bit(((_i : GoUInt))) != ((0 : GoUInt))) {
                    _t1 = (_t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())) == null ? null : _t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())).__copy__());
                    _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk == null ? null : _vk.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                    _t1 = (_t1._sqr((_vk1 == null ? null : _vk1.__copy__())) == null ? null : _t1._sqr((_vk1 == null ? null : _vk1.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk1 == null ? null : _vk1.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk1 = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                } else {
                    _t1 = (_t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())) == null ? null : _t1._mul((_vk == null ? null : _vk.__copy__()), (_vk1 == null ? null : _vk1.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__())).__copy__());
                    _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_natP == null ? null : _natP.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk1 == null ? null : _vk1.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk1 = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                    _t1 = (_t1._sqr((_vk == null ? null : _vk.__copy__())) == null ? null : _t1._sqr((_vk == null ? null : _vk.__copy__())).__copy__());
                    _t1 = (_t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())) == null ? null : _t1._add((_t1 == null ? null : _t1.__copy__()), (_nm2 == null ? null : _nm2.__copy__())).__copy__());
                    {
                        var __tmp__ = _t2._div((_vk == null ? null : _vk.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                        _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _vk = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                };
            });
        };
        if ((_vk._cmp((_natTwo == null ? null : _natTwo.__copy__())) == ((0 : GoInt))) || (_vk._cmp((_nm2 == null ? null : _nm2.__copy__())) == ((0 : GoInt)))) {
            var _t1:T_nat = (_t1._mul((_vk == null ? null : _vk.__copy__()), (_natP == null ? null : _natP.__copy__())) == null ? null : _t1._mul((_vk == null ? null : _vk.__copy__()), (_natP == null ? null : _natP.__copy__())).__copy__());
            var _t2:T_nat = (_t2._shl((_vk1 == null ? null : _vk1.__copy__()), ((1 : GoUInt))) == null ? null : _t2._shl((_vk1 == null ? null : _vk1.__copy__()), ((1 : GoUInt))).__copy__());
            if (_t1._cmp((_t2 == null ? null : _t2.__copy__())) < ((0 : GoInt))) {
                {
                    final __tmp__0 = (_t2 == null ? null : _t2.__copy__());
                    final __tmp__1 = (_t1 == null ? null : _t1.__copy__());
                    _t1 = __tmp__0;
                    _t2 = __tmp__1;
                };
            };
            _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_t2 == null ? null : _t2.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_t2 == null ? null : _t2.__copy__())).__copy__());
            var _t3:T_nat = (_vk1 == null ? null : _vk1.__copy__());
            _vk1 = null;
            _vk1;
            {
                var __tmp__ = _t2._div((_t3 == null ? null : _t3.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                _t3 = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
            };
            if ((_t3 != null ? _t3.length : ((0 : GoInt))) == ((0 : GoInt))) {
                return true;
            };
        };
        {
            var _t:GoInt = ((0 : GoInt));
            Go.cfor(_t < (_r - ((1 : GoInt))), _t++, {
                if ((_vk != null ? _vk.length : ((0 : GoInt))) == ((0 : GoInt))) {
                    return true;
                };
                if (((_vk != null ? _vk.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_vk != null ? _vk[((0 : GoInt))] : new Word()) == ((2 : GoUInt)))) {
                    return false;
                };
                _t1 = (_t1._sqr((_vk == null ? null : _vk.__copy__())) == null ? null : _t1._sqr((_vk == null ? null : _vk.__copy__())).__copy__());
                _t1 = (_t1._sub((_t1 == null ? null : _t1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : _t1._sub((_t1 == null ? null : _t1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
                {
                    var __tmp__ = _t2._div((_vk == null ? null : _vk.__copy__()), (_t1 == null ? null : _t1.__copy__()), (_n == null ? null : _n.__copy__()));
                    _t2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _vk = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
            });
        };
        return false;
    }
    @:keep
    public static function _probablyPrimeMillerRabin(_n:T_nat, _reps:GoInt, _force2:Bool):Bool {
        (_n == null ? null : _n.__copy__());
        return stdgo.internal.Macro.controlFlow({
            var _nm1:T_nat = (((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_n == null ? null : _n.__copy__()), (_natOne == null ? null : _natOne.__copy__())).__copy__());
            var _k:GoUInt = _nm1._trailingZeroBits();
            var _q:T_nat = (((new T_nat() : T_nat))._shr((_nm1 == null ? null : _nm1.__copy__()), _k) == null ? null : ((new T_nat() : T_nat))._shr((_nm1 == null ? null : _nm1.__copy__()), _k).__copy__());
            var _nm3:T_nat = (((new T_nat() : T_nat))._sub((_nm1 == null ? null : _nm1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : ((new T_nat() : T_nat))._sub((_nm1 == null ? null : _nm1.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
            var _rand:Ref<stdgo.math.rand.Rand.Rand> = _rand.new_(_rand.newSource((((_n != null ? _n[((0 : GoInt))] : new Word()) : GoInt64))));
            var _x:T_nat = new T_nat(), _y:T_nat = new T_nat(), _quotient:T_nat = new T_nat();
            var _nm3Len:GoInt = _nm3._bitLen();
            @:label("NextRandom") {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < _reps, _i++, {
                    if ((_i == (_reps - ((1 : GoInt)))) && _force2) {
                        _x = (_x._set((_natTwo == null ? null : _natTwo.__copy__())) == null ? null : _x._set((_natTwo == null ? null : _natTwo.__copy__())).__copy__());
                    } else {
                        _x = (_x._random(_rand, (_nm3 == null ? null : _nm3.__copy__()), _nm3Len) == null ? null : _x._random(_rand, (_nm3 == null ? null : _nm3.__copy__()), _nm3Len).__copy__());
                        _x = (_x._add((_x == null ? null : _x.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())) == null ? null : _x._add((_x == null ? null : _x.__copy__()), (_natTwo == null ? null : _natTwo.__copy__())).__copy__());
                    };
                    _y = (_y._expNN((_x == null ? null : _x.__copy__()), (_q == null ? null : _q.__copy__()), (_n == null ? null : _n.__copy__())) == null ? null : _y._expNN((_x == null ? null : _x.__copy__()), (_q == null ? null : _q.__copy__()), (_n == null ? null : _n.__copy__())).__copy__());
                    if ((_y._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt))) || (_y._cmp((_nm1 == null ? null : _nm1.__copy__())) == ((0 : GoInt)))) {
                        continue;
                    };
                    {
                        var _j:GoUInt = ((((1 : GoUInt)) : GoUInt));
                        Go.cfor(_j < _k, _j++, {
                            _y = (_y._sqr((_y == null ? null : _y.__copy__())) == null ? null : _y._sqr((_y == null ? null : _y.__copy__())).__copy__());
                            {
                                var __tmp__ = _quotient._div((_y == null ? null : _y.__copy__()), (_y == null ? null : _y.__copy__()), (_n == null ? null : _n.__copy__()));
                                _quotient = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _y = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            if (_y._cmp((_nm1 == null ? null : _nm1.__copy__())) == ((0 : GoInt))) {
                                continue;
                            };
                            if (_y._cmp((_natOne == null ? null : _natOne.__copy__())) == ((0 : GoInt))) {
                                return false;
                            };
                        });
                    };
                    return false;
                });
            };
            return true;
        });
    }
    @:keep
    public static function _divRecursiveStep(_z:T_nat, _u:T_nat, _v:T_nat, _depth:GoInt, _tmp:T_nat, _temps:Slice<T_nat>):Void {
        (_z == null ? null : _z.__copy__());
        _u = (_u._norm() == null ? null : _u._norm().__copy__());
        _v = (_v._norm() == null ? null : _v._norm().__copy__());
        if ((_u != null ? _u.length : ((0 : GoInt))) == ((0 : GoInt))) {
            _z._clear();
            return;
        };
        var _n:GoInt = (_v != null ? _v.length : ((0 : GoInt)));
        if (_n < ((100 : GoInt))) {
            _z._divBasic((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
            return;
        };
        var _m:GoInt = (_u != null ? _u.length : ((0 : GoInt))) - _n;
        if (_m < ((0 : GoInt))) {
            return;
        };
        var b:GoInt = _n / ((2 : GoInt));
        if ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) == null) {
            if (_temps != null) _temps[_depth] = _getNat(_n);
        } else {
            (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) = ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>)))._make(b + ((1 : GoInt))) == null ? null : (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>)))._make(b + ((1 : GoInt))).__copy__());
        };
        var _j:GoInt = _m;
        while (_j > b) {
            var _s:GoInt = (b - ((1 : GoInt)));
            var _uu:T_nat = (((_u.__slice__(_j - b) : T_nat)) == null ? null : ((_u.__slice__(_j - b) : T_nat)).__copy__());
            var _qhat:T_nat = ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) == null ? null : (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))).__copy__());
            _qhat._clear();
            _qhat._divRecursiveStep((((_uu.__slice__(_s, b + _n) : T_nat)) == null ? null : ((_uu.__slice__(_s, b + _n) : T_nat)).__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), _depth + ((1 : GoInt)), _tmp, _temps);
            _qhat = (_qhat._norm() == null ? null : _qhat._norm().__copy__());
            var _qhatv:T_nat = (_tmp._make(((3 : GoInt)) * _n) == null ? null : _tmp._make(((3 : GoInt)) * _n).__copy__());
            _qhatv._clear();
            _qhatv = (_qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())) == null ? null : _qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())).__copy__());
            {
                var _i:GoInt = ((0 : GoInt));
                Go.cfor(_i < ((2 : GoInt)), _i++, {
                    var _e:GoInt = _qhatv._cmp((_uu._norm() == null ? null : _uu._norm().__copy__()));
                    if (_e <= ((0 : GoInt))) {
                        break;
                    };
                    _subVW(_qhat, _qhat, ((1 : GoUInt)));
                    var _c:Word = _subVV(((_qhatv.__slice__(0, _s) : T_nat)), ((_qhatv.__slice__(0, _s) : T_nat)), ((_v.__slice__(0, _s) : T_nat)));
                    if ((_qhatv != null ? _qhatv.length : ((0 : GoInt))) > _s) {
                        _subVW(((_qhatv.__slice__(_s) : T_nat)), ((_qhatv.__slice__(_s) : T_nat)), _c);
                    };
                    _addAt((((_uu.__slice__(_s) : T_nat)) == null ? null : ((_uu.__slice__(_s) : T_nat)).__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), ((0 : GoInt)));
                });
            };
            if (_qhatv._cmp((_uu._norm() == null ? null : _uu._norm().__copy__())) > ((0 : GoInt))) {
                throw Go.toInterface(((("impossible" : GoString))));
            };
            var _c:Word = _subVV(((_uu.__slice__(0, (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_uu.__slice__(0, (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _qhatv);
            if (_c > ((0 : GoUInt))) {
                _subVW(((_uu.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_uu.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _c);
            };
            _addAt((_z == null ? null : _z.__copy__()), (_qhat == null ? null : _qhat.__copy__()), _j - b);
            _j = _j - (b);
        };
        var _s:GoInt = b - ((1 : GoInt));
        var _qhat:T_nat = ((_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))) == null ? null : (_temps != null ? _temps[_depth] : ((null : Ref<T_nat>))).__copy__());
        _qhat._clear();
        _qhat._divRecursiveStep((((_u.__slice__(_s) : T_nat))._norm() == null ? null : ((_u.__slice__(_s) : T_nat))._norm().__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), _depth + ((1 : GoInt)), _tmp, _temps);
        _qhat = (_qhat._norm() == null ? null : _qhat._norm().__copy__());
        var _qhatv:T_nat = (_tmp._make(((3 : GoInt)) * _n) == null ? null : _tmp._make(((3 : GoInt)) * _n).__copy__());
        _qhatv._clear();
        _qhatv = (_qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())) == null ? null : _qhatv._mul((_qhat == null ? null : _qhat.__copy__()), (((_v.__slice__(0, _s) : T_nat)) == null ? null : ((_v.__slice__(0, _s) : T_nat)).__copy__())).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < ((2 : GoInt)), _i++, {
                {
                    var _e:GoInt = _qhatv._cmp((_u._norm() == null ? null : _u._norm().__copy__()));
                    if (_e > ((0 : GoInt))) {
                        _subVW(_qhat, _qhat, ((1 : GoUInt)));
                        var _c:Word = _subVV(((_qhatv.__slice__(0, _s) : T_nat)), ((_qhatv.__slice__(0, _s) : T_nat)), ((_v.__slice__(0, _s) : T_nat)));
                        if ((_qhatv != null ? _qhatv.length : ((0 : GoInt))) > _s) {
                            _subVW(((_qhatv.__slice__(_s) : T_nat)), ((_qhatv.__slice__(_s) : T_nat)), _c);
                        };
                        _addAt((((_u.__slice__(_s) : T_nat)) == null ? null : ((_u.__slice__(_s) : T_nat)).__copy__()), (((_v.__slice__(_s) : T_nat)) == null ? null : ((_v.__slice__(_s) : T_nat)).__copy__()), ((0 : GoInt)));
                    };
                };
            });
        };
        if (_qhatv._cmp((_u._norm() == null ? null : _u._norm().__copy__())) > ((0 : GoInt))) {
            throw Go.toInterface(((("impossible" : GoString))));
        };
        var _c:Word = _subVV(((_u.__slice__(((0 : GoInt)), (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_u.__slice__(((0 : GoInt)), (_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _qhatv);
        if (_c > ((0 : GoUInt))) {
            _c = _subVW(((_u.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), ((_u.__slice__((_qhatv != null ? _qhatv.length : ((0 : GoInt)))) : T_nat)), _c);
        };
        if (_c > ((0 : GoUInt))) {
            throw Go.toInterface(((("impossible" : GoString))));
        };
        _addAt((_z == null ? null : _z.__copy__()), (_qhat._norm() == null ? null : _qhat._norm().__copy__()), ((0 : GoInt)));
    }
    @:keep
    public static function _divRecursive(_z:T_nat, _u:T_nat, _v:T_nat):Void {
        (_z == null ? null : _z.__copy__());
        var _recDepth:GoInt = ((2 : GoInt)) * stdgo.math.bits.Bits.len((((_v != null ? _v.length : ((0 : GoInt))) : GoUInt)));
        var _tmp:Ref<T_nat> = _getNat(((3 : GoInt)) * (_v != null ? _v.length : ((0 : GoInt))));
        var _temps:Slice<Ref<T_nat>> = new Slice<Ref<T_nat>>(...[for (i in 0 ... ((_recDepth : GoInt)).toBasic()) ((null : Ref<T_nat>))]);
        _z._clear();
        _z._divRecursiveStep((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()), ((0 : GoInt)), _tmp, _temps);
        for (_0 => _n in _temps) {
            if (_n != null) {
                _putNat(_n);
            };
        };
        _putNat(_tmp);
    }
    @:keep
    public static function _divBasic(_q:T_nat, _u:T_nat, _v:T_nat):Void {
        (_q == null ? null : _q.__copy__());
        var _n:GoInt = (_v != null ? _v.length : ((0 : GoInt)));
        var _m:GoInt = (_u != null ? _u.length : ((0 : GoInt))) - _n;
        var _qhatvp:Ref<T_nat> = _getNat(_n + ((1 : GoInt)));
        var _qhatv:T_nat = (_qhatvp == null ? null : _qhatvp.__copy__());
        var _vn1:Word = (_v != null ? _v[_n - ((1 : GoInt))] : new Word());
        var _rec:Word = _reciprocalWord(_vn1);
        {
            var _j:GoInt = _m;
            Go.cfor(_j >= ((0 : GoInt)), _j--, {
                var _qhat:Word = (((("4294967295" : GoUInt)) : Word));
                var _ujn:Word = new Word();
                if ((_j + _n) < (_u != null ? _u.length : ((0 : GoInt)))) {
                    _ujn = (_u != null ? _u[_j + _n] : new Word());
                };
                if (_ujn != _vn1) {
                    var _rhat:Word = new Word();
                    {
                        var __tmp__ = _divWW(_ujn, (_u != null ? _u[(_j + _n) - ((1 : GoInt))] : new Word()), _vn1, _rec);
                        _qhat = __tmp__._0;
                        _rhat = __tmp__._1;
                    };
                    var _vn2:Word = (_v != null ? _v[_n - ((2 : GoInt))] : new Word());
                    var __tmp__ = _mulWW(_qhat, _vn2), _x1:Word = __tmp__._0, _x2:Word = __tmp__._1;
                    var _ujn2:Word = (_u != null ? _u[(_j + _n) - ((2 : GoInt))] : new Word());
                    while (_greaterThan(_x1, _x2, _rhat, _ujn2)) {
                        _qhat--;
                        var _prevRhat:Word = _rhat;
                        _rhat = _rhat + (_vn1);
                        if (_rhat < _prevRhat) {
                            break;
                        };
                        {
                            var __tmp__ = _mulWW(_qhat, _vn2);
                            _x1 = __tmp__._0;
                            _x2 = __tmp__._1;
                        };
                    };
                };
                if (_qhatv != null) _qhatv[_n] = _mulAddVWW(((_qhatv.__slice__(((0 : GoInt)), _n) : T_nat)), _v, _qhat, ((0 : GoUInt)));
                var _qhl:GoInt = (_qhatv != null ? _qhatv.length : ((0 : GoInt)));
                if (((_j + _qhl) > (_u != null ? _u.length : ((0 : GoInt)))) && ((_qhatv != null ? _qhatv[_n] : new Word()) == ((0 : GoUInt)))) {
                    _qhl--;
                };
                var _c:Word = _subVV(((_u.__slice__(_j, _j + _qhl) : T_nat)), ((_u.__slice__(_j) : T_nat)), _qhatv);
                if (_c != ((0 : GoUInt))) {
                    var _c:Word = _addVV(((_u.__slice__(_j, _j + _n) : T_nat)), ((_u.__slice__(_j) : T_nat)), _v);
                    if (_n < _qhl) {
                        if (_u != null) (_u != null ? _u[_j + _n] : new Word()) + (_c);
                    };
                    _qhat--;
                };
                if (((_j == _m) && (_m == (_q != null ? _q.length : ((0 : GoInt))))) && (_qhat == ((0 : GoUInt)))) {
                    continue;
                };
                if (_q != null) _q[_j] = _qhat;
            });
        };
        _putNat(_qhatvp);
    }
    @:keep
    public static function _divLarge(_z:T_nat, _u:T_nat, _uIn:T_nat, _vIn:T_nat):{ var _0 : T_nat; var _1 : T_nat; } {
        (_z == null ? null : _z.__copy__());
        var _q:T_nat = new T_nat(), _r:T_nat = new T_nat();
        var _n:GoInt = (_vIn != null ? _vIn.length : ((0 : GoInt)));
        var _m:GoInt = (_uIn != null ? _uIn.length : ((0 : GoInt))) - _n;
        var _shift:GoUInt = _nlz((_vIn != null ? _vIn[_n - ((1 : GoInt))] : new Word()));
        var _vp:Ref<T_nat> = _getNat(_n);
        var _v:T_nat = (_vp == null ? null : _vp.__copy__());
        _shlVU(_v, _vIn, _shift);
        _u = (_u._make((_uIn != null ? _uIn.length : ((0 : GoInt))) + ((1 : GoInt))) == null ? null : _u._make((_uIn != null ? _uIn.length : ((0 : GoInt))) + ((1 : GoInt))).__copy__());
        if (_u != null) _u[(_uIn != null ? _uIn.length : ((0 : GoInt)))] = _shlVU(((_u.__slice__(((0 : GoInt)), (_uIn != null ? _uIn.length : ((0 : GoInt)))) : T_nat)), _uIn, _shift);
        if (_alias((_z == null ? null : _z.__copy__()), (_u == null ? null : _u.__copy__()))) {
            _z = null;
        };
        _q = (_z._make(_m + ((1 : GoInt))) == null ? null : _z._make(_m + ((1 : GoInt))).__copy__());
        if (_n < ((100 : GoInt))) {
            _q._divBasic((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
        } else {
            _q._divRecursive((_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
        };
        _putNat(_vp);
        _q = (_q._norm() == null ? null : _q._norm().__copy__());
        _shrVU(_u, _u, _shift);
        _r = (_u._norm() == null ? null : _u._norm().__copy__());
        return { _0 : (_q == null ? null : _q.__copy__()), _1 : (_r == null ? null : _r.__copy__()) };
    }
    @:keep
    public static function _modW(_x:T_nat, _d:Word):Word {
        (_x == null ? null : _x.__copy__());
        var _r:Word = new Word();
        var _q:T_nat = new T_nat();
        _q = (_q._make((_x != null ? _x.length : ((0 : GoInt)))) == null ? null : _q._make((_x != null ? _x.length : ((0 : GoInt)))).__copy__());
        return _divWVW(_q, ((0 : GoUInt)), _x, _d);
    }
    @:keep
    public static function _divW(_z:T_nat, _x:T_nat, _y:Word):{ var _0 : T_nat; var _1 : Word; } {
        (_z == null ? null : _z.__copy__());
        var _q:T_nat = new T_nat(), _r:Word = new Word();
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_y == ((0 : GoUInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        } else if (_y == ((1 : GoUInt))) {
            _q = (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
            return { _0 : _q, _1 : _r };
        } else if (_m == ((0 : GoInt))) {
            _q = (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            return { _0 : _q, _1 : _r };
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        _r = _divWVW(_z, ((0 : GoUInt)), _x, _y);
        _q = (_z._norm() == null ? null : _z._norm().__copy__());
        return { _0 : _q, _1 : _r };
    }
    @:keep
    public static function _div(_z:T_nat, _z2:T_nat, _u:T_nat, _v:T_nat):{ var _0 : T_nat; var _1 : T_nat; } {
        (_z == null ? null : _z.__copy__());
        var _q:T_nat = new T_nat(), _r:T_nat = new T_nat();
        if ((_v != null ? _v.length : ((0 : GoInt))) == ((0 : GoInt))) {
            throw Go.toInterface(((("division by zero" : GoString))));
        };
        if (_u._cmp((_v == null ? null : _v.__copy__())) < ((0 : GoInt))) {
            _q = (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
            _r = (_z2._set((_u == null ? null : _u.__copy__())) == null ? null : _z2._set((_u == null ? null : _u.__copy__())).__copy__());
            return { _0 : _q, _1 : _r };
        };
        if ((_v != null ? _v.length : ((0 : GoInt))) == ((1 : GoInt))) {
            var _r2:Word = new Word();
            {
                var __tmp__ = _z._divW((_u == null ? null : _u.__copy__()), (_v != null ? _v[((0 : GoInt))] : new Word()));
                _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                _r2 = __tmp__._1;
            };
            _r = (_z2._setWord(_r2) == null ? null : _z2._setWord(_r2).__copy__());
            return { _0 : _q, _1 : _r };
        };
        {
            var __tmp__ = _z._divLarge((_z2 == null ? null : _z2.__copy__()), (_u == null ? null : _u.__copy__()), (_v == null ? null : _v.__copy__()));
            _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        return { _0 : _q, _1 : _r };
    }
    @:keep
    public static function _expWW(_z:T_nat, _x:Word, _y:Word):T_nat {
        (_z == null ? null : _z.__copy__());
        return (_z._expNN((((new T_nat() : T_nat))._setWord(_x) == null ? null : ((new T_nat() : T_nat))._setWord(_x).__copy__()), (((new T_nat() : T_nat))._setWord(_y) == null ? null : ((new T_nat() : T_nat))._setWord(_y).__copy__()), null) == null ? null : _z._expNN((((new T_nat() : T_nat))._setWord(_x) == null ? null : ((new T_nat() : T_nat))._setWord(_x).__copy__()), (((new T_nat() : T_nat))._setWord(_y) == null ? null : ((new T_nat() : T_nat))._setWord(_y).__copy__()), null).__copy__());
    }
    @:keep
    public static function _convertWords(_q:T_nat, _s:Slice<GoByte>, _b:Word, _ndigits:GoInt, _bb:Word, _table:Slice<T_divisor>):Void {
        (_q == null ? null : _q.__copy__());
        if (_table != null) {
            var _r:T_nat = new T_nat();
            var _index:GoInt = (_table != null ? _table.length : ((0 : GoInt))) - ((1 : GoInt));
            while ((_q != null ? _q.length : ((0 : GoInt))) > _leafSize) {
                var _maxLength:GoInt = _q._bitLen();
                var _minLength:GoInt = _maxLength >> ((1 : GoUnTypedInt));
                while ((_index > ((0 : GoInt))) && ((_table != null ? _table[_index - ((1 : GoInt))] : new T_divisor())._nbits > _minLength)) {
                    _index--;
                };
                if (((_table != null ? _table[_index] : new T_divisor())._nbits >= _maxLength) && ((_table != null ? _table[_index] : new T_divisor())._bbb._cmp((_q == null ? null : _q.__copy__())) >= ((0 : GoInt)))) {
                    _index--;
                    if (_index < ((0 : GoInt))) {
                        throw Go.toInterface(((("internal inconsistency" : GoString))));
                    };
                };
                {
                    var __tmp__ = _q._div((_r == null ? null : _r.__copy__()), (_q == null ? null : _q.__copy__()), ((_table != null ? _table[_index] : new T_divisor())._bbb == null ? null : (_table != null ? _table[_index] : new T_divisor())._bbb.__copy__()));
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                var _h:GoInt = (_s != null ? _s.length : ((0 : GoInt))) - (_table != null ? _table[_index] : new T_divisor())._ndigits;
                _r._convertWords(((_s.__slice__(_h) : Slice<GoUInt8>)), _b, _ndigits, _bb, ((_table.__slice__(((0 : GoInt)), _index) : Slice<T_divisor>)));
                _s = ((_s.__slice__(0, _h) : Slice<GoUInt8>));
            };
        };
        var _i:GoInt = (_s != null ? _s.length : ((0 : GoInt)));
        var _r:Word = new Word();
        if (_b == ((10 : GoUInt))) {
            while ((_q != null ? _q.length : ((0 : GoInt))) > ((0 : GoInt))) {
                {
                    var __tmp__ = _q._divW((_q == null ? null : _q.__copy__()), _bb);
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = __tmp__._1;
                };
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor((_j < _ndigits) && (_i > ((0 : GoInt))), _j++, {
                        _i--;
                        var _t:Word = _r / ((10 : GoUInt));
                        if (_s != null) _s[_i] = ((((("0" : GoString))).code : GoRune)) + (((_r - (_t * ((10 : GoUInt)))) : GoByte));
                        _r = _t;
                    });
                };
            };
        } else {
            while ((_q != null ? _q.length : ((0 : GoInt))) > ((0 : GoInt))) {
                {
                    var __tmp__ = _q._divW((_q == null ? null : _q.__copy__()), _bb);
                    _q = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = __tmp__._1;
                };
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor((_j < _ndigits) && (_i > ((0 : GoInt))), _j++, {
                        _i--;
                        if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_r % _b] : ((0 : GoUInt8)));
                        _r = _r / (_b);
                    });
                };
            };
        };
        while (_i > ((0 : GoInt))) {
            _i--;
            if (_s != null) _s[_i] = ((((("0" : GoString))).code : GoRune));
        };
    }
    @:keep
    public static function _itoa(_x:T_nat, _neg:Bool, _base:GoInt):Slice<GoByte> {
        (_x == null ? null : _x.__copy__());
        if ((_base < ((2 : GoInt))) || (_base > ((62 : GoInt)))) {
            throw Go.toInterface(((("invalid base" : GoString))));
        };
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((((("0" : GoString))) : Slice<GoByte>));
        };
        var _i:GoInt = (((((_x._bitLen() : GoFloat64)) / stdgo.math.Math.log2(((_base : GoFloat64)))) : GoInt)) + ((1 : GoInt));
        if (_neg) {
            _i++;
        };
        var _s:Slice<GoUInt8> = new Slice<GoUInt8>(...[for (i in 0 ... ((_i : GoInt)).toBasic()) ((0 : GoUInt8))]);
        {
            var _b:Word = ((_base : Word));
            if (_b == (_b & -_b)) {
                var _shift:GoUInt = ((stdgo.math.bits.Bits.trailingZeros(((_b : GoUInt))) : GoUInt));
                var _mask:Word = ((((((1 : GoUInt)) << _shift) - ((1 : GoUInt))) : Word));
                var _w:Word = (_x != null ? _x[((0 : GoInt))] : new Word());
                var _nbits:GoUInt = ((((32 : GoUInt)) : GoUInt));
                {
                    var _k:GoInt = ((1 : GoInt));
                    Go.cfor(_k < (_x != null ? _x.length : ((0 : GoInt))), _k++, {
                        while (_nbits >= _shift) {
                            _i--;
                            if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_w & _mask] : ((0 : GoUInt8)));
                            _w = _w >> (_shift);
                            _nbits = _nbits - (_shift);
                        };
                        if (_nbits == ((0 : GoUInt))) {
                            _w = (_x != null ? _x[_k] : new Word());
                            _nbits = ((32 : GoUInt));
                        } else {
                            _w = _w | ((_x != null ? _x[_k] : new Word()) << _nbits);
                            _i--;
                            if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_w & _mask] : ((0 : GoUInt8)));
                            _w = (_x != null ? _x[_k] : new Word()) >> (_shift - _nbits);
                            _nbits = ((32 : GoUInt)) - (_shift - _nbits);
                        };
                    });
                };
                while (_w != ((0 : GoUInt))) {
                    _i--;
                    if (_s != null) _s[_i] = (((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString))) != null ? ((("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ" : GoString)))[_w & _mask] : ((0 : GoUInt8)));
                    _w = _w >> (_shift);
                };
            } else {
                var __tmp__ = _maxPow(_b), _bb:Word = __tmp__._0, _ndigits:GoInt = __tmp__._1;
                var _table:Slice<T_divisor> = _divisors((_x != null ? _x.length : ((0 : GoInt))), _b, _ndigits, _bb);
                var _q:T_nat = (((new T_nat() : T_nat))._set((_x == null ? null : _x.__copy__())) == null ? null : ((new T_nat() : T_nat))._set((_x == null ? null : _x.__copy__())).__copy__());
                _q._convertWords(_s, _b, _ndigits, _bb, _table);
                _i = ((0 : GoInt));
                while ((_s != null ? _s[_i] : ((0 : GoUInt8))) == ((((("0" : GoString))).code : GoRune))) {
                    _i++;
                };
            };
        };
        if (_neg) {
            _i--;
            if (_s != null) _s[_i] = ((((("-" : GoString))).code : GoRune));
        };
        return ((_s.__slice__(_i) : Slice<GoUInt8>));
    }
    @:keep
    public static function _utoa(_x:T_nat, _base:GoInt):Slice<GoByte> {
        (_x == null ? null : _x.__copy__());
        return _x._itoa(false, _base);
    }
    @:keep
    public static function _scan(_z:T_nat, _r:stdgo.io.Io.ByteScanner, _base:GoInt, _fracOk:Bool):{ var _0 : T_nat; var _1 : GoInt; var _2 : GoInt; var _3 : Error; } {
        (_z == null ? null : _z.__copy__());
        var _res:T_nat = new T_nat(), _b:GoInt = ((0 : GoInt)), _count:GoInt = ((0 : GoInt)), _err:Error = ((null : stdgo.Error));
        var _baseOk:Bool = ((_base == ((0 : GoInt))) || ((!_fracOk && (((2 : GoInt)) <= _base)) && (_base <= ((62 : GoInt))))) || (_fracOk && ((((_base == ((2 : GoInt))) || (_base == ((8 : GoInt)))) || (_base == ((10 : GoInt)))) || (_base == ((16 : GoInt)))));
        if (!_baseOk) {
            throw Go.toInterface(stdgo.fmt.Fmt.sprintf(((("invalid number base %d" : GoString))), Go.toInterface(_base)));
        };
        var _prev:GoInt32 = ((((("." : GoString))).code : GoRune));
        var _invalSep:Bool = false;
        var __tmp__ = _r.readByte(), _ch:GoUInt8 = __tmp__._0, _err:stdgo.Error = __tmp__._1;
        var _b:GoInt = _base, _prefix:GoInt = ((0 : GoInt));
        if (_base == ((0 : GoInt))) {
            _b = ((10 : GoInt));
            if ((_err == null) && (_ch == ((((("0" : GoString))).code : GoRune)))) {
                _prev = ((((("0" : GoString))).code : GoRune));
                _count = ((1 : GoInt));
                {
                    var __tmp__ = _r.readByte();
                    _ch = __tmp__._0;
                    _err = __tmp__._1;
                };
                if (_err == null) {
                    if (_ch == ((((("b" : GoString))).code : GoRune)) || _ch == ((((("B" : GoString))).code : GoRune))) {
                        {
                            final __tmp__0 = ((2 : GoInt));
                            final __tmp__1 = ((((("b" : GoString))).code : GoRune));
                            _b = __tmp__0;
                            _prefix = __tmp__1;
                        };
                    } else if (_ch == ((((("o" : GoString))).code : GoRune)) || _ch == ((((("O" : GoString))).code : GoRune))) {
                        {
                            final __tmp__0 = ((8 : GoInt));
                            final __tmp__1 = ((((("o" : GoString))).code : GoRune));
                            _b = __tmp__0;
                            _prefix = __tmp__1;
                        };
                    } else if (_ch == ((((("x" : GoString))).code : GoRune)) || _ch == ((((("X" : GoString))).code : GoRune))) {
                        {
                            final __tmp__0 = ((16 : GoInt));
                            final __tmp__1 = ((((("x" : GoString))).code : GoRune));
                            _b = __tmp__0;
                            _prefix = __tmp__1;
                        };
                    } else {
                        if (!_fracOk) {
                            {
                                final __tmp__0 = ((8 : GoInt));
                                final __tmp__1 = ((((("0" : GoString))).code : GoRune));
                                _b = __tmp__0;
                                _prefix = __tmp__1;
                            };
                        };
                    };
                    if (_prefix != ((0 : GoInt))) {
                        _count = ((0 : GoInt));
                        if (_prefix != ((((("0" : GoString))).code : GoRune))) {
                            {
                                var __tmp__ = _r.readByte();
                                _ch = __tmp__._0;
                                _err = __tmp__._1;
                            };
                        };
                    };
                };
            };
        };
        _z = (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        var _b1:Word = ((_b : Word));
        var __tmp__ = _maxPow(_b1), _bn:Word = __tmp__._0, _n:GoInt = __tmp__._1;
        var _di:Word = ((((0 : GoUInt)) : Word));
        var _i:GoInt = ((0 : GoInt));
        var _dp:GoInt = ((-1 : GoInt));
        while (_err == null) {
            if ((_ch == ((((("." : GoString))).code : GoRune))) && _fracOk) {
                _fracOk = false;
                if (_prev == ((((("_" : GoString))).code : GoRune))) {
                    _invalSep = true;
                };
                _prev = ((((("." : GoString))).code : GoRune));
                _dp = _count;
            } else if ((_ch == ((((("_" : GoString))).code : GoRune))) && (_base == ((0 : GoInt)))) {
                if (_prev != ((((("0" : GoString))).code : GoRune))) {
                    _invalSep = true;
                };
                _prev = ((((("_" : GoString))).code : GoRune));
            } else {
                var _d1:Word = new Word();
                if ((((((("0" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("9" : GoString))).code : GoRune)))) {
                    _d1 = (((_ch - ((((("0" : GoString))).code : GoRune))) : Word));
                } else if ((((((("a" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("z" : GoString))).code : GoRune)))) {
                    _d1 = ((((_ch - ((((("a" : GoString))).code : GoRune))) + ((10 : GoUInt8))) : Word));
                } else if ((((((("A" : GoString))).code : GoRune)) <= _ch) && (_ch <= ((((("Z" : GoString))).code : GoRune)))) {
                    if (_b <= ((36 : GoInt))) {
                        _d1 = ((((_ch - ((((("A" : GoString))).code : GoRune))) + ((10 : GoUInt8))) : Word));
                    } else {
                        _d1 = ((((_ch - ((((("A" : GoString))).code : GoRune))) + ((36 : GoUInt8))) : Word));
                    };
                } else {
                    _d1 = ((63 : GoUInt));
                };
                if (_d1 >= _b1) {
                    _r.unreadByte();
                    break;
                };
                _prev = ((((("0" : GoString))).code : GoRune));
                _count++;
                _di = (_di * _b1) + _d1;
                _i++;
                if (_i == _n) {
                    _z = (_z._mulAddWW((_z == null ? null : _z.__copy__()), _bn, _di) == null ? null : _z._mulAddWW((_z == null ? null : _z.__copy__()), _bn, _di).__copy__());
                    _di = ((0 : GoUInt));
                    _i = ((0 : GoInt));
                };
            };
            {
                var __tmp__ = _r.readByte();
                _ch = __tmp__._0;
                _err = __tmp__._1;
            };
        };
        if (_err == stdgo.io.Io.eof) {
            _err = ((null : stdgo.Error));
        };
        if ((_err == null) && (_invalSep || (_prev == ((((("_" : GoString))).code : GoRune))))) {
            _err = _errInvalSep;
        };
        if (_count == ((0 : GoInt))) {
            if (_prefix == ((((("0" : GoString))).code : GoRune))) {
                return { _0 : (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__()), _1 : ((10 : GoInt)), _2 : ((1 : GoInt)), _3 : _err };
            };
            _err = _errNoDigits;
        };
        if (_i > ((0 : GoInt))) {
            _z = (_z._mulAddWW((_z == null ? null : _z.__copy__()), _pow(_b1, _i), _di) == null ? null : _z._mulAddWW((_z == null ? null : _z.__copy__()), _pow(_b1, _i), _di).__copy__());
        };
        _res = (_z._norm() == null ? null : _z._norm().__copy__());
        if (_dp >= ((0 : GoInt))) {
            _count = _dp - _count;
        };
        return { _0 : _res, _1 : _b, _2 : _count, _3 : _err };
    }
    @:keep
    public static function _sqrt(_z:T_nat, _x:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_x._cmp((_natOne == null ? null : _natOne.__copy__())) <= ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
            _z = null;
        };
        var _z1:T_nat = new T_nat(), _z2:T_nat = new T_nat();
        _z1 = (_z == null ? null : _z.__copy__());
        _z1 = (_z1._setUint64(((1 : GoUInt64))) == null ? null : _z1._setUint64(((1 : GoUInt64))).__copy__());
        _z1 = (_z1._shl((_z1 == null ? null : _z1.__copy__()), (((_x._bitLen() + ((1 : GoInt))) : GoUInt)) / ((2 : GoUInt))) == null ? null : _z1._shl((_z1 == null ? null : _z1.__copy__()), (((_x._bitLen() + ((1 : GoInt))) : GoUInt)) / ((2 : GoUInt))).__copy__());
        {
            var _n:GoInt = ((0 : GoInt));
            Go.cfor(true, _n++, {
                {
                    var __tmp__ = _z2._div(null, (_x == null ? null : _x.__copy__()), (_z1 == null ? null : _z1.__copy__()));
                    _z2 = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                };
                _z2 = (_z2._add((_z2 == null ? null : _z2.__copy__()), (_z1 == null ? null : _z1.__copy__())) == null ? null : _z2._add((_z2 == null ? null : _z2.__copy__()), (_z1 == null ? null : _z1.__copy__())).__copy__());
                _z2 = (_z2._shr((_z2 == null ? null : _z2.__copy__()), ((1 : GoUInt))) == null ? null : _z2._shr((_z2 == null ? null : _z2.__copy__()), ((1 : GoUInt))).__copy__());
                if (_z2._cmp((_z1 == null ? null : _z1.__copy__())) >= ((0 : GoInt))) {
                    if ((_n & ((1 : GoInt))) == ((0 : GoInt))) {
                        return (_z1 == null ? null : _z1.__copy__());
                    };
                    return (_z._set((_z1 == null ? null : _z1.__copy__())) == null ? null : _z._set((_z1 == null ? null : _z1.__copy__())).__copy__());
                };
                {
                    final __tmp__0 = (_z2 == null ? null : _z2.__copy__());
                    final __tmp__1 = (_z1 == null ? null : _z1.__copy__());
                    _z1 = __tmp__0;
                    _z2 = __tmp__1;
                };
            });
        };
    }
    @:keep
    public static function _setBytes(_z:T_nat, _buf:Slice<GoByte>):T_nat {
        (_z == null ? null : _z.__copy__());
        _z = (_z._make((((_buf != null ? _buf.length : ((0 : GoInt))) + ((4 : GoInt))) - ((1 : GoInt))) / ((4 : GoInt))) == null ? null : _z._make((((_buf != null ? _buf.length : ((0 : GoInt))) + ((4 : GoInt))) - ((1 : GoInt))) / ((4 : GoInt))).__copy__());
        var _i:GoInt = (_buf != null ? _buf.length : ((0 : GoInt)));
        {
            var _k:GoInt = ((0 : GoInt));
            Go.cfor(_i >= ((4 : GoInt)), _k++, {
                if (_z != null) _z[_k] = _bigEndianWord(((_buf.__slice__(_i - ((4 : GoInt)), _i) : Slice<GoUInt8>)));
                _i = _i - (((4 : GoInt)));
            });
        };
        if (_i > ((0 : GoInt))) {
            var _d:Word = new Word();
            {
                var _s:GoUInt = ((((0 : GoUInt)) : GoUInt));
                Go.cfor(_i > ((0 : GoInt)), _s = _s + (((8 : GoUInt))), {
                    _d = _d | ((((_buf != null ? _buf[_i - ((1 : GoInt))] : ((0 : GoUInt8))) : Word)) << _s);
                    _i--;
                });
            };
            if (_z != null) _z[(_z != null ? _z.length : ((0 : GoInt))) - ((1 : GoInt))] = _d;
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _bytes(_z:T_nat, _buf:Slice<GoByte>):GoInt {
        (_z == null ? null : _z.__copy__());
        var _i:GoInt = ((0 : GoInt));
        _i = (_buf != null ? _buf.length : ((0 : GoInt)));
        for (_0 => _d in _z) {
            {
                var _j:GoInt = ((0 : GoInt));
                Go.cfor(_j < ((4 : GoInt)), _j++, {
                    _i--;
                    if (_i >= ((0 : GoInt))) {
                        if (_buf != null) _buf[_i] = ((_d : GoByte));
                    } else if (((_d : GoByte)) != ((0 : GoUInt8))) {
                        throw Go.toInterface(((("math/big: buffer too small to fit value" : GoString))));
                    };
                    _d = _d >> (((8 : GoUnTypedInt)));
                });
            };
        };
        if (_i < ((0 : GoInt))) {
            _i = ((0 : GoInt));
        };
        while ((_i < (_buf != null ? _buf.length : ((0 : GoInt)))) && ((_buf != null ? _buf[_i] : ((0 : GoUInt8))) == ((0 : GoUInt8)))) {
            _i++;
        };
        return _i;
    }
    @:keep
    public static function _expNNMontgomery(_z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _numWords:GoInt = (_m != null ? _m.length : ((0 : GoInt)));
        if ((_x != null ? _x.length : ((0 : GoInt))) > _numWords) {
            {
                var __tmp__ = ((new T_nat() : T_nat))._div(null, (_x == null ? null : _x.__copy__()), (_m == null ? null : _m.__copy__()));
                _x = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
            };
        };
        if ((_x != null ? _x.length : ((0 : GoInt))) < _numWords) {
            var _rr:T_nat = new Slice<Word>(...[for (i in 0 ... ((_numWords : GoInt)).toBasic()) new Word()]);
            Go.copySlice(_rr, _x);
            _x = (_rr == null ? null : _rr.__copy__());
        };
        var _k0:Word = ((2 : GoUInt)) - (_m != null ? _m[((0 : GoInt))] : new Word());
        var _t:Word = (_m != null ? _m[((0 : GoInt))] : new Word()) - ((1 : GoUInt));
        {
            var _i:GoInt = ((1 : GoInt));
            Go.cfor(_i < ((32 : GoInt)), _i = _i << (((1 : GoUnTypedInt))), {
                _t = _t * (_t);
                _k0 = _k0 * ((_t + ((1 : GoUInt))));
            });
        };
        _k0 = -_k0;
        var rr:T_nat = (((new T_nat() : T_nat))._setWord(((1 : GoUInt))) == null ? null : ((new T_nat() : T_nat))._setWord(((1 : GoUInt))).__copy__());
        var _zz:T_nat = (((new T_nat() : T_nat))._shl((rr == null ? null : rr.__copy__()), ((((((2 : GoInt)) * _numWords) * ((32 : GoInt))) : GoUInt))) == null ? null : ((new T_nat() : T_nat))._shl((rr == null ? null : rr.__copy__()), ((((((2 : GoInt)) * _numWords) * ((32 : GoInt))) : GoUInt))).__copy__());
        {
            var __tmp__ = ((new T_nat() : T_nat))._div((rr == null ? null : rr.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()));
            rr = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
        };
        if ((rr != null ? rr.length : ((0 : GoInt))) < _numWords) {
            _zz = (_zz._make(_numWords) == null ? null : _zz._make(_numWords).__copy__());
            Go.copySlice(_zz, rr);
            rr = (_zz == null ? null : _zz.__copy__());
        };
        var _one:T_nat = new Slice<Word>(...[for (i in 0 ... ((_numWords : GoInt)).toBasic()) new Word()]);
        if (_one != null) _one[((0 : GoInt))] = ((1 : GoUInt));
        {};
        var _powers:GoArray<T_nat> = new GoArray<T_nat>(...[for (i in 0 ... 16) new T_nat()]);
        if (_powers != null) _powers[((0 : GoInt))] = ((_powers != null ? _powers[((0 : GoInt))] : new T_nat())._montgomery((_one == null ? null : _one.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : (_powers != null ? _powers[((0 : GoInt))] : new T_nat())._montgomery((_one == null ? null : _one.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
        if (_powers != null) _powers[((1 : GoInt))] = ((_powers != null ? _powers[((1 : GoInt))] : new T_nat())._montgomery((_x == null ? null : _x.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : (_powers != null ? _powers[((1 : GoInt))] : new T_nat())._montgomery((_x == null ? null : _x.__copy__()), (rr == null ? null : rr.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
        {
            var _i:GoInt = ((2 : GoInt));
            Go.cfor(_i < ((16 : GoInt)), _i++, {
                if (_powers != null) _powers[_i] = ((_powers != null ? _powers[_i] : new T_nat())._montgomery(((_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()).__copy__()), ((_powers != null ? _powers[((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[((1 : GoInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : (_powers != null ? _powers[_i] : new T_nat())._montgomery(((_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_i - ((1 : GoInt))] : new T_nat()).__copy__()), ((_powers != null ? _powers[((1 : GoInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[((1 : GoInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
            });
        };
        _z = (_z._make(_numWords) == null ? null : _z._make(_numWords).__copy__());
        Go.copySlice(_z, (_powers != null ? _powers[((0 : GoInt))] : new T_nat()));
        _zz = (_zz._make(_numWords) == null ? null : _zz._make(_numWords).__copy__());
        {
            var _i:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                var _yi:Word = (_y != null ? _y[_i] : new Word());
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < ((32 : GoInt)), _j = _j + (((4 : GoInt))), {
                        if ((_i != ((_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt)))) || (_j != ((0 : GoInt)))) {
                            _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                            _z = (_z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                            _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                            _z = (_z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _z._montgomery((_zz == null ? null : _zz.__copy__()), (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                        };
                        _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
                        {
                            final __tmp__0 = (_zz == null ? null : _zz.__copy__());
                            final __tmp__1 = (_z == null ? null : _z.__copy__());
                            _z = __tmp__0;
                            _zz = __tmp__1;
                        };
                        _yi = _yi << (((4 : GoUnTypedInt)));
                    });
                };
            });
        };
        _zz = (_zz._montgomery((_z == null ? null : _z.__copy__()), (_one == null ? null : _one.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords) == null ? null : _zz._montgomery((_z == null ? null : _z.__copy__()), (_one == null ? null : _one.__copy__()), (_m == null ? null : _m.__copy__()), _k0, _numWords).__copy__());
        if (_zz._cmp((_m == null ? null : _m.__copy__())) >= ((0 : GoInt))) {
            _zz = (_zz._sub((_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : _zz._sub((_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
            if (_zz._cmp((_m == null ? null : _m.__copy__())) >= ((0 : GoInt))) {
                {
                    var __tmp__ = ((new T_nat() : T_nat))._div(null, (_zz == null ? null : _zz.__copy__()), (_m == null ? null : _m.__copy__()));
                    _zz = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
            };
        };
        return (_zz._norm() == null ? null : _zz._norm().__copy__());
    }
    @:keep
    public static function _expNNWindowed(_z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _zz:T_nat = new T_nat(), _r:T_nat = new T_nat();
        {};
        var _powers:GoArray<T_nat> = new GoArray<T_nat>(...[for (i in 0 ... 16) new T_nat()]);
        if (_powers != null) _powers[((0 : GoInt))] = (_natOne == null ? null : _natOne.__copy__());
        if (_powers != null) _powers[((1 : GoInt))] = (_x == null ? null : _x.__copy__());
        {
            var _i:GoInt = ((2 : GoInt));
            Go.cfor(_i < ((16 : GoInt)), _i = _i + (((2 : GoInt))), {
                var _p2:Ref<T_nat> = (_powers != null ? _powers[_i / ((2 : GoInt))] : new T_nat()), _p:Ref<T_nat> = (_powers != null ? _powers[_i] : new T_nat()), _p1:Ref<T_nat> = (_powers != null ? _powers[_i + ((1 : GoInt))] : new T_nat());
                _p = (_p._sqr((_p2 == null ? null : _p2.__copy__())) == null ? null : _p._sqr((_p2 == null ? null : _p2.__copy__())).__copy__());
                {
                    var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_p == null ? null : _p.__copy__()), (_m == null ? null : _m.__copy__()));
                    _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                {
                    final __tmp__0 = (_r == null ? null : _r.__copy__());
                    final __tmp__1 = (_p == null ? null : _p.__copy__());
                    _p = __tmp__0;
                    _r = __tmp__1;
                };
                _p1 = (_p1._mul((_p == null ? null : _p.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _p1._mul((_p == null ? null : _p.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
                {
                    var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_p1 == null ? null : _p1.__copy__()), (_m == null ? null : _m.__copy__()));
                    _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                    _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                };
                {
                    final __tmp__0 = (_r == null ? null : _r.__copy__());
                    final __tmp__1 = (_p1 == null ? null : _p1.__copy__());
                    _p1 = __tmp__0;
                    _r = __tmp__1;
                };
            });
        };
        _z = (_z._setWord(((1 : GoUInt))) == null ? null : _z._setWord(((1 : GoUInt))).__copy__());
        {
            var _i:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                var _yi:Word = (_y != null ? _y[_i] : new Word());
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < ((32 : GoInt)), _j = _j + (((4 : GoInt))), {
                        if ((_i != ((_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt)))) || (_j != ((0 : GoInt)))) {
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                            _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_r == null ? null : _r.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                _z = __tmp__0;
                                _r = __tmp__1;
                            };
                        };
                        _zz = (_zz._mul((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__())) == null ? null : _zz._mul((_z == null ? null : _z.__copy__()), ((_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()) == null ? null : (_powers != null ? _powers[_yi >> ((28 : GoUnTypedInt))] : new T_nat()).__copy__())).__copy__());
                        {
                            final __tmp__0 = (_z == null ? null : _z.__copy__());
                            final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        {
                            var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                            _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                            _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                        };
                        {
                            final __tmp__0 = (_r == null ? null : _r.__copy__());
                            final __tmp__1 = (_z == null ? null : _z.__copy__());
                            _z = __tmp__0;
                            _r = __tmp__1;
                        };
                        _yi = _yi << (((4 : GoUnTypedInt)));
                    });
                };
            });
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _expNN(_z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) || _alias((_z == null ? null : _z.__copy__()), (_y == null ? null : _y.__copy__()))) {
            _z = null;
        };
        if (((_m != null ? _m.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_m != null ? _m[((0 : GoInt))] : new Word()) == ((1 : GoUInt)))) {
            return (_z._setWord(((0 : GoUInt))) == null ? null : _z._setWord(((0 : GoUInt))).__copy__());
        };
        if ((_y != null ? _y.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return (_z._setWord(((1 : GoUInt))) == null ? null : _z._setWord(((1 : GoUInt))).__copy__());
        };
        if ((((_y != null ? _y.length : ((0 : GoInt))) == ((1 : GoInt))) && ((_y != null ? _y[((0 : GoInt))] : new Word()) == ((1 : GoUInt)))) && ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt)))) {
            {
                var __tmp__ = ((new T_nat() : T_nat))._div((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_m == null ? null : _m.__copy__()));
                _z = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
            };
            return (_z == null ? null : _z.__copy__());
        };
        if ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt))) {
            _z = (_z._make((_m != null ? _m.length : ((0 : GoInt)))) == null ? null : _z._make((_m != null ? _m.length : ((0 : GoInt)))).__copy__());
        };
        _z = (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        if (((_x._cmp((_natOne == null ? null : _natOne.__copy__())) > ((0 : GoInt))) && ((_y != null ? _y.length : ((0 : GoInt))) > ((1 : GoInt)))) && ((_m != null ? _m.length : ((0 : GoInt))) > ((0 : GoInt)))) {
            if (((_m != null ? _m[((0 : GoInt))] : new Word()) & ((1 : GoUInt))) == ((1 : GoUInt))) {
                return (_z._expNNMontgomery((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : _z._expNNMontgomery((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
            };
            return (_z._expNNWindowed((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())) == null ? null : _z._expNNWindowed((_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()), (_m == null ? null : _m.__copy__())).__copy__());
        };
        var _v:Word = (_y != null ? _y[(_y != null ? _y.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word());
        var _shift:GoUInt = _nlz(_v) + ((1 : GoUInt));
        _v = _v << (_shift);
        var _q:T_nat = new T_nat();
        {};
        var _w:GoInt = ((32 : GoInt)) - ((_shift : GoInt));
        var _zz:T_nat = new T_nat(), _r:T_nat = new T_nat();
        {
            var _j:GoInt = ((0 : GoInt));
            Go.cfor(_j < _w, _j++, {
                _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                {
                    final __tmp__0 = (_z == null ? null : _z.__copy__());
                    final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                    _zz = __tmp__0;
                    _z = __tmp__1;
                };
                if ((_v & (("2147483648" : GoUInt))) != ((0 : GoUInt))) {
                    _zz = (_zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
                    {
                        final __tmp__0 = (_z == null ? null : _z.__copy__());
                        final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                        _zz = __tmp__0;
                        _z = __tmp__1;
                    };
                };
                if ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt))) {
                    {
                        var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                        _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                        _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                    };
                    {
                        final __tmp__0 = (_q == null ? null : _q.__copy__());
                        final __tmp__1 = (_z == null ? null : _z.__copy__());
                        final __tmp__2 = (_zz == null ? null : _zz.__copy__());
                        final __tmp__3 = (_r == null ? null : _r.__copy__());
                        _zz = __tmp__0;
                        _r = __tmp__1;
                        _q = __tmp__2;
                        _z = __tmp__3;
                    };
                };
                _v = _v << (((1 : GoUnTypedInt)));
            });
        };
        {
            var _i:GoInt = (_y != null ? _y.length : ((0 : GoInt))) - ((2 : GoInt));
            Go.cfor(_i >= ((0 : GoInt)), _i--, {
                _v = (_y != null ? _y[_i] : new Word());
                {
                    var _j:GoInt = ((0 : GoInt));
                    Go.cfor(_j < ((32 : GoInt)), _j++, {
                        _zz = (_zz._sqr((_z == null ? null : _z.__copy__())) == null ? null : _zz._sqr((_z == null ? null : _z.__copy__())).__copy__());
                        {
                            final __tmp__0 = (_z == null ? null : _z.__copy__());
                            final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                            _zz = __tmp__0;
                            _z = __tmp__1;
                        };
                        if ((_v & (("2147483648" : GoUInt))) != ((0 : GoUInt))) {
                            _zz = (_zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _zz._mul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
                            {
                                final __tmp__0 = (_z == null ? null : _z.__copy__());
                                final __tmp__1 = (_zz == null ? null : _zz.__copy__());
                                _zz = __tmp__0;
                                _z = __tmp__1;
                            };
                        };
                        if ((_m != null ? _m.length : ((0 : GoInt))) != ((0 : GoInt))) {
                            {
                                var __tmp__ = _zz._div((_r == null ? null : _r.__copy__()), (_z == null ? null : _z.__copy__()), (_m == null ? null : _m.__copy__()));
                                _zz = (__tmp__._0 == null ? null : __tmp__._0.__copy__());
                                _r = (__tmp__._1 == null ? null : __tmp__._1.__copy__());
                            };
                            {
                                final __tmp__0 = (_q == null ? null : _q.__copy__());
                                final __tmp__1 = (_z == null ? null : _z.__copy__());
                                final __tmp__2 = (_zz == null ? null : _zz.__copy__());
                                final __tmp__3 = (_r == null ? null : _r.__copy__());
                                _zz = __tmp__0;
                                _r = __tmp__1;
                                _q = __tmp__2;
                                _z = __tmp__3;
                            };
                        };
                        _v = _v << (((1 : GoUnTypedInt)));
                    });
                };
            });
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _random(_z:T_nat, _rand:stdgo.math.rand.Rand.Rand, _limit:T_nat, _n:GoInt):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_alias((_z == null ? null : _z.__copy__()), (_limit == null ? null : _limit.__copy__()))) {
            _z = null;
        };
        _z = (_z._make((_limit != null ? _limit.length : ((0 : GoInt)))) == null ? null : _z._make((_limit != null ? _limit.length : ((0 : GoInt)))).__copy__());
        var _bitLengthOfMSW:GoUInt = (((_n % ((32 : GoInt))) : GoUInt));
        if (_bitLengthOfMSW == ((0 : GoUInt))) {
            _bitLengthOfMSW = ((32 : GoUInt));
        };
        var _mask:Word = ((((((1 : GoUInt)) << _bitLengthOfMSW) - ((1 : GoUInt))) : Word));
        while (true) {
            if (((32 : GoInt)) == ((32 : GoInt))) {
                for (_i => _ in _z) {
                    if (_z != null) _z[_i] = ((_rand.uint32() : Word));
                };
            } else if (((32 : GoInt)) == ((64 : GoInt))) {
                for (_i => _ in _z) {
                    if (_z != null) _z[_i] = ((_rand.uint32() : Word)) | (((_rand.uint32() : Word)) << ((32 : GoUnTypedInt)));
                };
            } else {
                throw Go.toInterface(((("unknown word size" : GoString))));
            };
            if (_z != null) (_z != null ? _z[(_limit != null ? _limit.length : ((0 : GoInt))) - ((1 : GoInt))] : new Word()) & (_mask);
            if (_z._cmp((_limit == null ? null : _limit.__copy__())) < ((0 : GoInt))) {
                break;
            };
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _xor(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        var _s:T_nat = (_x == null ? null : _x.__copy__());
        if (_m < _n) {
            {
                final __tmp__0 = _m;
                final __tmp__1 = _n;
                _n = __tmp__0;
                _m = __tmp__1;
            };
            _s = (_y == null ? null : _y.__copy__());
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) ^ (_y != null ? _y[_i] : new Word());
            });
        };
        Go.copySlice(((_z.__slice__(_n, _m) : T_nat)), ((_s.__slice__(_n, _m) : T_nat)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _or(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        var _s:T_nat = (_x == null ? null : _x.__copy__());
        if (_m < _n) {
            {
                final __tmp__0 = _m;
                final __tmp__1 = _n;
                _n = __tmp__0;
                _m = __tmp__1;
            };
            _s = (_y == null ? null : _y.__copy__());
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) | (_y != null ? _y[_i] : new Word());
            });
        };
        Go.copySlice(((_z.__slice__(_n, _m) : T_nat)), ((_s.__slice__(_n, _m) : T_nat)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _andNot(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_n > _m) {
            _n = _m;
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) & ((_y != null ? _y[_i] : new Word()) ^ ((-1 : GoUnTypedInt)));
            });
        };
        Go.copySlice(((_z.__slice__(_n, _m) : T_nat)), ((_x.__slice__(_n, _m) : T_nat)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _and(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m > _n) {
            _m = _n;
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _m, _i++, {
                if (_z != null) _z[_i] = (_x != null ? _x[_i] : new Word()) & (_y != null ? _y[_i] : new Word());
            });
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _sticky(_x:T_nat, _i:GoUInt):GoUInt {
        (_x == null ? null : _x.__copy__());
        var _j:GoUInt = _i / ((32 : GoUInt));
        if (_j >= (((_x != null ? _x.length : ((0 : GoInt))) : GoUInt))) {
            if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
                return ((0 : GoUInt));
            };
            return ((1 : GoUInt));
        };
        for (_0 => _x in ((_x.__slice__(0, _j) : T_nat))) {
            if (_x != ((0 : GoUInt))) {
                return ((1 : GoUInt));
            };
        };
        if (((_x != null ? _x[_j] : new Word()) << (((32 : GoUInt)) - (_i % ((32 : GoUInt))))) != ((0 : GoUInt))) {
            return ((1 : GoUInt));
        };
        return ((0 : GoUInt));
    }
    @:keep
    public static function _bit(_x:T_nat, _i:GoUInt):GoUInt {
        (_x == null ? null : _x.__copy__());
        var _j:GoUInt = _i / ((32 : GoUInt));
        if (_j >= (((_x != null ? _x.length : ((0 : GoInt))) : GoUInt))) {
            return ((0 : GoUInt));
        };
        return (((((_x != null ? _x[_j] : new Word()) >> (_i % ((32 : GoUInt)))) & ((1 : GoUInt))) : GoUInt));
    }
    @:keep
    public static function _setBit(_z:T_nat, _x:T_nat, _i:GoUInt, _b:GoUInt):T_nat {
        (_z == null ? null : _z.__copy__());
        var _j:GoInt = (((_i / ((32 : GoUInt))) : GoInt));
        var _m:Word = ((((1 : GoUInt)) : Word)) << (_i % ((32 : GoUInt)));
        var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_b == ((0 : GoUInt))) {
            _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
            Go.copySlice(_z, _x);
            if (_j >= _n) {
                return (_z == null ? null : _z.__copy__());
            };
            if (_z != null) (_z != null ? _z[_j] : new Word()) & ((_m) ^ ((-1 : GoUnTypedInt)));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        } else if (_b == ((1 : GoUInt))) {
            if (_j >= _n) {
                _z = (_z._make(_j + ((1 : GoInt))) == null ? null : _z._make(_j + ((1 : GoInt))).__copy__());
                ((_z.__slice__(_n) : T_nat))._clear();
            } else {
                _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
            };
            Go.copySlice(_z, _x);
            if (_z != null) (_z != null ? _z[_j] : new Word()) | (_m);
            return (_z == null ? null : _z.__copy__());
        };
        throw Go.toInterface(((("set bit is not 0 or 1" : GoString))));
    }
    @:keep
    public static function _shr(_z:T_nat, _x:T_nat, _s:GoUInt):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_s == ((0 : GoUInt))) {
            if (_same((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z == null ? null : _z.__copy__());
            };
            if (!_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
            };
        };
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = _m - (((_s / ((32 : GoUInt))) : GoInt));
        if (_n <= ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        };
        _z = (_z._make(_n) == null ? null : _z._make(_n).__copy__());
        _shrVU(_z, ((_x.__slice__(_m - _n) : T_nat)), _s % ((32 : GoUInt)));
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _shl(_z:T_nat, _x:T_nat, _s:GoUInt):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_s == ((0 : GoUInt))) {
            if (_same((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z == null ? null : _z.__copy__());
            };
            if (!_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
                return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
            };
        };
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_m == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        };
        var _n:GoInt = _m + (((_s / ((32 : GoUInt))) : GoInt));
        _z = (_z._make(_n + ((1 : GoInt))) == null ? null : _z._make(_n + ((1 : GoInt))).__copy__());
        if (_z != null) _z[_n] = _shlVU(((_z.__slice__(_n - _m, _n) : T_nat)), _x, _s % ((32 : GoUInt)));
        ((_z.__slice__(((0 : GoInt)), _n - _m) : T_nat))._clear();
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _trailingZeroBits(_x:T_nat):GoUInt {
        (_x == null ? null : _x.__copy__());
        if ((_x != null ? _x.length : ((0 : GoInt))) == ((0 : GoInt))) {
            return ((0 : GoUInt));
        };
        var _i:GoUInt = ((0 : GoUInt));
        while ((_x != null ? _x[_i] : new Word()) == ((0 : GoUInt))) {
            _i++;
        };
        return (_i * ((32 : GoUInt))) + ((stdgo.math.bits.Bits.trailingZeros((((_x != null ? _x[_i] : new Word()) : GoUInt))) : GoUInt));
    }
    @:keep
    public static function _bitLen(_x:T_nat):GoInt {
        (_x == null ? null : _x.__copy__());
        {
            var _i:GoInt = (_x != null ? _x.length : ((0 : GoInt))) - ((1 : GoInt));
            if (_i >= ((0 : GoInt))) {
                return (_i * ((32 : GoInt))) + stdgo.math.bits.Bits.len((((_x != null ? _x[_i] : new Word()) : GoUInt)));
            };
        };
        return ((0 : GoInt));
    }
    @:keep
    public static function _mulRange(_z:T_nat, _a:GoUInt64, _b:GoUInt64):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_a == ((0 : GoUInt64))) {
            return (_z._setUint64(((0 : GoUInt64))) == null ? null : _z._setUint64(((0 : GoUInt64))).__copy__());
        } else if (_a > _b) {
            return (_z._setUint64(((1 : GoUInt64))) == null ? null : _z._setUint64(((1 : GoUInt64))).__copy__());
        } else if (_a == _b) {
            return (_z._setUint64(_a) == null ? null : _z._setUint64(_a).__copy__());
        } else if ((_a + ((1 : GoUInt64))) == _b) {
            return (_z._mul((((new T_nat() : T_nat))._setUint64(_a) == null ? null : ((new T_nat() : T_nat))._setUint64(_a).__copy__()), (((new T_nat() : T_nat))._setUint64(_b) == null ? null : ((new T_nat() : T_nat))._setUint64(_b).__copy__())) == null ? null : _z._mul((((new T_nat() : T_nat))._setUint64(_a) == null ? null : ((new T_nat() : T_nat))._setUint64(_a).__copy__()), (((new T_nat() : T_nat))._setUint64(_b) == null ? null : ((new T_nat() : T_nat))._setUint64(_b).__copy__())).__copy__());
        };
        var _m:GoUInt64 = (_a + _b) / ((2 : GoUInt64));
        return (_z._mul((((new T_nat() : T_nat))._mulRange(_a, _m) == null ? null : ((new T_nat() : T_nat))._mulRange(_a, _m).__copy__()), (((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b) == null ? null : ((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b).__copy__())) == null ? null : _z._mul((((new T_nat() : T_nat))._mulRange(_a, _m) == null ? null : ((new T_nat() : T_nat))._mulRange(_a, _m).__copy__()), (((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b) == null ? null : ((new T_nat() : T_nat))._mulRange(_m + ((1 : GoUInt64)), _b).__copy__())).__copy__());
    }
    @:keep
    public static function _sqr(_z:T_nat, _x:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _n:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if (_n == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((1 : GoInt))) {
            var _d:Word = (_x != null ? _x[((0 : GoInt))] : new Word());
            _z = (_z._make(((2 : GoInt))) == null ? null : _z._make(((2 : GoInt))).__copy__());
            {
                var __tmp__ = _mulWW(_d, _d);
                if (_z != null) _z[((1 : GoInt))] = __tmp__._0;
                if (_z != null) _z[((0 : GoInt))] = __tmp__._1;
            };
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()))) {
            _z = null;
        };
        if (_n < _basicSqrThreshold) {
            _z = (_z._make(((2 : GoInt)) * _n) == null ? null : _z._make(((2 : GoInt)) * _n).__copy__());
            _basicMul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_x == null ? null : _x.__copy__()));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        if (_n < _karatsubaSqrThreshold) {
            _z = (_z._make(((2 : GoInt)) * _n) == null ? null : _z._make(((2 : GoInt)) * _n).__copy__());
            _basicSqr((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        var _k:GoInt = _karatsubaLen(_n, _karatsubaSqrThreshold);
        var _x0:T_nat = (((_x.__slice__(((0 : GoInt)), _k) : T_nat)) == null ? null : ((_x.__slice__(((0 : GoInt)), _k) : T_nat)).__copy__());
        _z = (_z._make(_max(((6 : GoInt)) * _k, ((2 : GoInt)) * _n)) == null ? null : _z._make(_max(((6 : GoInt)) * _k, ((2 : GoInt)) * _n)).__copy__());
        _karatsubaSqr((_z == null ? null : _z.__copy__()), (_x0 == null ? null : _x0.__copy__()));
        _z = (((_z.__slice__(((0 : GoInt)), ((2 : GoInt)) * _n) : T_nat)) == null ? null : ((_z.__slice__(((0 : GoInt)), ((2 : GoInt)) * _n) : T_nat)).__copy__());
        ((_z.__slice__(((2 : GoInt)) * _k) : T_nat))._clear();
        if (_k < _n) {
            var _tp:Ref<T_nat> = _getNat(((2 : GoInt)) * _k);
            var _t:T_nat = (_tp == null ? null : _tp.__copy__());
            var _x0:T_nat = (_x0._norm() == null ? null : _x0._norm().__copy__());
            var _x1:T_nat = (((_x.__slice__(_k) : T_nat)) == null ? null : ((_x.__slice__(_k) : T_nat)).__copy__());
            _t = (_t._mul((_x0 == null ? null : _x0.__copy__()), (_x1 == null ? null : _x1.__copy__())) == null ? null : _t._mul((_x0 == null ? null : _x0.__copy__()), (_x1 == null ? null : _x1.__copy__())).__copy__());
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _k);
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _k);
            _t = (_t._sqr((_x1 == null ? null : _x1.__copy__())) == null ? null : _t._sqr((_x1 == null ? null : _x1.__copy__())).__copy__());
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), ((2 : GoInt)) * _k);
            _putNat(_tp);
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _mul(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m < _n) {
            return (_z._mul((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _z._mul((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
        } else if ((_m == ((0 : GoInt))) || (_n == ((0 : GoInt)))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((1 : GoInt))) {
            return (_z._mulAddWW((_x == null ? null : _x.__copy__()), (_y != null ? _y[((0 : GoInt))] : new Word()), ((0 : GoUInt))) == null ? null : _z._mulAddWW((_x == null ? null : _x.__copy__()), (_y != null ? _y[((0 : GoInt))] : new Word()), ((0 : GoUInt))).__copy__());
        };
        if (_alias((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__())) || _alias((_z == null ? null : _z.__copy__()), (_y == null ? null : _y.__copy__()))) {
            _z = null;
        };
        if (_n < _karatsubaThreshold) {
            _z = (_z._make(_m + _n) == null ? null : _z._make(_m + _n).__copy__());
            _basicMul((_z == null ? null : _z.__copy__()), (_x == null ? null : _x.__copy__()), (_y == null ? null : _y.__copy__()));
            return (_z._norm() == null ? null : _z._norm().__copy__());
        };
        var _k:GoInt = _karatsubaLen(_n, _karatsubaThreshold);
        var _x0:T_nat = (((_x.__slice__(((0 : GoInt)), _k) : T_nat)) == null ? null : ((_x.__slice__(((0 : GoInt)), _k) : T_nat)).__copy__());
        var _y0:T_nat = (((_y.__slice__(((0 : GoInt)), _k) : T_nat)) == null ? null : ((_y.__slice__(((0 : GoInt)), _k) : T_nat)).__copy__());
        _z = (_z._make(_max(((6 : GoInt)) * _k, _m + _n)) == null ? null : _z._make(_max(((6 : GoInt)) * _k, _m + _n)).__copy__());
        _karatsuba((_z == null ? null : _z.__copy__()), (_x0 == null ? null : _x0.__copy__()), (_y0 == null ? null : _y0.__copy__()));
        _z = (((_z.__slice__(((0 : GoInt)), _m + _n) : T_nat)) == null ? null : ((_z.__slice__(((0 : GoInt)), _m + _n) : T_nat)).__copy__());
        ((_z.__slice__(((2 : GoInt)) * _k) : T_nat))._clear();
        if ((_k < _n) || (_m != _n)) {
            var _tp:Ref<T_nat> = _getNat(((3 : GoInt)) * _k);
            var _t:T_nat = (_tp == null ? null : _tp.__copy__());
            var _x0:T_nat = (_x0._norm() == null ? null : _x0._norm().__copy__());
            var _y1:T_nat = (((_y.__slice__(_k) : T_nat)) == null ? null : ((_y.__slice__(_k) : T_nat)).__copy__());
            _t = (_t._mul((_x0 == null ? null : _x0.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _t._mul((_x0 == null ? null : _x0.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
            _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _k);
            var _y0:T_nat = (_y0._norm() == null ? null : _y0._norm().__copy__());
            {
                var _i:GoInt = _k;
                Go.cfor(_i < (_x != null ? _x.length : ((0 : GoInt))), _i = _i + (_k), {
                    var _xi:T_nat = (((_x.__slice__(_i) : T_nat)) == null ? null : ((_x.__slice__(_i) : T_nat)).__copy__());
                    if ((_xi != null ? _xi.length : ((0 : GoInt))) > _k) {
                        _xi = (((_xi.__slice__(0, _k) : T_nat)) == null ? null : ((_xi.__slice__(0, _k) : T_nat)).__copy__());
                    };
                    _xi = (_xi._norm() == null ? null : _xi._norm().__copy__());
                    _t = (_t._mul((_xi == null ? null : _xi.__copy__()), (_y0 == null ? null : _y0.__copy__())) == null ? null : _t._mul((_xi == null ? null : _xi.__copy__()), (_y0 == null ? null : _y0.__copy__())).__copy__());
                    _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _i);
                    _t = (_t._mul((_xi == null ? null : _xi.__copy__()), (_y1 == null ? null : _y1.__copy__())) == null ? null : _t._mul((_xi == null ? null : _xi.__copy__()), (_y1 == null ? null : _y1.__copy__())).__copy__());
                    _addAt((_z == null ? null : _z.__copy__()), (_t == null ? null : _t.__copy__()), _i + _k);
                });
            };
            _putNat(_tp);
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _montgomery(_z:T_nat, _x:T_nat, _y:T_nat, _m:T_nat, _k:Word, _n:GoInt):T_nat {
        (_z == null ? null : _z.__copy__());
        if ((((_x != null ? _x.length : ((0 : GoInt))) != _n) || ((_y != null ? _y.length : ((0 : GoInt))) != _n)) || ((_m != null ? _m.length : ((0 : GoInt))) != _n)) {
            throw Go.toInterface(((("math/big: mismatched montgomery number lengths" : GoString))));
        };
        _z = (_z._make(_n * ((2 : GoInt))) == null ? null : _z._make(_n * ((2 : GoInt))).__copy__());
        _z._clear();
        var _c:Word = new Word();
        {
            var _i:GoInt = ((0 : GoInt));
            Go.cfor(_i < _n, _i++, {
                var _d:Word = (_y != null ? _y[_i] : new Word());
                var _c2:Word = _addMulVVW(((_z.__slice__(_i, _n + _i) : T_nat)), _x, _d);
                var _t:Word = (_z != null ? _z[_i] : new Word()) * _k;
                var _c3:Word = _addMulVVW(((_z.__slice__(_i, _n + _i) : T_nat)), _m, _t);
                var _cx:Word = _c + _c2;
                var _cy:Word = _cx + _c3;
                if (_z != null) _z[_n + _i] = _cy;
                if ((_cx < _c2) || (_cy < _c3)) {
                    _c = ((1 : GoUInt));
                } else {
                    _c = ((0 : GoUInt));
                };
            });
        };
        if (_c != ((0 : GoUInt))) {
            _subVV(((_z.__slice__(0, _n) : T_nat)), ((_z.__slice__(_n) : T_nat)), _m);
        } else {
            Go.copySlice(((_z.__slice__(0, _n) : T_nat)), ((_z.__slice__(_n) : T_nat)));
        };
        return (((_z.__slice__(0, _n) : T_nat)) == null ? null : ((_z.__slice__(0, _n) : T_nat)).__copy__());
    }
    @:keep
    public static function _mulAddWW(_z:T_nat, _x:T_nat, _y:Word, _r:Word):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        if ((_m == ((0 : GoInt))) || (_y == ((0 : GoUInt)))) {
            return (_z._setWord(_r) == null ? null : _z._setWord(_r).__copy__());
        };
        _z = (_z._make(_m + ((1 : GoInt))) == null ? null : _z._make(_m + ((1 : GoInt))).__copy__());
        if (_z != null) _z[_m] = _mulAddVWW(((_z.__slice__(((0 : GoInt)), _m) : T_nat)), _x, _y, _r);
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _cmp(_x:T_nat, _y:T_nat):GoInt {
        (_x == null ? null : _x.__copy__());
        var _r:GoInt = ((0 : GoInt));
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if ((_m != _n) || (_m == ((0 : GoInt)))) {
            if (_m < _n) {
                _r = ((-1 : GoInt));
            } else if (_m > _n) {
                _r = ((1 : GoInt));
            };
            return _r;
        };
        var _i:GoInt = _m - ((1 : GoInt));
        while ((_i > ((0 : GoInt))) && ((_x != null ? _x[_i] : new Word()) == (_y != null ? _y[_i] : new Word()))) {
            _i--;
        };
        if ((_x != null ? _x[_i] : new Word()) < (_y != null ? _y[_i] : new Word())) {
            _r = ((-1 : GoInt));
        } else if ((_x != null ? _x[_i] : new Word()) > (_y != null ? _y[_i] : new Word())) {
            _r = ((1 : GoInt));
        };
        return _r;
    }
    @:keep
    public static function _sub(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m < _n) {
            throw Go.toInterface(((("underflow" : GoString))));
        } else if (_m == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        _z = (_z._make(_m) == null ? null : _z._make(_m).__copy__());
        var _c:Word = _subVV(((_z.__slice__(((0 : GoInt)), _n) : T_nat)), _x, _y);
        if (_m > _n) {
            _c = _subVW(((_z.__slice__(_n) : T_nat)), ((_x.__slice__(_n) : T_nat)), _c);
        };
        if (_c != ((0 : GoUInt))) {
            throw Go.toInterface(((("underflow" : GoString))));
        };
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _add(_z:T_nat, _x:T_nat, _y:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _m:GoInt = (_x != null ? _x.length : ((0 : GoInt)));
        var _n:GoInt = (_y != null ? _y.length : ((0 : GoInt)));
        if (_m < _n) {
            return (_z._add((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())) == null ? null : _z._add((_y == null ? null : _y.__copy__()), (_x == null ? null : _x.__copy__())).__copy__());
        } else if (_m == ((0 : GoInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        } else if (_n == ((0 : GoInt))) {
            return (_z._set((_x == null ? null : _x.__copy__())) == null ? null : _z._set((_x == null ? null : _x.__copy__())).__copy__());
        };
        _z = (_z._make(_m + ((1 : GoInt))) == null ? null : _z._make(_m + ((1 : GoInt))).__copy__());
        var _c:Word = _addVV(((_z.__slice__(((0 : GoInt)), _n) : T_nat)), _x, _y);
        if (_m > _n) {
            _c = _addVW(((_z.__slice__(_n, _m) : T_nat)), ((_x.__slice__(_n) : T_nat)), _c);
        };
        if (_z != null) _z[_m] = _c;
        return (_z._norm() == null ? null : _z._norm().__copy__());
    }
    @:keep
    public static function _set(_z:T_nat, _x:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        _z = (_z._make((_x != null ? _x.length : ((0 : GoInt)))) == null ? null : _z._make((_x != null ? _x.length : ((0 : GoInt)))).__copy__());
        Go.copySlice(_z, _x);
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public static function _setUint64(_z:T_nat, _x:GoUInt64):T_nat {
        (_z == null ? null : _z.__copy__());
        {
            var _w:Word = ((_x : Word));
            if (((_w : GoUInt64)) == _x) {
                return (_z._setWord(_w) == null ? null : _z._setWord(_w).__copy__());
            };
        };
        _z = (_z._make(((2 : GoInt))) == null ? null : _z._make(((2 : GoInt))).__copy__());
        if (_z != null) _z[((1 : GoInt))] = (((_x >> ((32 : GoUnTypedInt))) : Word));
        if (_z != null) _z[((0 : GoInt))] = ((_x : Word));
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public static function _setWord(_z:T_nat, _x:Word):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_x == ((0 : GoUInt))) {
            return (((_z.__slice__(0, ((0 : GoInt))) : T_nat)) == null ? null : ((_z.__slice__(0, ((0 : GoInt))) : T_nat)).__copy__());
        };
        _z = (_z._make(((1 : GoInt))) == null ? null : _z._make(((1 : GoInt))).__copy__());
        if (_z != null) _z[((0 : GoInt))] = _x;
        return (_z == null ? null : _z.__copy__());
    }
    @:keep
    public static function _make(_z:T_nat, _n:GoInt):T_nat {
        (_z == null ? null : _z.__copy__());
        if (_n <= (_z != null ? _z.cap() : ((0 : GoInt)))) {
            return (((_z.__slice__(0, _n) : T_nat)) == null ? null : ((_z.__slice__(0, _n) : T_nat)).__copy__());
        };
        if (_n == ((1 : GoInt))) {
            return new Slice<Word>(...[for (i in 0 ... ((((1 : GoInt)) : GoInt)).toBasic()) new Word()]);
        };
        {};
        return (new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]).__setCap__(((_n + ((4 : GoInt)) : GoInt)).toBasic()) == null ? null : new Slice<Word>(...[for (i in 0 ... ((_n : GoInt)).toBasic()) new Word()]).__setCap__(((_n + ((4 : GoInt)) : GoInt)).toBasic()).__copy__());
    }
    @:keep
    public static function _norm(_z:T_nat):T_nat {
        (_z == null ? null : _z.__copy__());
        var _i:GoInt = (_z != null ? _z.length : ((0 : GoInt)));
        while ((_i > ((0 : GoInt))) && ((_z != null ? _z[_i - ((1 : GoInt))] : new Word()) == ((0 : GoUInt)))) {
            _i--;
        };
        return (((_z.__slice__(((0 : GoInt)), _i) : T_nat)) == null ? null : ((_z.__slice__(((0 : GoInt)), _i) : T_nat)).__copy__());
    }
    @:keep
    public static function _clear(_z:T_nat):Void {
        (_z == null ? null : _z.__copy__());
        for (_i => _ in _z) {
            if (_z != null) _z[_i] = ((0 : GoUInt));
        };
    }
}
class T_funNN_wrapper {
    public var __t__ : T_funNN;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
class T_ratBinFun_wrapper {
    public var __t__ : T_ratBinFun;
    public function new(__t__) this.__t__ = __t__;
    public function __underlying__():AnyInterface return Go.toInterface(this);
}
